<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.VisualStudio.Threading</name>
    </assembly>
    <members>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent">
            <summary>
            An asynchronous implementation of an AutoResetEvent.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.signalAwaiters">
            <summary>
            A queue of folks awaiting signals.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.allowInliningAwaiters">
            <summary>
            Whether to complete the task synchronously in the <see cref="M:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.Set" /> method,
            as opposed to asynchronously.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.onCancellationRequestHandler">
            <summary>
            A reusable delegate that points to the <see cref="M:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.OnCancellationRequest(System.Object)" /> method.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.signaled">
            <summary>
            A value indicating whether this event is already in a signaled state.
            </summary>
            <devremarks>
            This should not need the volatile modifier because it is
            always accessed within a lock.
            </devremarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent" /> class
            that does not inline awaiters.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent" /> class.
            </summary>
            <param name="allowInliningAwaiters">
            A value indicating whether to complete the task synchronously in the <see cref="M:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.Set" /> method,
            as opposed to asynchronously. <c>false</c> better simulates the behavior of the
            <see cref="T:System.Threading.AutoResetEvent" /> class, but <c>true</c> can result in slightly better performance.
            </param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.WaitAsync">
            <summary>
            Returns an awaitable that may be used to asynchronously acquire the next signal.
            </summary>
            <returns>An awaitable.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.WaitAsync(System.Threading.CancellationToken)">
            <summary>
            Returns an awaitable that may be used to asynchronously acquire the next signal.
            </summary>
            <param name="cancellationToken">A token whose cancellation removes the caller from the queue of those waiting for the event.</param>
            <returns>An awaitable.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.Set">
            <summary>
            Unblocks one waiter or sets the signal if no waiters are present so the next waiter may proceed immediately.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.OnCancellationRequest(System.Object)">
            <summary>
            Responds to cancellation requests by removing the request from the waiter queue.
            </summary>
            <param name="state">The <see cref="T:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.WaiterCompletionSource" /> passed in to the <see cref="M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object)" /> method.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.WaiterCompletionSource">
            <summary>
            Tracks someone waiting for a signal from the event.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.WaiterCompletionSource.#ctor(Microsoft.VisualStudio.Threading.AsyncAutoResetEvent,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.WaiterCompletionSource" /> class.
            </summary>
            <param name="owner">The event that is initializing this value.</param>
            <param name="allowInliningContinuations"><c>true</c> to allow continuations to be inlined upon the completer's callstack.</param>
            <param name="cancellationToken">The cancellation token associated with the waiter.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.WaiterCompletionSource.CancellationToken">
            <summary>
            Gets the <see cref="P:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.WaiterCompletionSource.CancellationToken" /> provided by the waiter.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.WaiterCompletionSource.Registration">
            <summary>
            Gets the registration to dispose of when the waiter receives their event.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncBarrier">
            <summary>
            An asynchronous barrier that blocks the signaler until all other participants have signaled.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncBarrier.participantCount">
            <summary>
            The number of participants being synchronized.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncBarrier.waiters">
            <summary>
            The set of participants who have reached the barrier, with their awaiters that can resume those participants.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncBarrier.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncBarrier" /> class.
            </summary>
            <param name="participants">The number of participants.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncBarrier.SignalAndWait">
            <summary>
            Signals that a participant is ready, and returns a Task
            that completes when all other participants have also signaled ready.
            </summary>
            <returns>A Task, which will complete (or may already be completed) when the last participant calls this method.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncCountdownEvent">
            <summary>
            An asynchronous style countdown event.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncCountdownEvent.manualEvent">
            <summary>
            The manual reset event we use to signal all awaiters.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncCountdownEvent.remainingCount">
            <summary>
            The remaining number of signals required before we can unblock waiters.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncCountdownEvent.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncCountdownEvent" /> class.
            </summary>
            <param name="initialCount">The number of signals required to unblock awaiters.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncCountdownEvent.WaitAsync">
            <summary>
            Returns an awaitable that executes the continuation when the countdown reaches zero.
            </summary>
            <returns>An awaitable.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncCountdownEvent.SignalAsync">
            <summary>
            Decrements the counter by one.
            </summary>
            <returns>
            A task that completes when the signal has been set if this call causes the count to reach zero.
            If the count is not zero, a completed task is returned.
            </returns>
            <remarks>
            <para>
            On .NET versions prior to 4.6:
            This method may return before the signal set has propagated.
            The returned task completes when the signal has definitely been set.
            </para>
            <para>
            On .NET 4.6 and later:
            This method is not asynchronous. The returned Task is always completed.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncCountdownEvent.Signal">
            <summary>
            Decrements the counter by one.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncCountdownEvent.SignalAndWaitAsync">
            <summary>
            Decrements the counter by one and returns an awaitable that executes the continuation when the countdown reaches zero.
            </summary>
            <returns>An awaitable.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncEventHandler">
            <summary>
            An asynchronous event handler.
            </summary>
            <param name="sender">The sender of the event.</param>
            <param name="args">Event arguments.</param>
            <returns>A task whose completion signals handling is finished.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncEventHandler`1">
            <summary>
            An asynchronous event handler.
            </summary>
            <typeparam name="TEventArgs">The type of event arguments.</typeparam>
            <param name="sender">The sender of the event.</param>
            <param name="args">Event arguments.</param>
            <returns>A task whose completion signals handling is finished.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncLazyInitializer">
            <summary>
            Lazily executes a delegate that has some side effect (typically initializing something)
            such that the delegate runs at most once.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLazyInitializer.lazy">
            <summary>
            The lazy instance we use internally for the bulk of the behavior we want.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncLazyInitializer.#ctor(System.Func{System.Threading.Tasks.Task},Microsoft.VisualStudio.Threading.JoinableTaskFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncLazyInitializer" /> class.
            </summary>
            <param name="action">The action to perform at most once, that has some desirable side-effect.</param>
            <param name="joinableTaskFactory">The factory to use when invoking the <paramref name="action" /> in <see cref="M:Microsoft.VisualStudio.Threading.AsyncLazyInitializer.InitializeAsync(System.Threading.CancellationToken)" /> to avoid deadlocks when the main thread is required by the <paramref name="action" />.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncLazyInitializer.IsCompleted">
            <summary>
            Gets a value indicating whether the action has executed completely, regardless of whether it threw an exception.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncLazyInitializer.IsCompletedSuccessfully">
            <summary>
            Gets a value indicating whether the action has executed completely without throwing an exception.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncLazyInitializer.Initialize(System.Threading.CancellationToken)">
            <summary>
            Executes the action given in the constructor if it has not yet been executed,
            or waits for it to complete if in progress from a prior call.
            </summary>
            <exception cref="T:System.Exception">Any exception thrown by the action is rethrown here.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncLazyInitializer.InitializeAsync(System.Threading.CancellationToken)">
            <summary>
            Executes the action given in the constructor if it has not yet been executed,
            or waits for it to complete if in progress from a prior call.
            </summary>
            <returns>A task that tracks completion of the action.</returns>
            <exception cref="T:System.Exception">Any exception thrown by the action is rethrown here.</exception>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncLazy`1">
            <summary>
            A thread-safe, lazily and asynchronously evaluated value factory.
            </summary>
            <typeparam name="T">The type of value generated by the value factory.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLazy`1.RecursiveCheckSentinel">
            <summary>
            The value set to the <see cref="F:Microsoft.VisualStudio.Threading.AsyncLazy`1.recursiveFactoryCheck" /> field
            while the value factory is executing.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLazy`1.syncObject">
            <summary>
            The object to lock to provide thread-safety.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLazy`1.recursiveFactoryCheck">
            <summary>
            The unique instance identifier.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLazy`1.valueFactory">
            <summary>
            The function to invoke to produce the task.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLazy`1.jobFactory">
            <summary>
            The async pump to Join on calls to <see cref="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.GetValueAsync(System.Threading.CancellationToken)" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLazy`1.value">
            <summary>
            The result of the value factory.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLazy`1.joinableTask">
            <summary>
            A joinable task whose result is the value to be cached.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.#ctor(System.Func{System.Threading.Tasks.Task{`0}},Microsoft.VisualStudio.Threading.JoinableTaskFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncLazy`1" /> class.
            </summary>
            <param name="valueFactory">The async function that produces the value.  To be invoked at most once.</param>
            <param name="joinableTaskFactory">The factory to use when invoking the value factory in <see cref="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.GetValueAsync(System.Threading.CancellationToken)" /> to avoid deadlocks when the main thread is required by the value factory.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncLazy`1.IsValueCreated">
            <summary>
            Gets a value indicating whether the value factory has been invoked.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncLazy`1.IsValueFactoryCompleted">
            <summary>
            Gets a value indicating whether the value factory has been invoked and has run to completion.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.GetValueAsync">
            <summary>
            Gets the task that produces or has produced the value.
            </summary>
            <returns>A task whose result is the lazily constructed value.</returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the value factory calls <see cref="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.GetValueAsync" /> on this instance.
            </exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.GetValueAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the task that produces or has produced the value.
            </summary>
            <param name="cancellationToken">
            A token whose cancellation indicates that the caller no longer is interested in the result.
            Note that this will not cancel the value factory (since other callers may exist).
            But this token will result in an expediant cancellation of the returned Task,
            and a dis-joining of any <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" /> that may have occurred as a result of this call.
            </param>
            <returns>A task whose result is the lazily constructed value.</returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the value factory calls <see cref="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.GetValueAsync" /> on this instance.
            </exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.GetValue">
            <summary>
            Gets the lazily computed value.
            </summary>
            <returns>The lazily constructed value.</returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the value factory calls <see cref="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.GetValueAsync" /> on this instance.
            </exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.GetValue(System.Threading.CancellationToken)">
            <summary>
            Gets the lazily computed value.
            </summary>
            <param name="cancellationToken">
            A token whose cancellation indicates that the caller no longer is interested in the result.
            Note that this will not cancel the value factory (since other callers may exist).
            But when this token is canceled, the caller will experience an <see cref="T:System.OperationCanceledException" />
            immediately and a dis-joining of any <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" /> that may have occurred as a result of this call.
            </param>
            <returns>The lazily constructed value.</returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the value factory calls <see cref="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.GetValueAsync" /> on this instance.
            </exception>
            <exception cref="T:System.OperationCanceledException">Thrown when <paramref name="cancellationToken" /> is canceled before the value is computed.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.ToString">
            <summary>
            Renders a string describing an uncreated value, or the string representation of the created value.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncLocal`1">
            <summary>
            Stores references such that they are available for retrieval
            in the same call context.
            </summary>
            <typeparam name="T">The type of value to store.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLocal`1.asyncLocal">
            <summary>
            The framework version specific instance of AsyncLocal to use.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncLocal`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncLocal`1" /> class.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncLocal`1.Value">
            <summary>
            Gets or sets the value to associate with the current CallContext.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncManualResetEvent">
            <summary>
            A flavor of <see cref="T:System.Threading.ManualResetEvent" /> that can be asynchronously awaited on.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.allowInliningAwaiters">
            <summary>
            Whether the task completion source should allow executing continuations synchronously.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.syncObject">
            <summary>
            The object to lock when accessing fields.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.taskCompletionSource">
            <summary>
            The source of the task to return from <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.WaitAsync" />.
            </summary>
            <devremarks>
            This should not need the volatile modifier because it is
            always accessed within a lock.
            </devremarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.isSet">
            <summary>
            A flag indicating whether the event is signaled.
            When this is set to true, it's possible that
            <see cref="F:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.taskCompletionSource" />.Task.IsCompleted is still false
            if the completion has been scheduled asynchronously.
            Thus, this field should be the definitive answer as to whether
            the event is signaled because it is synchronously updated.
            </summary>
            <devremarks>
            This should not need the volatile modifier because it is
            always accessed within a lock.
            </devremarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncManualResetEvent" /> class.
            </summary>
            <param name="initialState">A value indicating whether the event should be initially signaled.</param>
            <param name="allowInliningAwaiters">
            A value indicating whether to allow <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.WaitAsync" /> callers' continuations to execute
            on the thread that calls <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.SetAsync" /> before the call returns.
            <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.SetAsync" /> callers should not hold private locks if this value is <c>true</c> to avoid deadlocks.
            When <c>false</c>, the task returned from <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.WaitAsync" /> may not have fully transitioned to
            its completed state by the time <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.SetAsync" /> returns to its caller.
            </param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.IsSet">
            <summary>
            Gets a value indicating whether the event is currently in a signaled state.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.WaitAsync">
            <summary>
            Returns a task that will be completed when this event is set.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.WaitAsync(System.Threading.CancellationToken)">
            <summary>
            Returns a task that will be completed when this event is set.
            </summary>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>A task that completes when the event is set, or cancels with the <paramref name="cancellationToken" />.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.SetAsync">
            <summary>
            Sets this event to unblock callers of <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.WaitAsync" />.
            </summary>
            <returns>A task that completes when the signal has been set.</returns>
            <remarks>
            <para>
            On .NET versions prior to 4.6:
            This method may return before the signal set has propagated (so <see cref="P:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.IsSet" /> may return <c>false</c> for a bit more if called immediately).
            The returned task completes when the signal has definitely been set.
            </para>
            <para>
            On .NET 4.6 and later:
            This method is not asynchronous. The returned Task is always completed.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.Set">
            <summary>
            Sets this event to unblock callers of <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.WaitAsync" />.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.Reset">
            <summary>
            Resets this event to a state that will block callers of <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.WaitAsync" />.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.PulseAllAsync">
            <summary>
            Sets and immediately resets this event, allowing all current waiters to unblock.
            </summary>
            <returns>A task that completes when the signal has been set.</returns>
            <remarks>
            <para>
            On .NET versions prior to 4.6:
            This method may return before the signal set has propagated (so <see cref="P:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.IsSet" /> may return <c>false</c> for a bit more if called immediately).
            The returned task completes when the signal has definitely been set.
            </para>
            <para>
            On .NET 4.6 and later:
            This method is not asynchronous. The returned Task is always completed.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.PulseAll">
            <summary>
            Sets and immediately resets this event, allowing all current waiters to unblock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.GetAwaiter">
            <summary>
            Gets an awaiter that completes when this event is signaled.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.CreateTaskSource">
            <summary>
            Creates a new TaskCompletionSource to represent an unset event.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncQueue`1">
            <summary>
            A thread-safe, asynchronously dequeuable queue.
            </summary>
            <typeparam name="T">The type of values kept by the queue.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncQueue`1.completedSource">
            <summary>
            The source of the task returned by <see cref="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.Completion" />. Lazily constructed.
            </summary>
            <remarks>
            Volatile to allow the check-lock-check pattern in <see cref="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.Completion" /> to be reliable,
            in the event that within the lock, one thread initializes the value and assigns the field
            and the weak memory model allows the assignment prior to the initialization. Another thread
            outside the lock might observe the non-null field and start accessing the Task property
            before it is actually initialized. Volatile prevents CPU reordering of commands around
            the assignment (or read) of this field.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncQueue`1.queueElements">
            <summary>
            The internal queue of elements. Lazily constructed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncQueue`1.dequeuingWaiters">
            <summary>
            The internal queue of <see cref="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.DequeueAsync(System.Threading.CancellationToken)" /> waiters. Lazily constructed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncQueue`1.completeSignaled">
            <summary>
            A value indicating whether <see cref="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.Complete" /> has been called.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncQueue`1.onCompletedInvoked">
            <summary>
            A flag indicating whether the <see cref="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.OnCompleted" /> has been invoked.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncQueue`1" /> class.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.IsEmpty">
            <summary>
            Gets a value indicating whether the queue is currently empty.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.Count">
            <summary>
            Gets the number of elements currently in the queue.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.IsCompleted">
            <summary>
            Gets a value indicating whether the queue has completed.
            </summary>
            <remarks>
            This is arguably redundant with <see cref="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.Completion" />.IsCompleted, but this property
            won't cause the lazy instantiation of the Task that <see cref="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.Completion" /> may if there
            is no other reason for the Task to exist.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.Completion">
            <summary>
            Gets a task that transitions to a completed state when <see cref="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.Complete" /> is called.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.SyncRoot">
            <summary>
            Gets the synchronization object used by this queue.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.InitialCapacity">
            <summary>
            Gets the initial capacity for the queue.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.Complete">
            <summary>
            Signals that no further elements will be enqueued.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.Enqueue(`0)">
            <summary>
            Adds an element to the tail of the queue.
            </summary>
            <param name="value">The value to add.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.TryEnqueue(`0)">
            <summary>
            Adds an element to the tail of the queue if it has not yet completed.
            </summary>
            <param name="value">The value to add.</param>
            <returns><c>true</c> if the value was added to the queue; <c>false</c> if the queue is already completed.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.TryPeek(`0@)">
            <summary>
            Gets the value at the head of the queue without removing it from the queue, if it is non-empty.
            </summary>
            <param name="value">Receives the value at the head of the queue; or the default value for the element type if the queue is empty.</param>
            <returns><c>true</c> if the queue was non-empty; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.Peek">
            <summary>
            Gets the value at the head of the queue without removing it from the queue.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the queue is empty.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.DequeueAsync(System.Threading.CancellationToken)">
            <summary>
            Gets a task whose result is the element at the head of the queue.
            </summary>
            <param name="cancellationToken">
            A token whose cancellation signals lost interest in the item.
            Cancelling this token does *not* guarantee that the task will be canceled
            before it is assigned a resulting element from the head of the queue.
            It is the responsibility of the caller to ensure after cancellation that
            either the task is canceled, or it has a result which the caller is responsible
            for then handling.
            </param>
            <returns>A task whose result is the head element.</returns>
            <exception cref="T:System.OperationCanceledException">
            Thrown when this instance has an empty queue and <see cref="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.Complete" /> has been called.
            Also thrown when <paramref name="cancellationToken" /> is canceled before a work item can be dequeued.
            </exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.TryDequeue(`0@)">
            <summary>
            Immediately dequeues the element from the head of the queue if one is available,
            otherwise returns without an element.
            </summary>
            <param name="value">Receives the element from the head of the queue; or <c>default(T)</c> if the queue is empty.</param>
            <returns><c>true</c> if an element was dequeued; <c>false</c> if the queue was empty.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.Microsoft#VisualStudio#Threading#ThreadingTools#ICancellationNotification#OnCanceled">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.ToArray">
            <summary>
            Returns a copy of this queue as an array.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.TryDequeue(System.Predicate{`0},`0@)">
            <summary>
            Immediately dequeues the element from the head of the queue if one is available
            that satisfies the specified check;
            otherwise returns without an element.
            </summary>
            <param name="valueCheck">The test on the head element that must succeed to dequeue.</param>
            <param name="value">Receives the element from the head of the queue; or <c>default(T)</c> if the queue is empty.</param>
            <returns><c>true</c> if an element was dequeued; <c>false</c> if the queue was empty.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.OnEnqueued(`0,System.Boolean)">
            <summary>
            Invoked when a value is enqueued.
            </summary>
            <param name="value">The enqueued value.</param>
            <param name="alreadyDispatched">
            <c>true</c> if the item will skip the queue because a dequeuer was already waiting for an item;
            <c>false</c> if the item was actually added to the queue.
            </param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.OnDequeued(`0)">
            <summary>
            Invoked when a value is dequeued.
            </summary>
            <param name="value">The dequeued value.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.OnCompleted">
            <summary>
            Invoked when the queue is completed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.TryDequeueInternal(System.Predicate{`0},`0@)">
            <summary>
            Immediately dequeues the element from the head of the queue if one is available,
            otherwise returns without an element.
            </summary>
            <param name="valueCheck">The test on the head element that must succeed to dequeue.</param>
            <param name="value">Receives the element from the head of the queue; or <c>default(T)</c> if the queue is empty.</param>
            <returns><c>true</c> if an element was dequeued; <c>false</c> if the queue was empty.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.CompleteIfNecessary">
            <summary>
            Transitions this queue to a completed state if signaled and the queue is empty.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.FreeCanceledDequeuers">
            <summary>
            Clears as many canceled dequeuers as we can from the head of the waiting queue.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock">
            <summary>
            A non-blocking lock that allows concurrent access, exclusive access, or concurrent with upgradeability to exclusive access.
            </summary>
            <remarks>
            We have to use a custom awaitable rather than simply returning Task{LockReleaser} because
            we have to set CallContext data in the context of the person receiving the lock,
            which requires that we get to execute code at the start of the continuation (whether we yield or not).
            </remarks>
            <devnotes>
            Considering this class to be a state machine, the states are:
            <code>
            <![CDATA[
               -------------
               |           | <-----> READERS
               |    IDLE   | <-----> UPGRADEABLE READER + READERS -----> UPGRADED WRITER --\
               |  NO LOCKS |                             ^                                 |
               |           |                             |--- RE-ENTER CONCURRENCY PREP <--/
               |           | <-----> WRITER
               -------------
            ]]>
            </code>
            </devnotes>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.NoMessagePumpSynchronizationContext">
            <summary>
            Gets a <see cref="T:System.Threading.SynchronizationContext" /> which, when applied,
            suppresses any message pump that may run during synchronous blocks
            of the calling thread.
            </summary>
            <remarks>
            The default implementation of this property is effective
            in builds of this assembly that target the .NET Framework.
            But on builds that target the portable profile, it should be
            overridden to provide an effective platform-specific solution.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Microsoft#VisualStudio#Threading#IHangReportContributor#GetHangReport">
            <summary>
            Contributes data for a hang report.
            </summary>
            <returns>The hang report contribution. Null values should be ignored.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.GetHangReport">
            <summary>
            Contributes data for a hang report.
            </summary>
            <returns>The hang report contribution. Null values should be ignored.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.CreateAwaiterNode(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Appends details of a given collection of awaiters to the hang report.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.DefaultDeadlockCheckTimeout">
            <summary>
            A time delay to check whether pending writer lock and reader locks forms a deadlock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.DefaultSynchronizationContext">
            <summary>
            The default SynchronizationContext to schedule work after issuing a lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.syncObject">
            <summary>
            The object to acquire a Monitor-style lock on for all field access on this instance.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.joinableTaskContext">
            <summary>
            A JoinableTaskContext used to resolve dependencies between read locks to lead into deadlocks when there is a pending write lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.topAwaiter">
            <summary>
            A CallContext-local reference to the Awaiter that is on the top of the stack (most recently acquired).
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.issuedReadLocks">
            <summary>
            The set of read locks that are issued and active.
            </summary>
            <remarks>
            Many readers are allowed concurrently.  Also, readers may re-enter read locks (recursively)
            each of which gets an element in this set.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.issuedUpgradeableReadLocks">
            <summary>
            The set of upgradeable read locks that are issued and active.
            </summary>
            <remarks>
            Although only one upgradeable read lock can be held at a time, this set may have more
            than one element because that one lock holder may enter the lock it already possesses
            multiple times.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.issuedWriteLocks">
            <summary>
            The set of write locks that are issued and active.
            </summary>
            <remarks>
            Although only one write lock can be held at a time, this set may have more
            than one element because that one lock holder may enter the lock it already possesses
            multiple times.
            Although this lock is mutually exclusive, there *may* be elements in the
            <see cref="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.issuedUpgradeableReadLocks" /> set if the write lock was upgraded from a reader.
            Also note that some elements in this may themselves be upgradeable readers if they have
            the <see cref="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags.StickyWrite" /> flag.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.waitingReaders">
            <summary>
            A queue of readers waiting to obtain the concurrent read lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.waitingUpgradeableReaders">
            <summary>
            A queue of upgradeable readers waiting to obtain a lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.waitingWriters">
            <summary>
            A queue of writers waiting to obtain an exclusive lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.completionSource">
            <summary>
            The source of the <see cref="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Completion" /> task, which transitions to completed after
            the <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Complete" /> method is called and all issued locks have been released.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.beforeWriteReleasedCallbacks">
            <summary>
            The queue of callbacks to invoke when the currently held write lock is totally released.
            </summary>
            <remarks>
            If the write lock is released to an upgradeable read lock, these callbacks are fired synchronously
            with respect to the writer who is releasing the lock.  Otherwise, the callbacks are invoked
            asynchronously with respect to the releasing thread.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.captureDiagnostics">
            <summary>
            A value indicating whether extra resources should be spent to collect diagnostic information
            that may be useful in deadlock investigations.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.reenterConcurrencyPrepRunning">
            <summary>
            A flag indicating whether we're currently running code to prepare for re-entering concurrency mode
            after releasing an exclusive lock. The Awaiter being released is the non-null value.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.completeInvoked">
            <summary>
            A flag indicating that the <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Complete" /> method has been called, indicating that no
            new top-level lock requests should be serviced.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.etw">
            <summary>
            A helper class to produce ETW trace events.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.pendingWriterLockDeadlockCheckTimer">
            <summary>
            A timer to recheck potential deadlock caused by pending writer locks.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock" /> class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock" /> class.
            </summary>
            <param name="captureDiagnostics">
            <c>true</c> to spend additional resources capturing diagnostic details that can be used
            to analyze deadlocks or other issues.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskContext,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock" /> class.
            </summary>
            <param name="joinableTaskContext">
            A JoinableTaskContext to help resolve deadlocks caused by interdependency between top read lock tasks when there is a pending write lock blocking one of them.
            </param>
            <param name="captureDiagnostics">
            <c>true</c> to spend additional resources capturing diagnostic details that can be used
            to analyze deadlocks or other issues.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags">
            <summary>
            Flags that modify default lock behavior.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags.None">
            <summary>
            The default behavior applies.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags.StickyWrite">
            <summary>
            Causes an upgradeable reader to remain in an upgraded-write state once upgraded,
            even after the nested write lock has been released.
            </summary>
            <remarks>
            This is useful when you have a batch of possible write operations to apply, which
            may or may not actually apply in the end, but if any of them change anything,
            all of their changes should be seen atomically (within a single write lock).
            This approach is preferable to simply acquiring a write lock around the batch of
            potential changes because it doesn't defeat concurrent readers until it knows there
            is a change to actually make.
            </remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind">
            <summary>
            An enumeration of the kinds of locks supported by this class.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind.Read">
            <summary>
            A lock that supports concurrently executing threads that hold this same lock type.
            Holders of this lock may not obtain a <see cref="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind.Write" /> lock without first
            releasing all their <see cref="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind.Read" /> locks.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind.UpgradeableRead">
            <summary>
            A lock that may run concurrently with standard readers, but is exclusive of any other
            upgradeable readers.  Holders of this lock are allowed to obtain a write lock while
            holding this lock to guarantee continuity of state between what they read and what they write.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind.Write">
            <summary>
            A mutually exclusive lock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsAnyLockHeld">
            <summary>
            Gets a value indicating whether any kind of lock is held by the caller and can
            be immediately used given the caller's context.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsAnyPassiveLockHeld">
            <summary>
            Gets a value indicating whether any kind of lock is held by the caller without regard
            to the lock compatibility of the caller's context.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsReadLockHeld">
            <summary>
            Gets a value indicating whether the caller holds a read lock.
            </summary>
            <remarks>
            This property returns <c>false</c> if any other lock type is held, unless
            within that alternate lock type this lock is also nested.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsPassiveReadLockHeld">
            <summary>
            Gets a value indicating whether a read lock is held by the caller without regard
            to the lock compatibility of the caller's context.
            </summary>
            <remarks>
            This property returns <c>false</c> if any other lock type is held, unless
            within that alternate lock type this lock is also nested.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsUpgradeableReadLockHeld">
            <summary>
            Gets a value indicating whether the caller holds an upgradeable read lock.
            </summary>
            <remarks>
            This property returns <c>false</c> if any other lock type is held, unless
            within that alternate lock type this lock is also nested.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsPassiveUpgradeableReadLockHeld">
            <summary>
            Gets a value indicating whether an upgradeable read lock is held by the caller without regard
            to the lock compatibility of the caller's context.
            </summary>
            <remarks>
            This property returns <c>false</c> if any other lock type is held, unless
            within that alternate lock type this lock is also nested.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsWriteLockHeld">
            <summary>
            Gets a value indicating whether the caller holds a write lock.
            </summary>
            <remarks>
            This property returns <c>false</c> if any other lock type is held, unless
            within that alternate lock type this lock is also nested.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsPassiveWriteLockHeld">
            <summary>
            Gets a value indicating whether a write lock is held by the caller without regard
            to the lock compatibility of the caller's context.
            </summary>
            <remarks>
            This property returns <c>false</c> if any other lock type is held, unless
            within that alternate lock type this lock is also nested.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Completion">
            <summary>
            Gets a task whose completion signals that this lock will no longer issue locks.
            </summary>
            <remarks>
            This task only transitions to a complete state after a call to <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Complete" />.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.SyncObject">
            <summary>
            Gets the object used to synchronize access to this instance's fields.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.AmbientLock">
            <summary>
            Gets the lock held by the caller's execution context.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.CaptureDiagnostics">
            <summary>
            Gets or sets a value indicating whether additional resources should be spent to collect
            information that would be useful in diagnosing deadlocks, etc.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.DeadlockCheckTimeout">
            <summary>
            Gets a time delay to check whether pending writer lock and reader locks forms a deadlock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.CanCurrentThreadHoldActiveLock">
            <summary>
            Gets a value indicating whether the current thread is allowed to
            hold an active lock.
            </summary>
            <remarks>
            The default implementation of this property returns <c>true</c>
            when the calling thread is NOT an STA thread.
            This property may be overridden to return <c>false</c>
            on threads that may compromise the integrity of the lock.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsUnsupportedSynchronizationContext">
            <summary>
            Gets a value indicating whether the current SynchronizationContext is one that is not supported
            by this lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.ReadLockAsync(System.Threading.CancellationToken)">
            <summary>
            Obtains a read lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException" />.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.UpgradeableReadLockAsync(System.Threading.CancellationToken)">
            <summary>
            Obtains an upgradeable read lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException" />.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.UpgradeableReadLockAsync(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags,System.Threading.CancellationToken)">
            <summary>
            Obtains a read lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="options">Modifications to normal lock behavior.</param>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException" />.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.WriteLockAsync(System.Threading.CancellationToken)">
            <summary>
            Obtains a write lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException" />.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.WriteLockAsync(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags,System.Threading.CancellationToken)">
            <summary>
            Obtains a write lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="options">Modifications to normal lock behavior.</param>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException" />.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.HideLocks">
            <summary>
            Prevents use or visibility of the caller's lock(s) until the returned value is disposed.
            </summary>
            <returns>The value to dispose to restore lock visibility.</returns>
            <remarks>
            This can be used by a write lock holder that is about to fork execution to avoid
            two threads simultaneously believing they hold the exclusive write lock.
            The lock should be hidden just before kicking off the work and can be restored immediately
            after kicking off the work.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Complete">
            <summary>
            Causes new top-level lock requests to be rejected and the <see cref="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Completion" /> task to transition
            to a completed state after any issued locks have been released.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.OnBeforeWriteLockReleased(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Registers a callback to be invoked when the write lock held by the caller is
            about to be ultimately released (outermost write lock).
            </summary>
            <param name="action">
            The asynchronous delegate to invoke.
            Access to the write lock is provided throughout the asynchronous invocation.
            </param>
            <remarks>
            This supports some scenarios VC++ has where change event handlers need to inspect changes,
            or follow up with other changes to respond to earlier changes, at the conclusion of the lock.
            This method is safe to call from within a previously registered callback, in which case the
            registered callback will run when previously registered callbacks have completed execution.
            If the write lock is released to an upgradeable read lock, these callbacks are fired synchronously
            with respect to the writer who is releasing the lock.  Otherwise, the callbacks are invoked
            asynchronously with respect to the releasing thread.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Dispose(System.Boolean)">
            <summary>
            Disposes managed and unmanaged resources held by this instance.
            </summary>
            <param name="disposing"><c>true</c> if <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Dispose" /> was called; <c>false</c> if the object is being finalized.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockStackContains(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle)">
            <summary>
            Checks whether the aggregated flags from all locks in the lock stack satisfy the specified flag(s).
            </summary>
            <param name="flags">The flag(s) that must be specified for a <c>true</c> result.</param>
            <param name="handle">The head of the lock stack to consider.</param>
            <returns><c>true</c> if all the specified flags are found somewhere in the lock stack; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.GetAggregateLockFlags">
            <summary>
            Returns the aggregate of the lock flags for all nested locks.
            </summary>
            <remarks>
            This is not redundant with <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockStackContains(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle)" /> because that returns fast
            once the presence of certain flag(s) is determined, whereas this will aggregate all flags,
            some of which may be defined by derived types.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.OnBeforeLockReleasedAsync(System.Boolean,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle)">
            <summary>
            Fired when any lock is being released.
            </summary>
            <param name="exclusiveLockRelease"><c>true</c> if the last write lock that the caller holds is being released; <c>false</c> otherwise.</param>
            <param name="releasingLock">The lock being released.</param>
            <returns>A task whose completion signals the conclusion of the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.OnBeforeExclusiveLockReleasedAsync">
            <summary>
            Fired when the last write lock is about to be released.
            </summary>
            <returns>A task whose completion signals the conclusion of the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.GetTaskSchedulerForReadLockRequest">
            <summary>
            Get the task scheduler to execute the continuation when the lock is acquired.
             AsyncReaderWriterLock uses a special <see cref="T:System.Threading.SynchronizationContext" /> to handle execusive locks, and will ignore task scheduler provided, so this is only used in a read lock scenario.
            This method is called within the execution context to wait the read lock, so it can pick up <see cref="T:System.Threading.Tasks.TaskScheduler" /> based on the current execution context.
            Note: the task scheduler is only used, when the lock is issued later.  If the lock is issued immediately when <see cref="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.CanCurrentThreadHoldActiveLock" /> returns true, it will be ignored.
            </summary>
            <returns>A task scheduler to schedule the continutation task when a lock is issued.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.OnExclusiveLockReleasedAsync">
            <summary>
            Invoked after an exclusive lock is released but before anyone has a chance to enter the lock.
            </summary>
            <remarks>
            This method is called while holding a private lock in order to block future lock consumers till this method is finished.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.OnUpgradeableReadLockReleased">
            <summary>
            Invoked when a top-level upgradeable read lock is released, leaving no remaining (write) lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.OnCriticalFailure(System.Exception)">
            <summary>
            Invoked when the lock detects an internal error or illegal usage pattern that
            indicates a serious flaw that should be immediately reported to the application
            and/or bring down the process to avoid hangs or data corruption.
            </summary>
            <param name="ex">The exception that captures the details of the failure.</param>
            <returns>An exception that may be returned by some implementations of tis method for he caller to rethrow.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.OnCriticalFailure(System.String)">
            <summary>
            Invoked when the lock detects an internal error or illegal usage pattern that
            indicates a serious flaw that should be immediately reported to the application
            and/or bring down the process to avoid hangs or data corruption.
            </summary>
            <param name="message">The message to use for the exception.</param>
            <returns>An exception that may be returned by some implementations of tis method for he caller to rethrow.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.HasAnyNestedLocks(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Collections.Generic.HashSet{Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter})">
            <summary>
            Checks whether the specified lock has any active nested locks.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.ThrowIfUnsupportedThreadOrSyncContext">
            <summary>
            Throws an exception if called on an STA thread.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsLockSupportingContext(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Gets a value indicating whether the caller's thread apartment model and SynchronizationContext
            is compatible with a lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.CompleteIfAppropriate">
            <summary>
            Transitions the <see cref="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Completion" /> task to a completed state
            if appropriate.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.AggregateLockStackKinds(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Boolean@,System.Boolean@,System.Boolean@)">
            <summary>
            Detects which lock types the given lock holder has (including all nested locks).
            </summary>
            <param name="awaiter">The most nested lock to be considered.</param>
            <param name="read">Receives a value indicating whether a read lock is held.</param>
            <param name="upgradeableRead">Receives a value indicating whether an upgradeable read lock is held.</param>
            <param name="write">Receives a value indicating whether a write lock is held.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.AllHeldLocksAreByThisStack(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Gets a value indicating whether all issued locks are merely the top-level lock or nesting locks of the specified lock.
            </summary>
            <param name="awaiter">The most nested lock.</param>
            <returns><c>true</c> if all issued locks are the specified lock or nesting locks of it.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockStackContains(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Gets a value indicating whether the specified lock is, or is a nested lock of, a given type.
            </summary>
            <param name="kind">The kind of lock being queried for.</param>
            <param name="awaiter">The (possibly nested) lock.</param>
            <returns><c>true</c> if the lock holder (also) holds the specified kind of lock.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsStickyWriteUpgradedLock(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Checks whether the specified lock is an upgradeable read lock, with a <see cref="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags.StickyWrite" /> flag,
            which has actually be upgraded.
            </summary>
            <param name="awaiter">The lock to test.</param>
            <returns><c>true</c> if the test succeeds; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsLockHeld(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Boolean,System.Boolean)">
            <summary>
            Checks whether the caller's held locks (or the specified lock stack) includes an active lock of the specified type.
            Always <c>false</c> when called on an STA thread.
            </summary>
            <param name="kind">The type of lock to check for.</param>
            <param name="awaiter">The most nested lock of the caller, or null to look up the caller's lock in the CallContext.</param>
            <param name="checkSyncContextCompatibility"><c>true</c> to throw an exception if the caller has an exclusive lock but not an associated SynchronizationContext.</param>
            <param name="allowNonLockSupportingContext"><c>true</c> to return true when a lock is held but unusable because of the context of the caller.</param>
            <returns><c>true</c> if the caller holds active locks of the given type; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsLockActive(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Boolean,System.Boolean)">
            <summary>
            Checks whether a given lock is active.
            Always <c>false</c> when called on an STA thread.
            </summary>
            <param name="awaiter">The lock to check.</param>
            <param name="considerStaActive">if <c>false</c> the return value will always be <c>false</c> if called on an STA thread.</param>
            <param name="checkSyncContextCompatibility"><c>true</c> to throw an exception if the caller has an exclusive lock but not an associated SynchronizationContext.</param>
            <returns><c>true</c> if the lock is currently issued and the caller is not on an STA thread.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.CheckSynchronizationContextAppropriateForLock(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Checks whether the specified awaiter's lock type has an associated SynchronizationContext if one is applicable.
            </summary>
            <param name="awaiter">The awaiter whose lock should be considered.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.TryIssueLock(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Boolean,System.Boolean)">
            <summary>
            Immediately issues a lock to the specified awaiter if it is available.
            </summary>
            <param name="awaiter">The awaiter to issue a lock to.</param>
            <param name="previouslyQueued">
            A value indicating whether this lock was previously queued.  <c>false</c> if this is a new just received request.
            The value is used to determine whether to reject it if <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Complete" /> has already been called and this
            is a new top-level request.
            </param>
            <param name="skipPendingWriteLockCheck">
            Normally, new reader locks are no longer issued when there is a pending writer lock to allow existing reader lock to complete.
            However, that can lead deadlocks, when tasks with issued lock depending on tasks requiring new read locks to complete.
            When it is true, new reader locks will be issued even when there is a pending writer lock.
            </param>
            <returns>A value indicating whether the lock was issued.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.FindRootUpgradeableReadWithStickyWrite(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Finds the upgradeable reader with <see cref="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags.StickyWrite" /> flag that is nearest
            to the top-level lock request held by the given lock holder.
            </summary>
            <param name="headAwaiter">The awaiter to start the search down the stack from.</param>
            <returns>The least nested upgradeable reader lock with sticky write flag; or <c>null</c> if none was found.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.GetActiveLockSet(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind)">
            <summary>
            Gets the set of locks of a given kind.
            </summary>
            <param name="kind">The kind of lock.</param>
            <returns>A set of locks.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.GetLockQueue(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind)">
            <summary>
            Gets the queue for a lock with a given type.
            </summary>
            <param name="kind">The kind of lock.</param>
            <returns>A queue.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.GetFirstActiveSelfOrAncestor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Walks the nested lock stack until it finds an active one.
            </summary>
            <param name="awaiter">The most nested lock to consider.  May be null.</param>
            <returns>The first active lock encountered, or <c>null</c> if none.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IssueAndExecute(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Issues a lock to the specified awaiter and executes its continuation.
            The awaiter should have already been dequeued.
            </summary>
            <param name="awaiter">The awaiter to issue a lock to and execute.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.ReleaseAsync(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Boolean)">
            <summary>
            Releases the lock held by the specified awaiter.
            </summary>
            <param name="awaiter">The awaiter holding an active lock.</param>
            <param name="lockConsumerCanceled">A value indicating whether the lock consumer ended up not executing any work.</param>
            <returns>
            A task that should complete before the releasing thread accesses any resource protected by
            a lock wrapping the lock being released.
            The task will always be complete if <paramref name="lockConsumerCanceled" /> is <c>true</c>.
            This method guarantees that the lock is effectively released from the caller, and the <paramref name="awaiter" />
            can be safely recycled, before the synchronous portion of this method completes.
            </returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.DowngradeLockAsync(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Boolean,System.Boolean,System.Threading.Tasks.Task)">
            <summary>
            Schedules work on a background thread that will prepare protected resource(s) for concurrent access.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.HasAnyNestedLocks(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Checks whether the specified lock has any active nested locks.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.OnReleaseReenterConcurrencyComplete(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Boolean,System.Boolean)">
            <summary>
            Called at the conclusion of releasing an exclusive lock to complete the transition.
            </summary>
            <param name="awaiter">The awaiter being released.</param>
            <param name="upgradedStickyWrite">A flag indicating whether the lock being released was an upgraded read lock with the sticky write flag set.</param>
            <param name="searchAllWaiters"><c>true</c> to scan the entire queue for pending lock requests that might qualify; used when qualifying locks were delayed for some reason besides lock contention.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.TryInvokeLockConsumer(System.Boolean)">
            <summary>
            Issues locks to one or more queued lock requests and executes their continuations
            based on lock availability and policy-based prioritization (writer-friendly, etc.)
            </summary>
            <param name="searchAllWaiters"><c>true</c> to scan the entire queue for pending lock requests that might qualify; used when qualifying locks were delayed for some reason besides lock contention.</param>
            <returns><c>true</c> if any locks were issued; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.InvokeBeforeWriteLockReleaseHandlersAsync">
            <summary>
            Invokes the final write lock release callbacks, if appropriate.
            </summary>
            <returns>A task representing the work of sequentially invoking the callbacks.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.TryDequeueBeforeWriteReleasedCallback(System.Func{System.Threading.Tasks.Task}@)">
            <summary>
            Dequeues a single write lock release callback if available.
            </summary>
            <param name="callback">Receives the callback to invoke, if any.</param>
            <returns>A value indicating whether a callback was available to invoke.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.ApplyLockToCallContext(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Stores the specified lock in the CallContext dictionary.
            </summary>
            <param name="topAwaiter">The awaiter that tracks the lock to grant to the caller.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.TryInvokeAllReadersIfAppropriate(System.Boolean)">
            <summary>
            Issues locks to all queued reader lock requests if there are no issued write locks.
            </summary>
            <param name="searchAllWaiters"><c>true</c> to scan the entire queue for pending lock requests that might qualify; used when qualifying locks were delayed for some reason besides lock contention.</param>
            <returns>A value indicating whether any readers were issued locks.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.TryInvokeOneUpgradeableReaderIfAppropriate(System.Boolean)">
            <summary>
            Issues a lock to the next queued upgradeable reader, if no upgradeable read or write locks are currently issued.
            </summary>
            <param name="searchAllWaiters"><c>true</c> to scan the entire queue for pending lock requests that might qualify; used when qualifying locks were delayed for some reason besides lock contention.</param>
            <returns>A value indicating whether any upgradeable readers were issued locks.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.TryInvokeOneWriterIfAppropriate(System.Boolean)">
            <summary>
            Issues a lock to the next queued writer, if no other locks are currently issued
            or the last contending read lock was removed allowing a waiting upgradeable reader to upgrade.
            </summary>
            <param name="searchAllWaiters"><c>true</c> to scan the entire queue for pending lock requests that might qualify; used when qualifying locks were delayed for some reason besides lock contention.</param>
            <returns>A value indicating whether a writer was issued a lock.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.TryInvokeAnyWaitersInQueue(System.Collections.Generic.Queue{Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter},System.Boolean)">
            <summary>
            Scans a lock awaiter queue for any that can be issued locks now.
            </summary>
            <param name="waiters">The queue to scan.</param>
            <param name="breakOnFirstIssue"><c>true</c> to break out immediately after issuing the first lock.</param>
            <returns><c>true</c> if any lock was issued; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.PendAwaiter(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Issues a lock to a lock waiter and execute its code if the lock is immediately available, otherwise
            queues the lock request.
            </summary>
            <param name="awaiter">The lock request.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.ExecuteOrHandleCancellation(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Boolean)">
            <summary>
            Executes the lock receiver or releases the lock because the request for it was canceled before it was issued.
            </summary>
            <param name="awaiter">The awaiter.</param>
            <param name="stillInQueue">A value indicating whether the specified <paramref name="awaiter" /> is expected to still be in the queue (and should be removed).</param>
            <returns>A value indicating whether a continuation delegate was actually invoked.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaitable">
            <summary>
            An awaitable that is returned from asynchronous lock requests.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaitable.awaiter">
            <summary>
            The awaiter to return from the <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaitable.GetAwaiter" /> method.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaitable.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaitable" /> struct.
            </summary>
            <param name="lck">The lock class that created this instance.</param>
            <param name="kind">The type of lock being requested.</param>
            <param name="options">Any flags applied to the lock request.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="checkSyncContextCompatibility"><c>true</c> to throw an exception if the caller has an exclusive lock but not an associated SynchronizationContext.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaitable.GetAwaiter">
            <summary>
            Gets the awaiter value.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Releaser">
            <summary>
            A value whose disposal releases a held lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Releaser.awaiter">
            <summary>
            The awaiter who manages the lifetime of a lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Releaser.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Releaser" /> struct.
            </summary>
            <param name="awaiter">The awaiter.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Releaser.Dispose">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Releaser.DisposeAsync">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Releaser.ReleaseAsync">
            <summary>
            Asynchronously releases the lock.  Dispose should still be called after this.
            </summary>
            <returns>
            A task that should complete before the releasing thread accesses any resource protected by
            a lock wrapping the lock being released.
            </returns>
            <remarks>
            Rather than calling this method explicitly, use the C# 8 "await using" syntax instead.
            </remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Suppression">
            <summary>
            A value whose disposal restores visibility of any locks held by the caller.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Suppression.lck">
            <summary>
            The locking class.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Suppression.awaiter">
            <summary>
            The awaiter most recently acquired by the caller before hiding locks.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Suppression.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Suppression" /> struct.
            </summary>
            <param name="lck">The lock class.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Suppression.Dispose">
            <summary>
            Restores visibility of hidden locks.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle">
            <summary>
            A "public" representation of a specific lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.awaiter">
            <summary>
            The awaiter this lock handle wraps.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle" /> struct.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.IsValid">
            <summary>
            Gets a value indicating whether this handle is to a lock which was actually acquired.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.IsActive">
            <summary>
            Gets a value indicating whether this lock is still active.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.IsReadLock">
            <summary>
            Gets a value indicating whether this lock represents a read lock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.IsUpgradeableReadLock">
            <summary>
            Gets a value indicating whether this lock represents an upgradeable read lock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.IsWriteLock">
            <summary>
            Gets a value indicating whether this lock represents a write lock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.HasReadLock">
            <summary>
            Gets a value indicating whether this lock is an active read lock or is nested by one.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.HasUpgradeableReadLock">
            <summary>
            Gets a value indicating whether this lock is an active upgradeable read lock or is nested by one.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.HasWriteLock">
            <summary>
            Gets a value indicating whether this lock is an active write lock or is nested by one.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.Flags">
            <summary>
            Gets the flags that were passed into this lock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.Data">
            <summary>
            Gets or sets some object associated to this specific lock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.NestingLock">
            <summary>
            Gets the lock within which this lock was acquired.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.Awaiter">
            <summary>
            Gets the wrapped awaiter.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter">
            <summary>
            Manages asynchronous access to a lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.CancellationResponseAction">
            <summary>
            A singleton delegate for use in cancellation token registration to avoid memory allocations for delegates each time.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.lck">
            <summary>
            The instance of the lock class to which this awaiter is affiliated.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.kind">
            <summary>
            The type of lock requested.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.nestingLock">
            <summary>
            The "parent" lock (i.e. the lock within which this lock is nested) if any.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.cancellationToken">
            <summary>
            The cancellation token that would terminate waiting for a lock that is not yet available.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.cancellationRegistration">
            <summary>
            The cancellation token event that should be disposed of to free memory when we no longer need to receive cancellation notifications.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.options">
            <summary>
            The flags applied to this lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.fault">
            <summary>
            Any exception to throw back to the lock requestor.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.continuation">
            <summary>
            The continuation to execute when the lock is available.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.continuationAfterLockIssued">
            <summary>
            The continuation we invoked to an issued lock.
            </summary>
            <remarks>
            We retain this value simply so that in hang reports we can identify the method we issued the lock to.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.continuationTaskScheduler">
            <summary>
            The TaskScheduler to invoke the continuation.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.releaseAsyncTask">
            <summary>
            The task from a prior call to <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.ReleaseAsync(System.Boolean)" />, if any.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.synchronizationContext">
            <summary>
            The synchronization context applied to folks who hold the lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.requestingStackTrace">
            <summary>
            The stacktrace of the caller originally requesting the lock.
            </summary>
            <remarks>
            This field is initialized only when <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock" /> is constructed with
            the captureDiagnostics parameter set to <c>true</c>.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.data">
            <summary>
            An arbitrary object that may be set by a derived type of the containing lock class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags,System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter" /> class.
            </summary>
            <param name="lck">The lock class creating this instance.</param>
            <param name="kind">The type of lock being requested.</param>
            <param name="options">The flags to apply to the lock.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.IsCompleted">
            <summary>
            Gets a value indicating whether the lock has been issued.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.OwningLock">
            <summary>
            Gets the lock instance that owns this awaiter.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.RequestingStackTrace">
            <summary>
            Gets the stack trace of the requestor of this lock.
            </summary>
            <remarks>
            Used for diagnostic purposes only.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.LockRequestingContinuation">
            <summary>
            Gets the delegate to invoke (or that was invoked) when the lock is/was issued, if available.
            FOR DIAGNOSTIC PURPOSES ONLY.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.NestingLock">
            <summary>
            Gets the lock that the caller held before requesting this lock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.Data">
            <summary>
            Gets or sets an arbitrary object that may be set by a derived type of the containing lock class.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.CancellationToken">
            <summary>
            Gets the cancellation token.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.Kind">
            <summary>
            Gets the kind of lock being requested.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.Options">
            <summary>
            Gets the flags applied to this lock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.IsReleased">
            <summary>
            Gets a value indicating whether the lock has already been released.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.AmbientJoinableTask">
            <summary>
            Gets the ambient JoinableTask when the lock is requested. This is used to resolve deadlock caused by issued read lock depending on new read lock requests blocked by pending write locks.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.LockIssued">
            <summary>
            Gets a value indicating whether the lock is active.
            </summary>
            <value><c>true</c> iff the lock has bee issued, has not yet been released, and the caller is on an MTA thread.</value>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.OnCompleted(System.Action)">
            <summary>
            Sets the delegate to execute when the lock is available.
            </summary>
            <param name="continuation">The delegate.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.UnsafeOnCompleted(System.Action)">
            <summary>
            Sets the delegate to execute when the lock is available
            without flowing ExecutionContext.
            </summary>
            <param name="continuation">The delegate.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.GetResult">
            <summary>
            Applies the issued lock to the caller and returns the value used to release the lock.
            </summary>
            <returns>The value to dispose of to release the lock.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.ReleaseAsync(System.Boolean)">
            <summary>
            Releases the lock and recycles this instance.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.TryScheduleContinuationExecution">
            <summary>
            Executes the code that requires the lock.
            </summary>
            <returns><c>true</c> if the continuation was (asynchronously) invoked; <c>false</c> if there was no continuation available to invoke.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.SetFault(System.Exception)">
            <summary>
            Specifies the exception to throw from <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.GetResult" />.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.CancellationResponder(System.Object)">
            <summary>
            Responds to lock request cancellation.
            </summary>
            <param name="state">The <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter" /> instance being canceled.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.GetEffectiveSynchronizationContext">
            <summary>
            Get the correct SynchronizationContext to execute code executing within the lock.
            Note: we need get the NonConcurrentSynchronizationContext from the nesting exclusive lock, because the child lock is essentially under the same context.
            When we don't have a valid nesting lock, we will create a new NonConcurrentSynchronizationContext for an exclusive lock.  For read lock, we don't put it within a NonConcurrentSynchronizationContext,
            we set it to DefaultSynchronizationContext to mark we have computed it.  The result is cached.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.OnCompleted(System.Action,System.Boolean)">
            <summary>
            Sets the delegate to execute when the lock is available.
            </summary>
            <param name="continuation">The delegate.</param>
            <param name="flowExecutionContext">A value indicating whether to flow ExecutionContext.</param>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.NonConcurrentSynchronizationContext.semaphoreHoldingManagedThreadId">
            <summary>
            The managed thread ID of the thread that has entered the semaphore.
            </summary>
            <remarks>
            No reason to lock around access to this field because it is only ever set to
            or compared against the current thread, so the activity of other threads is irrelevant.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.NonConcurrentSynchronizationContext.IsCurrentThreadHoldingSemaphore">
            <summary>
            Gets a value indicating whether the current thread holds the semaphore.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.NonConcurrentSynchronizationContext.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.NonConcurrentSynchronizationContext.PostHelper(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Executes the specified delegate.
            </summary>
            <remarks>
            We use async void instead of async Task because the caller will never
            use the result, and this way the compiler doesn't have to create the Task object.
            </remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2">
            <summary>
            A non-blocking lock that allows concurrent access, exclusive access, or concurrent with upgradeability to exclusive access,
            making special allowances for resources that must be prepared for concurrent or exclusive access.
            </summary>
            <typeparam name="TMoniker">The type of the moniker that identifies a resource.</typeparam>
            <typeparam name="TResource">The type of resource issued for access by this lock.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.helper">
            <summary>
            A private nested class we use to isolate some of the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2" /> class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2" /> class.
            </summary>
            <param name="captureDiagnostics">
            <c>true</c> to spend additional resources capturing diagnostic details that can be used
            to analyze deadlocks or other issues.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskContext,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2" /> class.
            </summary>
            <param name="joinableTaskContext">
            A JoinableTaskContext to help resolve dead locks caused by interdependency between top read lock tasks when there is a pending write lock blocking one of them.
            </param>
            <param name="captureDiagnostics">
            <c>true</c> to spend additional resources capturing diagnostic details that can be used
            to analyze deadlocks or other issues.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.LockFlags">
            <summary>
            Flags that modify default lock behavior.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.LockFlags.None">
            <summary>
            The default behavior applies.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.LockFlags.StickyWrite">
            <summary>
            Causes an upgradeable reader to remain in an upgraded-write state once upgraded,
            even after the nested write lock has been released.
            </summary>
            <remarks>
            This is useful when you have a batch of possible write operations to apply, which
            may or may not actually apply in the end, but if any of them change anything,
            all of their changes should be seen atomically (within a single write lock).
            This approach is preferable to simply acquiring a write lock around the batch of
            potential changes because it doesn't defeat concurrent readers until it knows there
            is a change to actually make.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.LockFlags.SkipInitialPreparation">
            <summary>
            Skips a step to make sure that the resource is initially prepared when retrieved using GetResourceAsync.
            </summary>
            <remarks>
            This flag is dormant for non-write locks.  But if present on an upgradeable read lock,
            this flag will activate for a nested write lock.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ReadLockAsync(System.Threading.CancellationToken)">
            <summary>
            Obtains a read lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException" />.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.UpgradeableReadLockAsync(Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.LockFlags,System.Threading.CancellationToken)">
            <summary>
            Obtains a read lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="options">Modifications to normal lock behavior.</param>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException" />.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.UpgradeableReadLockAsync(System.Threading.CancellationToken)">
            <summary>
            Obtains an upgradeable read lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException" />.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.WriteLockAsync(System.Threading.CancellationToken)">
            <summary>
            Obtains a write lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException" />.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.WriteLockAsync(Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.LockFlags,System.Threading.CancellationToken)">
            <summary>
            Obtains a write lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="options">Modifications to normal lock behavior.</param>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException" />.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.GetResourceAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Retrieves the resource with the specified moniker.
            </summary>
            <param name="resourceMoniker">The identifier for the desired resource.</param>
            <param name="cancellationToken">A token whose cancellation indicates lost interest in obtaining the resource.</param>
            <returns>A task whose result is the desired resource.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.SetResourceAsAccessed(`1)">
            <summary>
            Marks a resource as having been retrieved under a lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.SetResourceAsAccessed(System.Func{`1,System.Object,System.Boolean},System.Object)">
            <summary>
            Marks any loaded resources as having been retrieved under a lock if they
            satisfy some predicate.
            </summary>
            <param name="resourceCheck">A function that returns <c>true</c> if the provided resource should be considered retrieved.</param>
            <param name="state">The state object to pass as a second parameter to <paramref name="resourceCheck" />.</param>
            <returns><c>true</c> if the delegate returned <c>true</c> on any of the invocations.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.SetAllResourcesToUnknownState">
            <summary>
            Sets all the resources to be considered in an unknown state.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.GetAggregateLockFlags">
            <summary>
            Returns the aggregate of the lock flags for all nested locks.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.PrepareResourceForConcurrentAccessAsync(`1,System.Threading.CancellationToken)">
            <summary>
            Prepares a resource for concurrent access.
            </summary>
            <param name="resource">The resource to prepare.</param>
            <param name="cancellationToken">The token whose cancellation signals lost interest in the resource.</param>
            <returns>A task whose completion signals the resource has been prepared.</returns>
            <remarks>
            This is invoked on a resource when it is initially requested for concurrent access,
            for both transitions from no access and exclusive access.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.PrepareResourceForExclusiveAccessAsync(`1,Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.LockFlags,System.Threading.CancellationToken)">
            <summary>
            Prepares a resource for access by one thread.
            </summary>
            <param name="resource">The resource to prepare.</param>
            <param name="lockFlags">The aggregate of all flags from the active and nesting locks.</param>
            <param name="cancellationToken">The token whose cancellation signals lost interest in the resource.</param>
            <returns>A task whose completion signals the resource has been prepared.</returns>
            <remarks>
            This is invoked on a resource when it is initially access for exclusive access,
            but only when transitioning from no access -- it is not invoked when transitioning
            from concurrent access to exclusive access.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.OnExclusiveLockReleasedAsync">
            <summary>
            Invoked after an exclusive lock is released but before anyone has a chance to enter the lock.
            </summary>
            <remarks>
            This method is called while holding a private lock in order to block future lock consumers till this method is finished.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.OnUpgradeableReadLockReleased">
            <summary>
            Invoked when a top-level upgradeable read lock is released, leaving no remaining (write) lock.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaitable">
            <summary>
            An awaitable that is returned from asynchronous lock requests.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaitable.awaitable">
            <summary>
            The underlying lock awaitable.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaitable.helper">
            <summary>
            The helper class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaitable.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaitable,Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.Helper)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaitable" /> struct.
            </summary>
            <param name="awaitable">The underlying lock awaitable.</param>
            <param name="helper">The helper class.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaitable.GetAwaiter">
            <summary>
            Gets the awaiter value.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaiter">
            <summary>
            Manages asynchronous access to a lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaiter.awaiter">
            <summary>
            The underlying lock awaiter.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaiter.helper">
            <summary>
            The helper class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaiter.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.Helper)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaiter" /> struct.
            </summary>
            <param name="awaiter">The underlying lock awaiter.</param>
            <param name="helper">The helper class.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaiter.IsCompleted">
            <summary>
            Gets a value indicating whether the lock has been issued.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaiter.OnCompleted(System.Action)">
            <summary>
            Sets the delegate to execute when the lock is available.
            </summary>
            <param name="continuation">The delegate.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>
            Sets the delegate to execute when the lock is available.
            </summary>
            <param name="continuation">The delegate.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaiter.GetResult">
            <summary>
            Applies the issued lock to the caller and returns the value used to release the lock.
            </summary>
            <returns>The value to dispose of to release the lock.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser">
            <summary>
            A value whose disposal releases a held lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser.releaser">
            <summary>
            The underlying lock releaser.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser.helper">
            <summary>
            The helper class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Releaser,Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.Helper)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser" /> struct.
            </summary>
            <param name="releaser">The underlying lock releaser.</param>
            <param name="helper">The helper class.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser.LockReleaser">
            <summary>
            Gets the underlying lock releaser.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser.GetResourceAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Gets the lock protected resource.
            </summary>
            <param name="resourceMoniker">The identifier for the protected resource.</param>
            <param name="cancellationToken">A token whose cancellation signals lost interest in the protected resource.</param>
            <returns>A task whose result is the resource.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser.Dispose">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser.DisposeAsync">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser.ReleaseAsync">
            <summary>
            Asynchronously releases the lock.  Dispose should still be called after this.
            </summary>
            <remarks>
            Rather than calling this method explicitly, use the C# 8 "await using" syntax instead.
            </remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper">
            <summary>
            A helper class to isolate some specific functionality in this outer class.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.service">
            <summary>
            The owning lock instance.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.prepareResourceConcurrentDelegate">
            <summary>
            A reusable delegate that invokes the <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.PrepareResourceForConcurrentAccessAsync(`1,System.Threading.CancellationToken)" /> method.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.prepareResourceExclusiveDelegate">
            <summary>
            A reusable delegate that invokes the <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.PrepareResourceForExclusiveAccessAsync(`1,Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.LockFlags,System.Threading.CancellationToken)" /> method.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.prepareResourceConcurrentContinuationDelegate">
            <summary>
            A reusable delegate that invokes the <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.PrepareResourceForConcurrentAccessAsync(`1,System.Threading.CancellationToken)" /> method.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.prepareResourceExclusiveContinuationDelegate">
            <summary>
            A reusable delegate that invokes the <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.PrepareResourceForExclusiveAccessAsync(`1,Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.LockFlags,System.Threading.CancellationToken)" /> method.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.resourcesAcquiredWithinUpgradeableRead">
            <summary>
            A collection of all the resources requested within the outermost upgradeable read lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.resourcePreparationTasks">
            <summary>
            A map of resources to the tasks that most recently began evaluating them.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper" /> class.
            </summary>
            <param name="service">The owning lock instance.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourceState">
            <summary>
            Describes the states a resource can be in.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourceState.Unknown">
            <summary>
            The resource is neither prepared for concurrent nor exclusive access.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourceState.Concurrent">
            <summary>
            The resource is prepared for concurrent access.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourceState.Exclusive">
            <summary>
            The resource is prepared for exclusive access.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.SetResourceAsAccessed(`1)">
            <summary>
            Marks a resource as having been retrieved under a lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.SetResourceAsAccessed(System.Func{`1,System.Object,System.Boolean},System.Object)">
            <summary>
            Marks any loaded resources as having been retrieved under a lock if they
            satisfy some predicate.
            </summary>
            <param name="resourceCheck">A function that returns <c>true</c> if the provided resource should be considered retrieved.</param>
            <param name="state">The state object to pass as a second parameter to <paramref name="resourceCheck" />.</param>
            <returns><c>true</c> if the delegate returned <c>true</c> on any of the invocations.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.OnExclusiveLockReleasedAsync">
            <summary>
            Ensures that all resources are marked as unprepared so at next request they are prepared again.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.OnUpgradeableReadLockReleased">
            <summary>
            Invoked when a top-level upgradeable read lock is released, leaving no remaining (write) lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.GetResourceAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Retrieves the resource with the specified moniker.
            </summary>
            <param name="resourceMoniker">The identifier for the desired resource.</param>
            <param name="cancellationToken">The token whose cancellation signals lost interest in this resource.</param>
            <returns>A task whose result is the desired resource.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.SetAllResourcesToUnknownState">
            <summary>
            Sets all the resources to be considered in an unknown state. Any subsequent access (exclusive or concurrent) will prepare the resource.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.SetUnknownResourceState(`1)">
            <summary>
            Sets the specified resource to be considered in an unknown state. Any subsequent access (exclusive or concurrent) will prepare the resource.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.SetUnknownResourceState(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Sets the specified resources to be considered in an unknown state. Any subsequent access (exclusive or concurrent) will prepare the resource.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.PrepareResourceAsync(`1,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Prepares the specified resource for access by a lock holder.
            </summary>
            <param name="resource">The resource to prepare.</param>
            <param name="cancellationToken">The token whose cancellation signals lost interest in this resource.</param>
            <param name="forcePrepareConcurrent">Force preparation of the resource for concurrent access, even if an exclusive lock is currently held.</param>
            <returns>A task that is completed when preparation has completed.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.AcquirePreexistingLockOrThrow">
            <summary>
            Reserves a read lock from a previously held lock.
            </summary>
            <returns>The releaser for the read lock.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if no lock is held by the caller.</exception>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourcePreparationTaskAndValidity">
            <summary>
            Tracks a task that prepares a resource for either concurrent or exclusive use.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourcePreparationTaskAndValidity.#ctor(System.Threading.Tasks.Task,Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.Helper.ResourceState)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourcePreparationTaskAndValidity" /> struct.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourcePreparationTaskAndValidity.PreparationTask">
            <summary>
            Gets the task that is preparing the resource.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourcePreparationTaskAndValidity.State">
            <summary>
            Gets the state the resource will be in when <see cref="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourcePreparationTaskAndValidity.PreparationTask" /> has completed.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncSemaphore">
            <summary>
            An asynchronous <see cref="T:System.Threading.SemaphoreSlim" /> like class with more convenient release syntax.
            </summary>
            <remarks>
            <para>This semaphore guarantees FIFO ordering.</para>
            <para>
            This object does *not* need to be disposed of, as it does not hold unmanaged resources.
            Disposing this object has no effect on current users of the semaphore, and they are allowed to release their hold on the semaphore without exception.
            An <see cref="T:System.ObjectDisposedException" /> is thrown back at anyone asking to or waiting to enter the semaphore after <see cref="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.Dispose" /> is called.
            </para>
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncSemaphore.DisposedReleaserTask">
            <summary>
            A task that is faulted with an <see cref="T:System.ObjectDisposedException" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncSemaphore.CanceledReleaser">
            <summary>
            A task that is canceled without a specific token.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncSemaphore.uncontestedReleaser">
            <summary>
            A task to return for any uncontested request for the lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncSemaphore.syncObject">
            <summary>
            The sync object to lock on for mutable field access.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncSemaphore.waiters">
            <summary>
            A queue of operations waiting to enter the semaphore.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncSemaphore.nodePool">
            <summary>
            A pool of recycled nodes.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncSemaphore.disposed">
            <summary>
            A value indicating whether this instance has been disposed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncSemaphore" /> class.
            </summary>
            <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncSemaphore.CurrentCount">
            <summary>
            Gets the number of openings that remain in the semaphore.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.EnterAsync(System.Threading.CancellationToken)">
            <summary>
            Requests access to the lock.
            </summary>
            <param name="cancellationToken">A token whose cancellation signals lost interest in the lock.</param>
            <returns>
            A task whose result is a releaser that should be disposed to release the lock.
            This task may be canceled if <paramref name="cancellationToken" /> is signaled.
            </returns>
            <exception cref="T:System.OperationCanceledException">Thrown when <paramref name="cancellationToken" /> is canceled before semaphore access is granted.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown when this semaphore is disposed before semaphore access is granted.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.EnterAsync(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Requests access to the lock.
            </summary>
            <param name="timeout">A timeout for waiting for the lock.</param>
            <param name="cancellationToken">A token whose cancellation signals lost interest in the lock.</param>
            <returns>
            A task whose result is a releaser that should be disposed to release the lock.
            This task may be canceled if <paramref name="cancellationToken" /> is signaled or <paramref name="timeout" /> expires.
            </returns>
            <exception cref="T:System.OperationCanceledException">Thrown when <paramref name="cancellationToken" /> is canceled or the <paramref name="timeout" /> expires before semaphore access is granted.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown when this semaphore is disposed before semaphore access is granted.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.EnterAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Requests access to the lock.
            </summary>
            <param name="timeout">A timeout for waiting for the lock (in milliseconds).</param>
            <param name="cancellationToken">A token whose cancellation signals lost interest in the lock.</param>
            <returns>A task whose result is a releaser that should be disposed to release the lock.</returns>
            <exception cref="T:System.OperationCanceledException">Thrown when <paramref name="cancellationToken" /> is canceled or the <paramref name="timeout" /> expires before semaphore access is granted.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown when this semaphore is disposed before semaphore access is granted.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.Dispose">
            <summary>
            Faults all pending semaphore waiters with <see cref="T:System.ObjectDisposedException" />
            and rejects all subsequent attempts to enter the semaphore with the same exception.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.Dispose(System.Boolean)">
            <summary>
            Disposes managed and unmanaged resources held by this instance.
            </summary>
            <param name="disposing"><c>true</c> if <see cref="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.Dispose" /> was called; <c>false</c> if the object is being finalized.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncSemaphore.Releaser">
            <summary>
            A value whose disposal triggers the release of a lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncSemaphore.Releaser.toRelease">
            <summary>
            The lock instance to release.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.Releaser.#ctor(Microsoft.VisualStudio.Threading.AsyncSemaphore)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncSemaphore.Releaser" /> struct.
            </summary>
            <param name="toRelease">The lock instance to release on.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.Releaser.Dispose">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AwaitExtensions">
            <summary>
            Extension methods and awaitables for .NET 4.5.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.GetAwaiter(System.Threading.Tasks.TaskScheduler)">
            <summary>
            Gets an awaiter that schedules continuations on the specified scheduler.
            </summary>
            <param name="scheduler">The task scheduler used to execute continuations.</param>
            <returns>An awaitable.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.SwitchTo(System.Threading.Tasks.TaskScheduler,System.Boolean)">
            <summary>
            Gets an awaitable that schedules continuations on the specified scheduler.
            </summary>
            <param name="scheduler">The task scheduler used to execute continuations.</param>
            <param name="alwaysYield">A value indicating whether the caller should yield even if
            already executing on the desired task scheduler.</param>
            <returns>An awaitable.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.GetAwaiter(System.Threading.WaitHandle)">
            <summary>
            Provides await functionality for ordinary <see cref="T:System.Threading.WaitHandle" />s.
            </summary>
            <param name="handle">The handle to wait on.</param>
            <returns>The awaiter.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.WaitForExitAsync(System.Diagnostics.Process,System.Threading.CancellationToken)">
            <summary>
            Returns a task that completes when the process exits and provides the exit code of that process.
            </summary>
            <param name="process">The process to wait for exit.</param>
            <param name="cancellationToken">
            A token whose cancellation will cause the returned Task to complete
            before the process exits in a faulted state with an <see cref="T:System.OperationCanceledException" />.
            This token has no effect on the <paramref name="process" /> itself.
            </param>
            <returns>A task whose result is the <see cref="P:System.Diagnostics.Process.ExitCode" /> of the <paramref name="process" />.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.WaitForChangeAsync(Microsoft.Win32.RegistryKey,System.Boolean,Microsoft.VisualStudio.Threading.RegistryChangeNotificationFilters,System.Threading.CancellationToken)">
            <summary>
            Returns a Task that completes when the specified registry key changes.
            </summary>
            <param name="registryKey">The registry key to watch for changes.</param>
            <param name="watchSubtree"><c>true</c> to watch the keys descendent keys as well; <c>false</c> to watch only this key without descendents.</param>
            <param name="change">Indicates the kinds of changes to watch for.</param>
            <param name="cancellationToken">A token that may be canceled to release the resources from watching for changes and complete the returned Task as canceled.</param>
            <returns>
            A task that completes when the registry key changes, the handle is closed, or upon cancellation.
            </returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfigureAwait(System.Runtime.CompilerServices.YieldAwaitable,System.Boolean)">
            <summary>
            Converts a <see cref="T:System.Runtime.CompilerServices.YieldAwaitable" /> to a <see cref="T:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfiguredTaskYieldAwaitable" />.
            </summary>
            <param name="yieldAwaitable">The result of <see cref="M:System.Threading.Tasks.Task.Yield" />.</param>
            <param name="continueOnCapturedContext">A value indicating whether the continuation should run on the captured <see cref="T:System.Threading.SynchronizationContext" />, if any.</param>
            <returns>An awaitable.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfigureAwaitRunInline(System.Threading.Tasks.Task)">
            <summary>
            Gets an awaitable that schedules the continuation with a preference to executing synchronously on the callstack that completed the <see cref="T:System.Threading.Tasks.Task" />,
            without regard to thread ID or any <see cref="T:System.Threading.SynchronizationContext" /> that may be applied when the continuation is scheduled or when the antecedent completes.
            </summary>
            <param name="antecedent">The task to await on.</param>
            <returns>An awaitable.</returns>
            <remarks>
            If there is not enough stack space remaining on the thread that is completing the <paramref name="antecedent" /> <see cref="T:System.Threading.Tasks.Task" />,
            the continuation may be scheduled on the threadpool.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfigureAwaitRunInline``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Gets an awaitable that schedules the continuation with a preference to executing synchronously on the callstack that completed the <see cref="T:System.Threading.Tasks.Task" />,
            without regard to thread ID or any <see cref="T:System.Threading.SynchronizationContext" /> that may be applied when the continuation is scheduled or when the antecedent completes.
            </summary>
            <typeparam name="T">The type of value returned by the awaited <see cref="T:System.Threading.Tasks.Task" />.</typeparam>
            <param name="antecedent">The task to await on.</param>
            <returns>An awaitable.</returns>
            <remarks>
            If there is not enough stack space remaining on the thread that is completing the <paramref name="antecedent" /> <see cref="T:System.Threading.Tasks.Task" />,
            the continuation may be scheduled on the threadpool.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfigureAwaitForAggregateException(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Returns an awaitable that will throw <see cref="T:System.AggregateException" /> from the <see cref="P:System.Threading.Tasks.Task.Exception" /> property of the task if it faults.
            </summary>
            <param name="task">The task to track for completion.</param>
            <param name="continueOnCapturedContext"><inheritdoc cref="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" path="/param[@name='continueOnCapturedContext']" /></param>
            <returns>An awaitable that may throw <see cref="T:System.AggregateException" />.</returns>
            <remarks>
            Awaiting a <see cref="T:System.Threading.Tasks.Task" /> with its default <see cref="T:System.Runtime.CompilerServices.TaskAwaiter" /> only throws the first exception within <see cref="P:System.AggregateException.InnerExceptions" />.
            When you do not want to lose the detail of other inner exceptions, use this extension method.
            </remarks>
            <exception cref="T:System.AggregateException">Thrown when <paramref name="task" /> faults.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.WaitForRegistryChangeAsync(Microsoft.Win32.SafeHandles.SafeRegistryHandle,System.Boolean,Microsoft.VisualStudio.Threading.RegistryChangeNotificationFilters,System.Threading.CancellationToken)">
            <summary>
            Returns a Task that completes when the specified registry key changes.
            </summary>
            <param name="registryKeyHandle">The handle to the open registry key to watch for changes.</param>
            <param name="watchSubtree"><c>true</c> to watch the keys descendent keys as well; <c>false</c> to watch only this key without descendents.</param>
            <param name="change">Indicates the kinds of changes to watch for.</param>
            <param name="cancellationToken">A token that may be canceled to release the resources from watching for changes and complete the returned Task as canceled.</param>
            <returns>
            A task that completes when the registry key changes, the handle is closed, or upon cancellation.
            </returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AwaitExtensions.AggregateExceptionAwaitable">
            <summary>
            The result of <see cref="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfigureAwaitForAggregateException(System.Threading.Tasks.Task,System.Boolean)" /> to prepare a <see cref="T:System.Threading.Tasks.Task" /> to be awaited while throwing with all inner exceptions.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.AggregateExceptionAwaitable.#ctor(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AwaitExtensions.AggregateExceptionAwaitable" /> struct.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.AggregateExceptionAwaitable.GetAwaiter">
            <summary>
            Gets an awaitable that schedules continuations on the specified scheduler.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AwaitExtensions.AggregateExceptionAwaiter">
            <summary>
            The result of <see cref="M:Microsoft.VisualStudio.Threading.AwaitExtensions.AggregateExceptionAwaitable.GetAwaiter" /> to prepare a <see cref="T:System.Threading.Tasks.Task" /> to be awaited while throwing with all inner exceptions.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.AggregateExceptionAwaiter.#ctor(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AwaitExtensions.AggregateExceptionAwaiter" /> struct.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AwaitExtensions.AggregateExceptionAwaiter.IsCompleted">
            <inheritdoc cref="P:System.Runtime.CompilerServices.TaskAwaiter.IsCompleted" />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.AggregateExceptionAwaiter.OnCompleted(System.Action)">
            <inheritdoc cref="M:System.Runtime.CompilerServices.TaskAwaiter.OnCompleted(System.Action)" />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.AggregateExceptionAwaiter.UnsafeOnCompleted(System.Action)">
            <inheritdoc cref="M:System.Runtime.CompilerServices.TaskAwaiter.UnsafeOnCompleted(System.Action)" />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.AggregateExceptionAwaiter.GetResult">
            <inheritdoc cref="M:System.Runtime.CompilerServices.TaskAwaiter.GetResult" path="/summary" />
            <exception cref="T:System.OperationCanceledException">Thrown if the task was canceled.</exception>
            <exception cref="T:System.AggregateException">Thrown if the task faulted.</exception>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaitable">
            <summary>
            An awaitable that executes continuations on the specified task scheduler.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaitable.taskScheduler">
            <summary>
            The scheduler for continuations.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaitable.alwaysYield">
            <summary>
            A value indicating whether the awaitable will always call the caller to yield.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaitable.#ctor(System.Threading.Tasks.TaskScheduler,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaitable" /> struct.
            </summary>
            <param name="taskScheduler">The task scheduler used to execute continuations.</param>
            <param name="alwaysYield">A value indicating whether the caller should yield even if
            already executing on the desired task scheduler.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaitable.GetAwaiter">
            <summary>
            Gets an awaitable that schedules continuations on the specified scheduler.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter">
            <summary>
            An awaiter returned from <see cref="M:Microsoft.VisualStudio.Threading.AwaitExtensions.GetAwaiter(System.Threading.Tasks.TaskScheduler)" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter.scheduler">
            <summary>
            The scheduler for continuations.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter.alwaysYield">
            <summary>
            A value indicating whether <see cref="P:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter.IsCompleted" />
            should always return false.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter.#ctor(System.Threading.Tasks.TaskScheduler,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter" /> struct.
            </summary>
            <param name="scheduler">The scheduler for continuations.</param>
            <param name="alwaysYield">A value indicating whether the caller should yield even if
            already executing on the desired task scheduler.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter.IsCompleted">
            <summary>
            Gets a value indicating whether no yield is necessary.
            </summary>
            <value><c>true</c> if the caller is already running on that TaskScheduler.</value>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter.OnCompleted(System.Action)">
            <summary>
            Schedules a continuation to execute using the specified task scheduler.
            </summary>
            <param name="continuation">The delegate to invoke.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>
            Schedules a continuation to execute using the specified task scheduler
            without capturing the ExecutionContext.
            </summary>
            <param name="continuation">The action.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter.GetResult">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfiguredTaskYieldAwaitable">
            <summary>
            An awaitable that will always lead the calling async method to yield,
            then immediately resume, possibly on the original <see cref="T:System.Threading.SynchronizationContext" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfiguredTaskYieldAwaitable.continueOnCapturedContext">
            <summary>
            A value indicating whether the continuation should run on the captured <see cref="T:System.Threading.SynchronizationContext" />, if any.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfiguredTaskYieldAwaitable.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfiguredTaskYieldAwaitable" /> struct.
            </summary>
            <param name="continueOnCapturedContext">A value indicating whether the continuation should run on the captured <see cref="T:System.Threading.SynchronizationContext" />, if any.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfiguredTaskYieldAwaitable.GetAwaiter">
            <summary>
            Gets the awaiter.
            </summary>
            <returns>The awaiter.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfiguredTaskYieldAwaiter">
            <summary>
            An awaiter that will always lead the calling async method to yield,
            then immediately resume, possibly on the original <see cref="T:System.Threading.SynchronizationContext" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfiguredTaskYieldAwaiter.continueOnCapturedContext">
            <summary>
            A value indicating whether the continuation should run on the captured <see cref="T:System.Threading.SynchronizationContext" />, if any.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfiguredTaskYieldAwaiter.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfiguredTaskYieldAwaiter" /> struct.
            </summary>
            <param name="continueOnCapturedContext">A value indicating whether the continuation should run on the captured <see cref="T:System.Threading.SynchronizationContext" />, if any.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfiguredTaskYieldAwaiter.IsCompleted">
            <summary>
            Gets a value indicating whether the caller should yield.
            </summary>
            <value>Always false.</value>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfiguredTaskYieldAwaiter.OnCompleted(System.Action)">
            <summary>
            Schedules a continuation to execute immediately (but not synchronously).
            </summary>
            <param name="continuation">The delegate to invoke.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfiguredTaskYieldAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>
            Schedules a delegate for execution at the conclusion of a task's execution
            without capturing the ExecutionContext.
            </summary>
            <param name="continuation">The action.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ConfiguredTaskYieldAwaiter.GetResult">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaitable">
            <summary>
            A Task awaitable that has affinity to executing callbacks synchronously on the completing callstack.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaitable.antecedent">
            <summary>
            The task whose completion will execute the continuation.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaitable.#ctor(System.Threading.Tasks.Task)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaitable" /> struct.
            </summary>
            <param name="antecedent">The task whose completion will execute the continuation.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaitable.GetAwaiter">
            <summary>
            Gets the awaiter.
            </summary>
            <returns>The awaiter.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaiter">
            <summary>
            A Task awaiter that has affinity to executing callbacks synchronously on the completing callstack.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaiter.antecedent">
            <summary>
            The task whose completion will execute the continuation.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaiter.#ctor(System.Threading.Tasks.Task)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaiter" /> struct.
            </summary>
            <param name="antecedent">The task whose completion will execute the continuation.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaiter.IsCompleted">
            <summary>
            Gets a value indicating whether the antedent <see cref="T:System.Threading.Tasks.Task" /> has already completed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaiter.GetResult">
            <summary>
            Rethrows any exception thrown by the antecedent.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaiter.OnCompleted(System.Action)">
            <summary>
            Schedules a callback to run when the antecedent task completes.
            </summary>
            <param name="continuation">The callback to invoke.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaitable`1">
            <summary>
            A Task awaitable that has affinity to executing callbacks synchronously on the completing callstack.
            </summary>
            <typeparam name="T">The type of value returned by the awaited <see cref="T:System.Threading.Tasks.Task" />.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaitable`1.antecedent">
            <summary>
            The task whose completion will execute the continuation.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaitable`1.#ctor(System.Threading.Tasks.Task{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaitable`1" /> struct.
            </summary>
            <param name="antecedent">The task whose completion will execute the continuation.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaitable`1.GetAwaiter">
            <summary>
            Gets the awaiter.
            </summary>
            <returns>The awaiter.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaiter`1">
            <summary>
            A Task awaiter that has affinity to executing callbacks synchronously on the completing callstack.
            </summary>
            <typeparam name="T">The type of value returned by the awaited <see cref="T:System.Threading.Tasks.Task" />.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaiter`1.antecedent">
            <summary>
            The task whose completion will execute the continuation.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaiter`1.#ctor(System.Threading.Tasks.Task{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaiter`1" /> struct.
            </summary>
            <param name="antecedent">The task whose completion will execute the continuation.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaiter`1.IsCompleted">
            <summary>
            Gets a value indicating whether the antedent <see cref="T:System.Threading.Tasks.Task" /> has already completed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaiter`1.GetResult">
            <summary>
            Rethrows any exception thrown by the antecedent.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.ExecuteContinuationSynchronouslyAwaiter`1.OnCompleted(System.Action)">
            <summary>
            Schedules a callback to run when the antecedent task completes.
            </summary>
            <param name="continuation">The callback to invoke.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AwaitExtensions.DownlevelRegistryWatcherSupport">
            <summary>
            Provides a dedicated thread for requesting registry change notifications.
            </summary>
            <remarks>
            For versions of Windows prior to Windows 8, requesting registry change notifications
            required that the thread that made the request remain alive or else the watcher would
            simply signal the event and stop watching for changes.
            This class provides a single, dedicated thread for requesting such notifications
            so that they don't get canceled when a thread happens to exit.
            The dedicated thread is released when no one is watching the registry any more.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.DownlevelRegistryWatcherSupport.SmallThreadStackSize">
            <summary>
            The size of the stack allocated for a thread that expects to stay within just a few methods in depth.
            </summary>
            <remarks>
            The default stack size for a thread is 1MB.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.DownlevelRegistryWatcherSupport.SyncObject">
            <summary>
            The object to lock when accessing any fields.
            This is also the object that is waited on by the dedicated thread,
            and may be pulsed by others to wake the dedicated thread to do some work.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.DownlevelRegistryWatcherSupport.PendingWork">
            <summary>
            A queue of actions the dedicated thread should take.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.DownlevelRegistryWatcherSupport.keepAliveCount">
            <summary>
            The number of callers that still have an interest in the survival of the dedicated thread.
            The dedicated thread will exit when this value reaches 0.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.DownlevelRegistryWatcherSupport.liveThread">
            <summary>
            The thread that should stay alive and be dequeuing <see cref="F:Microsoft.VisualStudio.Threading.AwaitExtensions.DownlevelRegistryWatcherSupport.PendingWork" />.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.DownlevelRegistryWatcherSupport.ExecuteOnDedicatedThreadAsync(System.Action)">
            <summary>
            Executes some action on a long-lived thread.
            </summary>
            <param name="action">The delegate to execute.</param>
            <returns>
            A task that either faults with the exception thrown by <paramref name="action" />
            or completes after successfully executing the delegate
            with a result that should be disposed when it is safe to terminate the long-lived thread.
            </returns>
            <remarks>
            This thread never posts to <see cref="P:System.Threading.SynchronizationContext.Current" />, so it is safe
            to call this method and synchronously block on its result.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.DownlevelRegistryWatcherSupport.ReleaseRefOnDedicatedThread">
            <summary>
            Decrements the count of interested parties in the live thread,
            and helps it to terminate if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.DownlevelRegistryWatcherSupport.Worker">
            <summary>
            Executes thread-affinitized work from a queue until both the queue is empty
            and any lingering interest in the survival of the dedicated thread has been released.
            </summary>
            <remarks>
            This method serves as the <see cref="T:System.Threading.ThreadStart" /> for our dedicated thread.
            </remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AwaitExtensions.DownlevelRegistryWatcherSupport.ThreadHandleRelease">
            <summary>
            Decrements the dedicated thread use counter by at most one upon disposal.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.DownlevelRegistryWatcherSupport.ThreadHandleRelease.disposed">
            <summary>
            A value indicating whether this instance has already been disposed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.DownlevelRegistryWatcherSupport.ThreadHandleRelease.Dispose">
            <summary>
            Release the keep alive count reserved by this instance.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.CancellationTokenExtensions">
            <summary>
            Extensions to <see cref="T:System.Threading.CancellationToken" />.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombineWith(System.Threading.CancellationToken,System.Threading.CancellationToken)">
            <summary>
            Creates a new <see cref="T:System.Threading.CancellationToken" /> that is canceled when any of a set of other tokens are canceled.
            </summary>
            <param name="original">The first token.</param>
            <param name="other">The second token.</param>
            <returns>A struct that contains the combined <see cref="T:System.Threading.CancellationToken" /> and a means to release memory when you're done using it.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombineWith(System.Threading.CancellationToken,System.Threading.CancellationToken[])">
            <summary>
            Creates a new <see cref="T:System.Threading.CancellationToken" /> that is canceled when any of a set of other tokens are canceled.
            </summary>
            <param name="original">The first token.</param>
            <param name="others">The additional tokens.</param>
            <returns>A struct that contains the combined <see cref="T:System.Threading.CancellationToken" /> and a means to release memory when you're done using it.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken">
            <summary>
            Provides access to a <see cref="T:System.Threading.CancellationToken" /> that combines multiple other tokens,
            and allows convenient disposal of any applicable <see cref="T:System.Threading.CancellationTokenSource" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken.cts">
            <summary>
            The object to dispose when this struct is disposed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken.#ctor(System.Threading.CancellationTokenSource)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken" /> struct
            that contains an aggregate <see cref="T:System.Threading.CancellationToken" /> whose source must be disposed.
            </summary>
            <param name="cancellationTokenSource">The cancellation token source.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken.#ctor(System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken" /> struct
            that represents just a single, non-disposable <see cref="T:System.Threading.CancellationToken" />.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken.Token">
            <summary>
            Gets the combined cancellation token.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken.op_Equality(Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken,Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken)">
            <summary>
            Checks whether two instances of <see cref="T:Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken" /> are equal.
            </summary>
            <param name="left">The left operand.</param>
            <param name="right">The right operand.</param>
            <returns><c>true</c> if they are equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken.op_Inequality(Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken,Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken)">
            <summary>
            Checks whether two instances of <see cref="T:Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken" /> are not equal.
            </summary>
            <param name="left">The left operand.</param>
            <param name="right">The right operand.</param>
            <returns><c>true</c> if they are not equal; <c>false</c> if they are equal.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken.Dispose">
            <summary>
            Disposes the <see cref="T:System.Threading.CancellationTokenSource" /> behind this combined token, if any.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken.Equals(Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.CancellationTokenExtensions.CombinedCancellationToken.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.DelegatingJoinableTaskFactory">
            <summary>
            A JoinableTaskFactory base class for derived types that delegate some of their work to an existing instance.
            </summary>
            <remarks>
            All virtual methods default to calling into the inner <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory" /> for its behavior,
            rather than the default behavior of the base class.
            This is useful because a derived-type cannot call protected methods on another instance of that type.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.DelegatingJoinableTaskFactory.innerFactory">
            <summary>
            The inner factory that will create the tasks.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.DelegatingJoinableTaskFactory.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.DelegatingJoinableTaskFactory" /> class.
            </summary>
            <param name="innerFactory">The inner factory that will create the tasks.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.DelegatingJoinableTaskFactory.WaitSynchronously(System.Threading.Tasks.Task)">
            <summary>
            Synchronously blocks the calling thread for the completion of the specified task.
            </summary>
            <param name="task">The task whose completion is being waited on.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.DelegatingJoinableTaskFactory.PostToUnderlyingSynchronizationContext(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Posts a message to the specified underlying SynchronizationContext for processing when the main thread
            is freely available.
            </summary>
            <param name="callback">The callback to invoke.</param>
            <param name="state">State to pass to the callback.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.DelegatingJoinableTaskFactory.OnTransitioningToMainThread(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Raised when a joinable task has requested a transition to the main thread.
            </summary>
            <param name="joinableTask">The task requesting the transition to the main thread.</param>
            <remarks>
            This event may be raised on any thread, including the main thread.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.DelegatingJoinableTaskFactory.OnTransitionedToMainThread(Microsoft.VisualStudio.Threading.JoinableTask,System.Boolean)">
            <summary>
            Raised whenever a joinable task has completed a transition to the main thread.
            </summary>
            <param name="joinableTask">The task whose request to transition to the main thread has completed.</param>
            <param name="canceled">A value indicating whether the transition was cancelled before it was fulfilled.</param>
            <remarks>
            This event is usually raised on the main thread, but can be on another thread when <paramref name="canceled" /> is <c>true</c>.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.Dgml.Namespace">
            <summary>
            The namespace that all DGML nodes appear in.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.Dgml.WithCategories(System.Xml.Linq.XElement,System.String[])">
            <summary>
            Adds categories to a DGML node or link.
            </summary>
            <param name="element">The node or link to add categories to.</param>
            <param name="categories">The categories to add.</param>
            <returns>The same node that was passed in. To enable "fluent" syntax.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.DispatcherExtensions">
            <summary>
            Extension methods for the WPF <see cref="T:System.Windows.Threading.Dispatcher" /> for better
            interop with the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory" />.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.DispatcherExtensions.WithPriority(Microsoft.VisualStudio.Threading.JoinableTaskFactory,System.Windows.Threading.Dispatcher,System.Windows.Threading.DispatcherPriority)">
            <summary>
            Creates a <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory" /> that schedules work with the specified
            <see cref="T:System.Windows.Threading.Dispatcher" /> and <see cref="T:System.Windows.Threading.DispatcherPriority" />.
            </summary>
            <param name="joinableTaskFactory">The underlying <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory" /> to use.</param>
            <param name="dispatcher">The <see cref="T:System.Windows.Threading.Dispatcher" /> that schedules work on the main thread.</param>
            <param name="priority">
            The priority with which to schedule any work on the UI thread,
            when and if <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SwitchToMainThreadAsync(System.Threading.CancellationToken)" /> is called
            and for each asynchronous return to the main thread after an <c>await</c>.
            </param>
            <returns>A <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory" /> that may be used for scheduling async work with the specified priority.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.DispatcherExtensions.DispatcherJoinableTaskFactory">
            <summary>
            A <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory" /> that schedules work on the UI thread
            according to a given <see cref="T:System.Windows.Threading.DispatcherPriority" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.DispatcherExtensions.DispatcherJoinableTaskFactory.dispatcher">
            <summary>
            The <see cref="T:System.Windows.Threading.Dispatcher" /> to use for scheduling work on the UI thread.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.DispatcherExtensions.DispatcherJoinableTaskFactory.priority">
            <summary>
            The priority with which to schedule work on the UI thread.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.DispatcherExtensions.DispatcherJoinableTaskFactory.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskFactory,System.Windows.Threading.Dispatcher,System.Windows.Threading.DispatcherPriority)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.DispatcherExtensions.DispatcherJoinableTaskFactory" /> class.
            </summary>
            <param name="innerFactory">The underlying <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory" /> to use when scheduling.</param>
            <param name="dispatcher">The <see cref="T:System.Windows.Threading.Dispatcher" /> to use for scheduling work on the UI thread.</param>
            <param name="priority">The priority with which to schedule work on the UI thread.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.DispatcherExtensions.DispatcherJoinableTaskFactory.PostToUnderlyingSynchronizationContext(System.Threading.SendOrPostCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.EmptyStruct">
            <summary>
            An empty struct.
            </summary>
            <remarks>
            This can save 4 bytes over System.Object when a type argument is required for a generic type, but entirely unused.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.EmptyStruct.Instance">
            <summary>
            Gets an instance of the empty struct.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1">
            <summary>
            Enumerates either a single element or a list of elements.
            </summary>
            <typeparam name="T">The type of element to enumerate.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.value">
            <summary>
            The single element to enumerate, when applicable.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.enumerator">
            <summary>
            The enumerator of the list.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.justOne">
            <summary>
            A value indicating whether a single element or a list of them is being enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.position">
            <summary>
            The position around the lone element being enumerated, when applicable.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1" /> struct.
            </summary>
            <param name="value">The single value to enumerate.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.#ctor(System.Collections.Generic.List{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1" /> struct.
            </summary>
            <param name="values">The list of values to enumerate.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.Current">
            <summary>
            Gets the current value.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current value.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.Dispose">
            <summary>
            Disposes this enumerator.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.MoveNext">
            <summary>
            Advances enumeration to the next element.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.System#Collections#IEnumerator#Reset">
            <summary>
            Resets this enumerator.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.HangReportContribution">
            <summary>
            A contribution to an aggregate hang report.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.HangReportContribution.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.HangReportContribution" /> class.
            </summary>
            <param name="content">The content for the hang report.</param>
            <param name="contentType">The MIME type of the attached content.</param>
            <param name="contentName">The suggested filename of the content when it is attached in a report.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.HangReportContribution.#ctor(System.String,System.String,System.String,Microsoft.VisualStudio.Threading.HangReportContribution[])">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.HangReportContribution" /> class.
            </summary>
            <param name="content">The content for the hang report.</param>
            <param name="contentType">The MIME type of the attached content.</param>
            <param name="contentName">The suggested filename of the content when it is attached in a report.</param>
            <param name="nestedReports">Nested reports.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.HangReportContribution.Content">
            <summary>
            Gets the content of the hang report.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.HangReportContribution.ContentType">
            <summary>
            Gets the MIME type for the content.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.HangReportContribution.ContentName">
            <summary>
            Gets the suggested filename for the content.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.HangReportContribution.NestedReports">
            <summary>
            Gets the nested hang reports, if any.
            </summary>
            <value>A read only collection, or <c>null</c>.</value>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.IAsyncDisposable">
            <summary>
            Defines an asynchronous method to release allocated resources.
            </summary>
            <remarks>
            Consider implementing <see cref="T:System.IAsyncDisposable" /> instead.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.IAsyncDisposable.DisposeAsync">
            <summary>
            Performs application-defined tasks associated with freeing,
            releasing, or resetting unmanaged resources asynchronously.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.IHangReportContributor">
            <summary>
            Provides a facility to produce reports that may be useful when analyzing hangs.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.IHangReportContributor.GetHangReport">
            <summary>
            Contributes data for a hang report.
            </summary>
            <returns>The hang report contribution. Null values should be ignored.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.IJoinableTaskDependent">
            <summary>
            Represents a dependent item in the JoinableTask dependency graph, it can be either a <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" /> or a <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCollection" />.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.IJoinableTaskDependent.JoinableTaskContext">
            <summary>
            Gets the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> this node belongs to.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.IJoinableTaskDependent.NeedRefCountChildDependencies">
            <summary>
            Gets a value indicating whether we need reference count child dependent node.  This is to keep the current behavior of <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCollection" />.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.IJoinableTaskDependent.GetJoinableTaskDependentData">
            <summary>
            Get the reference of dependent node to record dependencies.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.IJoinableTaskDependent.OnAddedToDependency(Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            A function is called, when this dependent node is added to be a dependency of a parent node.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.IJoinableTaskDependent.OnRemovedFromDependency(Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            A function is called, when this dependent node is removed as a dependency of a parent node.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.IJoinableTaskDependent.OnDependencyAdded(Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            A function is called, when a dependent child is added.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.IJoinableTaskDependent.OnDependencyRemoved(Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            A function is called, when a dependent child is removed.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.InlineResumable">
            <summary>
            An awaiter that can be pre-created, and later immediately execute its one scheduled continuation.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.InlineResumable.continuation">
            <summary>
            The continuation that has been scheduled.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.InlineResumable.capturedSynchronizationContext">
            <summary>
            The current <see cref="T:System.Threading.SynchronizationContext" /> as of when the continuation was scheduled.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.InlineResumable.resumed">
            <summary>
            Whether <see cref="M:Microsoft.VisualStudio.Threading.InlineResumable.Resume" /> has been called already.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.InlineResumable.IsCompleted">
            <summary>
            Gets a value indicating whether an awaiting expression should yield.
            </summary>
            <value>Always <c>false</c>.</value>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.InlineResumable.GetResult">
            <summary>
            Does and returns nothing.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.InlineResumable.OnCompleted(System.Action)">
            <summary>
            Stores the continuation for later execution when <see cref="M:Microsoft.VisualStudio.Threading.InlineResumable.Resume" /> is invoked.
            </summary>
            <param name="continuation">The delegate to execute later.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.InlineResumable.UnsafeOnCompleted(System.Action)">
            <summary>
            Stores the continuation for later execution when <see cref="M:Microsoft.VisualStudio.Threading.InlineResumable.Resume" /> is invoked.
            </summary>
            <param name="continuation">The delegate to execute later.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.InlineResumable.GetAwaiter">
            <summary>
            Gets this instance. This method makes this awaiter double as its own awaitable.
            </summary>
            <returns>This instance.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.InlineResumable.Resume">
            <summary>
            Executes the continuation immediately, on the caller's thread.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.InternalUtilities">
            <summary>
            Internal helper/extension methods for this assembly's own use.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.InternalUtilities.AsyncReturnStackPrefix">
            <summary>
            The substring that should be inserted before each async return stack frame.
            </summary>
            <remarks>
            When printing synchronous callstacks, .NET begins each frame with " at ".
            When printing async return stack, we use this to indicate continuations.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.InternalUtilities.RemoveMidQueue``1(System.Collections.Generic.Queue{``0},``0)">
            <summary>
            Removes an element from the middle of a queue without disrupting the other elements.
            </summary>
            <typeparam name="T">The element to remove.</typeparam>
            <param name="queue">The queue to modify.</param>
            <param name="valueToRemove">The value to remove.</param>
            <remarks>
            If a value appears multiple times in the queue, only its first entry is removed.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.InternalUtilities.GetAsyncReturnStackFrames(System.Delegate)">
            <summary>
            Walk the continuation objects inside "async state machines" to generate the return callstack.
            FOR DIAGNOSTIC PURPOSES ONLY.
            </summary>
            <param name="continuationDelegate">The delegate that represents the head of an async continuation chain.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.InternalUtilities.GetDelegateLabel(System.Delegate)">
            <summary>
            A helper method to get the label of the given delegate.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.InternalUtilities.GetAddress(System.Object)">
            <summary>
            Gets the memory address of a given object.
            </summary>
            <param name="value">The object to get the address for.</param>
            <returns>The memory address.</returns>
            <remarks>
            This method works when GCHandle will refuse because the type of object is a non-blittable type.
            However, this method provides no guarantees that the address will remain valid for the caller,
            so it is only useful for diagnostics and when we don't expect addresses to be changing much any more.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.InternalUtilities.FindAsyncStateMachine(System.Delegate)">
            <summary>
            A helper method to find the async state machine from the given delegate.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.InternalUtilities.FindContinuationDelegates(System.Runtime.CompilerServices.IAsyncStateMachine)">
            <summary>
            This is the core to find the continuation delegate(s) inside the given async state machine.
            The chain of objects is like this: async state machine -&gt; async method builder -&gt; task -&gt; continuation object -&gt; action.
            </summary>
            <remarks>
            There are 3 types of "async method builder": AsyncVoidMethodBuilder, AsyncTaskMethodBuilder, AsyncTaskMethodBuilder&lt;T&gt;.
            We don't cover AsyncVoidMethodBuilder as it is used rarely and it can't be awaited either;
            AsyncTaskMethodBuilder is a wrapper on top of AsyncTaskMethodBuilder&lt;VoidTaskResult&gt;.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.InternalUtilities.GetFieldValue(System.Object,System.String)">
            <summary>
            A helper method to get field's value given the object and the field name.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.InternalUtilities.GetStateMachineFieldValueOnSuffix(System.Runtime.CompilerServices.IAsyncStateMachine,System.String)">
            <summary>
            The field names of "async state machine" are not fixed; the workaround is to find the field based on the suffix.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTask">
            <summary>
            Tracks asynchronous operations and provides the ability to Join those operations to avoid
            deadlocks while synchronously blocking the Main thread for the operation's completion.
            </summary>
            <remarks>
            For more complete comments please see the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" />.
            </remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTask.ExecutionQueue">
            <summary>
            A thread-safe queue of <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector" /> elements
            that self-scavenges elements that are executed by other means.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext">
            <summary>
            A synchronization context that forwards posted messages to the ambient job.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.jobFactory">
            <summary>
            The owning job factory.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.mainThreadAffinitized">
            <summary>
            A flag indicating whether messages posted to this instance should execute
            on the main thread.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.job">
            <summary>
            The owning job. May be null from the beginning, or cleared after task completion.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext" /> class
            that is affinitized to the main thread.
            </summary>
            <param name="owner">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory" /> that created this instance.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.#ctor(Microsoft.VisualStudio.Threading.JoinableTask,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext" /> class.
            </summary>
            <param name="joinableTask">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" /> that owns this instance.</param>
            <param name="mainThreadAffinitized">A value indicating whether messages posted to this instance should execute on the main thread.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.MainThreadAffinitized">
            <summary>
            Gets a value indicating whether messages posted to this instance should execute
            on the main thread.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Forwards the specified message to the job this instance belongs to if applicable; otherwise to the factory.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Forwards a message to the ambient job and blocks on its execution.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.OnCompleted">
            <summary>
            Called by the joinable task when it has completed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.CompletingTask">
            <summary>
            Stores the top-most JoinableTask that is completing on the current thread, if any.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.owner">
            <summary>
            The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> that began the async operation.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.creationOptions">
            <summary>
            Store the task's initial creationOptions.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.nestingFactories">
            <summary>
            Other instances of <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory" /> that should be posted
            to with any main thread bound work.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.dependentData">
            <summary>
            The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData" /> to track dependencies between tasks.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.dependencyParents">
            <summary>
            The collections that this job is a member of.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.wrappedTask">
            <summary>
            The <see cref="T:System.Threading.Tasks.Task" /> returned by the async delegate that this JoinableTask originally executed,
            or a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> if the <see cref="P:Microsoft.VisualStudio.Threading.JoinableTask.Task" /> property was observed before <see cref="F:Microsoft.VisualStudio.Threading.JoinableTask.initialDelegate" />
            had given us a Task.
            </summary>
            <value>
            This is <c>null</c> until after <see cref="F:Microsoft.VisualStudio.Threading.JoinableTask.initialDelegate" /> returns a <see cref="P:Microsoft.VisualStudio.Threading.JoinableTask.Task" /> (or the <see cref="P:Microsoft.VisualStudio.Threading.JoinableTask.Task" /> property is observed),
            and retains its value even after this JoinableTask completes.
            </value>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.queueNeedProcessEvent">
            <summary>
            An event that is signaled when any queue in the dependent has item to process.  Lazily constructed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.pendingEventSource">
            <summary>
            The <see cref="F:Microsoft.VisualStudio.Threading.JoinableTask.queueNeedProcessEvent" /> is triggered by this JoinableTask, this allows a quick access to the event.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.pendingEventCount">
            <summary>
            The uplimit of the number pending events. The real number can be less because dependency can be removed, or a pending event can be processed.
            The number is critical, so it should only be updated in the lock region.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.mainThreadQueue">
            <summary>The queue of work items. Lazily constructed.</summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.initialDelegate">
            <summary>
            Stores the task's initial delegate so we could show its full name in hang report.
            This may not *actually* be the real delegate that was invoked for this instance, but
            it's the meaningful one that should be shown in hang reports.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.weakSelf">
            <summary>
            Backing field for the <see cref="P:Microsoft.VisualStudio.Threading.JoinableTask.WeakSelf" /> property.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskFactory,System.Boolean,Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions,System.Delegate)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" /> class.
            </summary>
            <param name="owner">The instance that began the async operation.</param>
            <param name="synchronouslyBlocking">A value indicating whether the launching thread will synchronously block for this job's completion.</param>
            <param name="creationOptions">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions" /> used to customize the task's behavior.</param>
            <param name="initialDelegate">The entry method's info for diagnostics.</param>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskFlags.None">
            <summary>
            No other flags defined.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskFlags.StartedSynchronously">
            <summary>
            This task was originally started as a synchronously executing one.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskFlags.StartedOnMainThread">
            <summary>
            This task was originally started on the main thread.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskFlags.CompleteRequested">
            <summary>
            This task has had its Complete method called, but may have lingering continuations to execute.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskFlags.CompleteFinalized">
            <summary>
            This task has completed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskFlags.CompletingSynchronously">
            <summary>
            This exact task has been passed to the <see cref="M:Microsoft.VisualStudio.Threading.JoinableTask.CompleteOnCurrentThread" /> method.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskFlags.SynchronouslyBlockingMainThread">
            <summary>
            This exact task has been passed to the <see cref="M:Microsoft.VisualStudio.Threading.JoinableTask.CompleteOnCurrentThread" /> method
            on the main thread.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.IsCompleted">
            <summary>
            Gets a value indicating whether the async operation represented by this instance has completed,
            as represented by its <see cref="P:Microsoft.VisualStudio.Threading.JoinableTask.Task" /> property's <see cref="P:System.Threading.Tasks.Task.IsCompleted" /> value.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.Task">
            <summary>
            Gets the asynchronous task that completes when the async operation completes.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.TaskCompletingOnThisThread">
            <summary>
            Gets the JoinableTask that is completing (i.e. synchronously blocking) on this thread, nearest to the top of the callstack.
            </summary>
            <remarks>
            This property is intentionally non-public to avoid its abuse by outside callers.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.AwaitShouldCaptureSyncContext">
            <summary>
            Gets a value indicating whether an awaiter should capture the
            <see cref="T:System.Threading.SynchronizationContext" />.
            </summary>
            <remarks>
            As a library, we generally wouldn't capture the <see cref="T:System.Threading.SynchronizationContext" />
            when awaiting, except that where our thread is synchronously blocking anyway, it is actually
            more efficient to capture the <see cref="T:System.Threading.SynchronizationContext" /> so that the continuation
            will resume on the blocking thread instead of occupying yet another one in order to execute.
            In fact, when threadpool starvation conditions exist, resuming on the calling thread
            can avoid significant delays in executing an often trivial continuation.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.IsFullyCompleted">
            <summary>
            Gets a value indicating whether the async operation and any extra queues tracked by this instance has completed.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.NestingFactories">
            <summary>
            Gets or sets the set of nesting factories (excluding <see cref="F:Microsoft.VisualStudio.Threading.JoinableTask.owner" />)
            that own JoinableTasks that are nesting this one.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.WeakSelf">
            <summary>
            Gets a weak reference to this object.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.PotentialUnreachableDependents">
            <summary>
            Gets or sets potential unreachable dependent nodes.
            This is a special collection only used in synchronized task when there are other tasks which are marked to block it through ref-count code.
            However, it is possible the reference count is retained by loop-dependencies. This collection tracking those items,
            so the clean-up logic can run when it becomes necessary.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.HasPotentialUnreachableDependents">
            <summary>
            Gets a value indicating whether PotentialUnreachableDependents is empty.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.State">
            <summary>
            Gets the flags set on this task.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.CreationOptions">
            <summary>
            Gets the task's initial creationOptions.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.EntryMethodInfo">
            <summary>
            Gets the entry method's info so we could show its full name in hang report.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.HasNonEmptyQueue">
            <summary>
            Gets a value indicating whether this task has a non-empty queue.
            FOR DIAGNOSTICS COLLECTION ONLY.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.MainThreadQueueContents">
            <summary>
            Gets a snapshot of all work queued to the main thread.
            FOR DIAGNOSTICS COLLECTION ONLY.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.ThreadPoolQueueContents">
            <summary>
            Gets a snapshot of all work queued to synchronously blocking threadpool thread.
            FOR DIAGNOSTICS COLLECTION ONLY.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.ContainingCollections">
            <summary>
            Gets the collections this task belongs to.
            FOR DIAGNOSTICS COLLECTION ONLY.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.IsCompleteRequested">
            <summary>
            Gets or sets a value indicating whether this task has had its Complete() method called..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskContext">
            <summary>
            Gets JoinableTaskContext for <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContextNode" /> to access locks.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.Join(System.Threading.CancellationToken)">
            <summary>
            Synchronously blocks the calling thread until the operation has completed.
            If the caller is on the Main thread (or is executing within a JoinableTask that has access to the main thread)
            the caller's access to the Main thread propagates to this JoinableTask so that it may also access the main thread.
            </summary>
            <param name="cancellationToken">A cancellation token that will exit this method before the task is completed.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.JoinAsync(System.Threading.CancellationToken)">
            <summary>
            Shares any access to the main thread the caller may have
            Joins any main thread affinity of the caller with the asynchronous operation to avoid deadlocks
            in the event that the main thread ultimately synchronously blocks waiting for the operation to complete.
            </summary>
            <param name="cancellationToken">
            A cancellation token that will revert the Join and cause the returned task to complete
            before the async operation has completed.
            </param>
            <returns>A task that completes after the asynchronous operation completes and the join is reverted.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.GetAwaiter">
            <summary>
            Gets an awaiter that is equivalent to calling <see cref="M:Microsoft.VisualStudio.Threading.JoinableTask.JoinAsync(System.Threading.CancellationToken)" />.
            </summary>
            <returns>A task whose result is the result of the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.CreateTaskCompletionSource">
            <summary>
            Instantiate a <see cref="T:Microsoft.VisualStudio.Threading.TaskCompletionSourceWithoutInlining`1" /> that can track the ultimate result of <see cref="F:Microsoft.VisualStudio.Threading.JoinableTask.initialDelegate" />.
            </summary>
            <returns>The new task completion source.</returns>
            <remarks>
            The implementation should be sure to instantiate a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> that will
            NOT inline continuations, since we'll be completing this ourselves, potentially while holding a private lock.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.GetTaskFromCompletionSource(System.Object)">
            <summary>
            Retrieves the <see cref="P:Microsoft.VisualStudio.Threading.TaskCompletionSourceWithoutInlining`1.Task" /> from a <see cref="T:Microsoft.VisualStudio.Threading.TaskCompletionSourceWithoutInlining`1" />.
            </summary>
            <param name="taskCompletionSource">The task completion source.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task" /> that will complete with this <see cref="T:Microsoft.VisualStudio.Threading.TaskCompletionSourceWithoutInlining`1" />.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.CompleteTaskSourceFromWrappedTask(System.Threading.Tasks.Task,System.Object)">
            <summary>
            Completes a <see cref="T:Microsoft.VisualStudio.Threading.TaskCompletionSourceWithoutInlining`1" />.
            </summary>
            <param name="wrappedTask">The task to read a result from.</param>
            <param name="taskCompletionSource">The <see cref="T:Microsoft.VisualStudio.Threading.TaskCompletionSourceWithoutInlining`1" /> created earlier with <see cref="M:Microsoft.VisualStudio.Threading.JoinableTask.CreateTaskCompletionSource" /> to apply the result to.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.Complete(System.Threading.Tasks.Task)">
            <summary>
            Fires when the underlying Task is completed.
            </summary>
            <param name="wrappedTask">The actual result from <see cref="F:Microsoft.VisualStudio.Threading.JoinableTask.initialDelegate" />.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.CompleteOnCurrentThread">
            <summary>Runs a loop to process all queued work items, returning only when the task is completed.</summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.GetPendingEventCountForSynchronousTask(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Get the number of pending messages to be process for the synchronous task.
            </summary>
            <param name="synchronousTask">The synchronous task.</param>
            <returns>The number of events need be processed by the synchronous task in the current JoinableTask.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.RegisterPendingEventsForSynchrousTask(Microsoft.VisualStudio.Threading.JoinableTask,System.Int32)">
            <summary>
            This is a helper method to parepare notifing the sychronous task for pending events.
            It must be called inside JTF lock, and returns a collection of event to trigger later. (Those events must be triggered out of the JTF lock.)
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.AddStateFlags(Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskFlags)">
            <summary>
            Adds the specified flags to the <see cref="F:Microsoft.VisualStudio.Threading.JoinableTask.state" /> field.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskCollection">
            <summary>
            A collection of incomplete <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" /> objects.
            </summary>
            <remarks>
            Any completed <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" /> is automatically removed from the collection.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskCollection.refCountAddedJobs">
            <summary>
            A value indicating whether joinable tasks are only removed when completed or removed as many times as they were added.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskCollection.displayName">
            <summary>
            A human-readable name that may appear in hang reports.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskCollection.dependentData">
            <summary>
            The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData" /> to track dependencies between tasks.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskCollection.emptyEvent">
            <summary>
            An event that is set when the collection is empty (lazily initialized).
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskContext,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCollection" /> class.
            </summary>
            <param name="context">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> instance to which this collection applies.</param>
            <param name="refCountAddedJobs">
            <c>true</c> if JoinableTask instances added to the collection multiple times should remain in the collection until they are
            either removed the same number of times or until they are completed;
            <c>false</c> causes the first Remove call for a JoinableTask to remove it from this collection regardless
            how many times it had been added.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskCollection.Context">
            <summary>
            Gets the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> to which this collection belongs.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskCollection.DisplayName">
            <summary>
            Gets or sets a human-readable name that may appear in hang reports.
            </summary>
            <remarks>
            This property should *not* be set to a value that may disclose
            personally identifiable information or other confidential data
            since this value may be included in hang reports sent to a third party.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskCollection.Microsoft#VisualStudio#Threading#IJoinableTaskDependent#JoinableTaskContext">
            <summary>
            Gets JoinableTaskContext for <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData" /> to access locks.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskCollection.Microsoft#VisualStudio#Threading#IJoinableTaskDependent#NeedRefCountChildDependencies">
            <summary>
            Gets a value indicating whether we need count reference for child dependent nodes.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.Add(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Adds the specified <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" /> to this collection.
            </summary>
            <param name="joinableTask">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" /> to add to the collection.</param>
            <remarks>
            As the collection only stores *incomplete* <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" /> instances,
            if the <paramref name="joinableTask" /> is already completed, it will not be added to the collection and this method will simply return.
            Any <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" /> instances added to the collection will be automatically removed upon completion.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.Remove(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Removes the specified <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" /> from this collection,
            or decrements the ref count if this collection tracks that.
            </summary>
            <param name="joinableTask">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" /> to remove.</param>
            <remarks>
            Completed <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" /> instances are automatically removed from the collection.
            Calling this method to remove them is not necessary.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.Join">
            <summary>
            Shares access to the main thread that the caller's JoinableTask may have (if any) with all
            JoinableTask instances in this collection until the returned value is disposed.
            </summary>
            <returns>A value to dispose of to revert the join.</returns>
            <remarks>
            Calling this method when the caller is not executing within a JoinableTask safely no-ops.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.JoinTillEmptyAsync">
            <summary>
            Joins the caller's context to this collection till the collection is empty.
            </summary>
            <returns>A task that completes when this collection is empty.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.JoinTillEmptyAsync(System.Threading.CancellationToken)">
            <summary>
            Joins the caller's context to this collection till the collection is empty.
            </summary>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>A task that completes when this collection is empty, or is canceled when <paramref name="cancellationToken" /> is canceled.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.Contains(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Checks whether the specified joinable task is a member of this collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.GetEnumerator">
            <summary>
            Enumerates the tasks in this collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerates the tasks in this collection.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskCollection.JoinRelease">
            <summary>
            A value whose disposal cancels a <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.Join" /> operation.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.JoinRelease.#ctor(Microsoft.VisualStudio.Threading.IJoinableTaskDependent,Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCollection.JoinRelease" /> struct.
            </summary>
            <param name="parentDependencyNode">The Main thread controlling SingleThreadSynchronizationContext to use to accelerate execution of Main thread bound work.</param>
            <param name="childDependencyNode">The instance that created this value.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.JoinRelease.Dispose">
            <summary>
            Cancels the <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.Join" /> operation.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskContext">
            <summary>
            A common context within which joinable tasks may be created and interact to avoid deadlocks.
            </summary>
            <devremarks>
            Lots of documentation and FAQ on Joinable Tasks is available on OneNote: <![CDATA[
            http://devdiv/sites/vspe/prjbld/_layouts/OneNote.aspx?id=%2fsites%2fvspe%2fprjbld%2fOneNote%2fTeamInfo&wd=target%28VS%20Threading.one%7c46FEAAD0-0131-45EE-8C52-C9893F1FD331%2fThreading%20Rules%7cD0EEFAB9-99C0-4B8F-AA5F-4287DD69A38F%2f%29
            ]]>.
            </devremarks>
            <remarks>
            There are three rules that should be strictly followed when using or interacting
            with JoinableTasks:
             1. If a method has certain thread apartment requirements (STA or MTA) it must either:
                  a) Have an asynchronous signature, and asynchronously marshal to the appropriate
                     thread if it isn't originally invoked on a compatible thread.
                     The recommended way to switch to the main thread is:
                     <code>
                     await JoinableTaskFactory.SwitchToMainThreadAsync();
                     </code>
                  b) Have a synchronous signature, and throw an exception when called on the wrong thread.
                In particular, no method is allowed to synchronously marshal work to another thread
                (blocking while that work is done). Synchronous blocks in general are to be avoided
                whenever possible.
             2. When an implementation of an already-shipped public API must call asynchronous code
                and block for its completion, it must do so by following this simple pattern:
                <code>
                JoinableTaskFactory.Run(async delegate {
                    await SomeOperationAsync(...);
                });
                </code>
             3. If ever awaiting work that was started earlier, that work must be Joined.
                For example, one service kicks off some asynchronous work that may later become
                synchronously blocking:
                <code>
                JoinableTask longRunningAsyncWork = JoinableTaskFactory.RunAsync(async delegate {
                    await SomeOperationAsync(...);
                });
                </code>
                Then later that async work becomes blocking:
                <code>
                longRunningAsyncWork.Join();
                </code>
                or perhaps:
                <code>
                await longRunningAsyncWork;
                </code>
                Note however that this extra step is not necessary when awaiting is done
                immediately after kicking off an asynchronous operation.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.Microsoft#VisualStudio#Threading#IHangReportContributor#GetHangReport">
            <summary>
            Contributes data for a hang report.
            </summary>
            <returns>The hang report contribution.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.GetHangReport">
            <summary>
            Contributes data for a hang report.
            </summary>
            <returns>The hang report contribution. Null values should be ignored.</returns>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContext.syncContextLock">
            <summary>
            A "global" lock that allows the graph of interconnected sync context and JoinableSet instances
            communicate in a thread-safe way without fear of deadlocks due to each taking their own private
            lock and then calling others, thus leading to deadlocks from lock ordering issues.
            </summary>
            <remarks>
            Yes, global locks should be avoided wherever possible. However even MEF from the .NET Framework
            uses a global lock around critical composition operations because containers can be interconnected
            in arbitrary ways. The code in this file has a very similar problem, so we use a similar solution.
            Except that our lock is only as global as the JoinableTaskContext. It isn't static.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContext.joinableOperation">
            <summary>
            An AsyncLocal value that carries the joinable instance associated with an async operation.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContext.pendingTasks">
            <summary>
            The set of tasks that have started but have not yet completed.
            </summary>
            <remarks>
            All access to this collection should be guarded by locking this collection.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContext.initializingSynchronouslyMainThreadTasks">
            <summary>
            The stack of tasks which synchronously blocks the main thread in the initial stage (before it yields and CompleteOnCurrentThread starts.)
            </summary>
            <remarks>
            Normally we expect this stack contains 0 or 1 task. When a synchronous task starts another synchronous task in the initialization stage,
            we might get more than 1 tasks, but it should be very rare to exceed 2 tasks.
            All access to this collection should be guarded by locking this collection.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContext.hangNotifications">
            <summary>
            A set of receivers of hang notifications.
            </summary>
            <remarks>
            All access to this collection should be guarded by locking this collection.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContext.mainThreadManagedThreadId">
            <summary>
            The ManagedThreadID for the main thread.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContext.nonJoinableFactory">
            <summary>
            A single joinable task factory that itself cannot be joined.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> class
            assuming the current thread is the main thread and
            <see cref="P:System.Threading.SynchronizationContext.Current" /> will provide the means to switch
            to the main thread from another thread.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.#ctor(System.Threading.Thread,System.Threading.SynchronizationContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> class.
            </summary>
            <param name="mainThread">
            The thread to switch to in <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SwitchToMainThreadAsync(System.Threading.CancellationToken)" />.
            If omitted, the current thread will be assumed to be the main thread.
            </param>
            <param name="synchronizationContext">
            The synchronization context to use to switch to the main thread.
            </param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.Factory">
            <summary>
            Gets the factory which creates joinable tasks
            that do not belong to a joinable task collection.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.MainThread">
            <summary>
            Gets the main thread that can be shared by tasks created by this context.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.IsOnMainThread">
            <summary>
            Gets a value indicating whether the caller is executing on the main thread.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.IsWithinJoinableTask">
            <summary>
            Gets a value indicating whether the caller is currently running within the context of a joinable task.
            </summary>
            <remarks>
            Use of this property is generally discouraged, as any operation that becomes a no-op when no
            ambient JoinableTask is present is very cheap. For clients that have complex algorithms that are
            only relevant if an ambient joinable task is present, this property may serve to skip that for
            performance reasons.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.UnderlyingSynchronizationContext">
            <summary>
            Gets the underlying <see cref="T:System.Threading.SynchronizationContext" /> that controls the main thread in the host.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.SyncContextLock">
            <summary>
            Gets the context-wide synchronization lock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.AmbientTask">
            <summary>
            Gets or sets the caller's ambient joinable task.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.NoMessagePumpSynchronizationContext">
            <summary>
            Gets a <see cref="T:System.Threading.SynchronizationContext" /> which, when applied,
            suppresses any message pump that may run during synchronous blocks
            of the calling thread.
            </summary>
            <remarks>
            The default implementation of this property is effective
            in builds of this assembly that target the .NET Framework.
            But on builds that target the portable profile, it should be
            overridden to provide an effective platform-specific solution.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.SuppressRelevance">
             <summary>
             Conceals any JoinableTask the caller is associated with until the returned value is disposed.
             </summary>
             <returns>A value to dispose of to restore visibility into the caller's associated JoinableTask, if any.</returns>
             <remarks>
             <para>In some cases asynchronous work may be spun off inside a delegate supplied to Run,
             so that the work does not have privileges to re-enter the Main thread until the
             <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Run(System.Func{System.Threading.Tasks.Task})" /> call has returned and the UI thread is idle.
             To prevent the asynchronous work from automatically being allowed to re-enter the Main thread,
             wrap the code that calls the asynchronous task in a <c>using</c> block with a call to this method
             as the expression.</para>
             <example>
             <code>
             this.JoinableTaskContext.RunSynchronously(async delegate {
                 using(this.JoinableTaskContext.SuppressRelevance()) {
                     var asyncOperation = Task.Run(async delegate {
                         // Some background work.
                         await this.JoinableTaskContext.SwitchToMainThreadAsync();
                         // Some Main thread work, that cannot begin until the outer RunSynchronously call has returned.
                     });
                 }
            
                 // Because the asyncOperation is not related to this Main thread work (it was suppressed),
                 // the following await *would* deadlock if it were uncommented.
                 ////await asyncOperation;
             });
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.IsMainThreadBlocked">
            <summary>
            Gets a value indicating whether the main thread is blocked for the caller's completion.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.IsMainThreadMaybeBlocked">
            <summary>
            Gets a very likely value whether the main thread is blocked for the caller's completion.
            It is less accurate when the UI thread blocking task just starts and hasn't been blocked yet, or the dependency chain is just removed.
            However, unlike <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.IsMainThreadBlocked" />, this implementation is lock free, and faster in high contention scenarios.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.CreateFactory(Microsoft.VisualStudio.Threading.JoinableTaskCollection)">
            <summary>
            Creates a joinable task factory that automatically adds all created tasks
            to a collection that can be jointly joined.
            </summary>
            <param name="collection">The collection that all tasks should be added to.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.CreateCollection">
            <summary>
            Creates a collection for in-flight joinable tasks.
            </summary>
            <returns>A new joinable task collection.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.OnJoinableTaskStarted(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Raised when a joinable task starts.
            </summary>
            <param name="task">The task that has started.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.OnJoinableTaskCompleted(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Raised when a joinable task completes.
            </summary>
            <param name="task">The completing task.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.OnSynchronousJoinableTaskToCompleteOnMainThread(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Raised when it starts to wait a joinable task to complete in the main thread.
            </summary>
            <param name="task">The task requires to be completed.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.RegisterHangNotifications(Microsoft.VisualStudio.Threading.JoinableTaskContextNode)">
            <summary>
            Registers a node for notification when a hang is detected.
            </summary>
            <param name="node">The instance to notify.</param>
            <returns>A value to dispose of to cancel registration.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.OnHangDetected(System.TimeSpan,System.Int32,System.Guid)">
            <summary>
            Invoked when a hang is suspected to have occurred involving the main thread.
            </summary>
            <param name="hangDuration">The duration of the current hang.</param>
            <param name="notificationCount">The number of times this hang has been reported, including this one.</param>
            <param name="hangId">A random GUID that uniquely identifies this particular hang.</param>
            <remarks>
            A single hang occurrence may invoke this method multiple times, with increasing
            values in the <paramref name="hangDuration" /> parameter.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.OnFalseHangDetected(System.TimeSpan,System.Guid)">
            <summary>
            Invoked when an earlier hang report is false alarm.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.CreateDefaultFactory">
            <summary>
            Creates a factory without a <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCollection" />.
            </summary>
            <remarks>
            Used for initializing the <see cref="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.Factory" /> property.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.Dispose(System.Boolean)">
            <summary>
            Disposes managed and unmanaged resources held by this instance.
            </summary>
            <param name="disposing"><c>true</c> if <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.Dispose" /> was called; <c>false</c> if the object is being finalized.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskContext.RevertRelevance">
            <summary>
            A structure that clears CallContext and SynchronizationContext async/thread statics and
            restores those values when this structure is disposed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.RevertRelevance.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext.RevertRelevance" /> struct.
            </summary>
            <param name="pump">The instance that created this value.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.RevertRelevance.Dispose">
            <summary>
            Reverts the async local and thread static values to their original values.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangDetails">
            <summary>
            A class to encapsulate the details of a possible hang.
            An instance of this <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangDetails" /> class will be passed to the
            <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContextNode" /> instances who registered the hang notifications.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangDetails.#ctor(System.TimeSpan,System.Int32,System.Guid,System.Reflection.MethodInfo)">
            <summary>Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangDetails" /> class.</summary>
            <param name="hangDuration">The duration of the current hang.</param>
            <param name="notificationCount">The number of times this hang has been reported, including this one.</param>
            <param name="hangId">A random GUID that uniquely identifies this particular hang.</param>
            <param name="entryMethod">The method that served as the entrypoint for the JoinableTask.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangDetails.HangDuration">
            <summary>
            Gets the length of time this hang has lasted so far.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangDetails.NotificationCount">
            <summary>
            Gets the number of times this particular hang has been reported, including this one.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangDetails.HangId">
            <summary>
            Gets a unique GUID identifying this particular hang.
            If the same hang is reported multiple times (with increasing duration values)
            the value of this property will remain constant.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangDetails.EntryMethod">
            <summary>
            Gets the method that served as the entrypoint for the JoinableTask that now blocks a thread.
            </summary>
            <remarks>
            The method indicated here may not be the one that is actually blocking a thread,
            but typically a deadlock is caused by a violation of a threading rule which is under
            the entrypoint's control. So usually regardless of where someone chooses the block
            a thread for the completion of a <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" />, a hang usually indicates
            a bug in the code that created it.
            This value may be used to assign the hangs to different buckets based on this method info.
            </remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangNotificationRegistration">
            <summary>
            A value whose disposal cancels hang registration.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangNotificationRegistration.node">
            <summary>
            The node to receive notifications. May be <c>null</c> if <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangNotificationRegistration.Dispose" /> has already been called.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangNotificationRegistration.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskContextNode)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangNotificationRegistration" /> class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangNotificationRegistration.Dispose">
            <summary>
            Removes the node from hang notifications.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskContextException">
            <summary>
            An exception thrown when the configuration provided to the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" />
            are incorrect or a virtual method is overridden such that it violates a contract.
            This exception should not be caught. It is thrown when the application has a programming fault.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContextException" /> class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContextException" /> class.
            </summary>
            <param name="message">The message for the exception.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContextException" /> class.
            </summary>
            <param name="message">The message for the exception.</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContextException" /> class.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskContextNode">
            <summary>
            A customizable source of <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory" /> instances.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.context">
            <summary>
            The inner JoinableTaskContext.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.nonJoinableFactory">
            <summary>
            A single joinable task factory that itself cannot be joined.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContextNode" /> class.
            </summary>
            <param name="context">The inner JoinableTaskContext.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.Factory">
            <summary>
            Gets the factory which creates joinable tasks
            that do not belong to a joinable task collection.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.MainThread">
            <summary>
            Gets the main thread that can be shared by tasks created by this context.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.IsOnMainThread">
            <summary>
            Gets a value indicating whether the caller is executing on the main thread.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.Context">
            <summary>
            Gets the inner wrapped context.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.CreateFactory(Microsoft.VisualStudio.Threading.JoinableTaskCollection)">
            <summary>
            Creates a joinable task factory that automatically adds all created tasks
            to a collection that can be jointly joined.
            </summary>
            <param name="collection">The collection that all tasks should be added to.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.CreateCollection">
            <summary>
            Creates a collection for in-flight joinable tasks.
            </summary>
            <returns>A new joinable task collection.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.SuppressRelevance">
             <summary>
             Conceals any JoinableTask the caller is associated with until the returned value is disposed.
             </summary>
             <returns>A value to dispose of to restore visibility into the caller's associated JoinableTask, if any.</returns>
             <remarks>
             <para>In some cases asynchronous work may be spun off inside a delegate supplied to Run,
             so that the work does not have privileges to re-enter the Main thread until the
             <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Run(System.Func{System.Threading.Tasks.Task})" /> call has returned and the UI thread is idle.
             To prevent the asynchronous work from automatically being allowed to re-enter the Main thread,
             wrap the code that calls the asynchronous task in a <c>using</c> block with a call to this method
             as the expression.</para>
             <example>
             <code>
             this.JoinableTaskContext.RunSynchronously(async delegate {
                 using(this.JoinableTaskContext.SuppressRelevance()) {
                     var asyncOperation = Task.Run(async delegate {
                         // Some background work.
                         await this.JoinableTaskContext.SwitchToMainThreadAsync();
                         // Some Main thread work, that cannot begin until the outer RunSynchronously call has returned.
                     });
                 }
            
                 // Because the asyncOperation is not related to this Main thread work (it was suppressed),
                 // the following await *would* deadlock if it were uncommented.
                 ////await asyncOperation;
             });
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.IsMainThreadBlocked">
            <summary>
            Gets a value indicating whether the main thread is blocked for the caller's completion.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.OnHangDetected(Microsoft.VisualStudio.Threading.JoinableTaskContext.HangDetails)">
            <summary>
            Invoked when a hang is suspected to have occurred involving the main thread.
            </summary>
            <param name="details">Describes the hang in detail.</param>
            <remarks>
            A single hang occurrence may invoke this method multiple times, with increasing
            values in the <see cref="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangDetails.NotificationCount" /> values
            in the <paramref name="details" /> parameter.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.OnFalseHangDetected(System.TimeSpan,System.Guid)">
            <summary>
            Invoked when an earlier hang report is false alarm.
            </summary>
            <param name="hangDuration">The duration of the total waiting time.</param>
            <param name="hangId">A GUID that uniquely identifies the earlier hang report.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.OnHangDetected(System.TimeSpan,System.Int32,System.Guid)">
            <summary>
            Invoked when a hang is suspected to have occurred involving the main thread.
            </summary>
            <param name="hangDuration">The duration of the current hang.</param>
            <param name="notificationCount">The number of times this hang has been reported, including this one.</param>
            <param name="hangId">A random GUID that uniquely identifies this particular hang.</param>
            <remarks>
            A single hang occurrence may invoke this method multiple times, with increasing
            values in the <paramref name="hangDuration" /> parameter.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.CreateDefaultFactory">
            <summary>
            Creates a factory without a <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCollection" />.
            </summary>
            <remarks>
            Used for initializing the <see cref="P:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.Factory" /> property.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.RegisterOnHangDetected">
            <summary>
            Registers with the inner <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> to receive hang notifications.
            </summary>
            <returns>A value to dispose of to cancel hang notifications.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions">
            <summary>
            Specifies flags that control optional behavior for the creation and execution of tasks.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions.None">
            <summary>
            Specifies that the default behavior should be used.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions.LongRunning">
            <summary>
            Specifies that a task will be a long-running operation. It provides a hint to the
            <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> that hang report should not be fired, when the main thread task is blocked on it.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph">
            <summary>
            Methods to maintain dependencies between <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" />.
            Those methods are expected to be called by <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" /> or <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCollection" /> only to maintain relationship between them, and should not be called directly by other code.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.HasNoChildDependentNode(Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            Gets a value indicating whether there is no child depenent item.
            This method is expected to be used with the JTF lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.HasDirectDependency(Microsoft.VisualStudio.Threading.IJoinableTaskDependent,Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            Checks whether a task or collection is a directly dependent of this item.
            This method is expected to be used with the JTF lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.HasMainThreadSynchronousTaskWaiting(Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            Gets a value indicating whether the main thread is waiting for the task's completion.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.MaybeHasMainThreadSynchronousTaskWaiting(Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            Gets a likely value whether the main thread is blocked for the caller's completion.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.AddDependency(Microsoft.VisualStudio.Threading.IJoinableTaskDependent,Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            Adds a <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData" /> instance as one that is relevant to the async operation.
            </summary>
            <param name="taskItem">The current joinableTask or collection.</param>
            <param name="joinChild">The <see cref="T:Microsoft.VisualStudio.Threading.IJoinableTaskDependent" /> to join as a child.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.RemoveDependency(Microsoft.VisualStudio.Threading.IJoinableTaskDependent,Microsoft.VisualStudio.Threading.IJoinableTaskDependent,System.Boolean)">
            <summary>
            Removes a <see cref="T:Microsoft.VisualStudio.Threading.IJoinableTaskDependent" /> instance as one that is no longer relevant to the async operation.
            </summary>
            <param name="taskItem">The current joinableTask or collection.</param>
            <param name="child">The <see cref="T:Microsoft.VisualStudio.Threading.IJoinableTaskDependent" /> to join as a child.</param>
            <param name="forceCleanup">Ignore refCount, it is being used when the child task is completed.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.GetDirectDependentNodes(Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            Gets all dependent nodes registered in the dependency collection.
            This method is expected to be used with the JTF lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.IsDependingSynchronousTask(Microsoft.VisualStudio.Threading.IJoinableTaskDependent,Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Check whether a task is being tracked in our tracking list.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.GetDependingSynchronousTasks(Microsoft.VisualStudio.Threading.IJoinableTaskDependent,System.Boolean)">
            <summary>
            Calculate the collection of events we need trigger after we enqueue a request.
            This method is expected to be used with the JTF lock.
            </summary>
            <param name="taskItem">The current joinableTask or collection.</param>
            <param name="forMainThread">True if we want to find tasks to process the main thread queue. Otherwise tasks to process the background queue.</param>
            <returns>The collection of synchronous tasks we need notify.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.GetAllDirectlyDependentJoinableTasks(Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            Gets a snapshot of all joined tasks.
            FOR DIAGNOSTICS COLLECTION ONLY.
            This method is expected to be used with the JTF lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.AddSelfAndDescendentOrJoinedJobs(Microsoft.VisualStudio.Threading.IJoinableTaskDependent,System.Collections.Generic.HashSet{Microsoft.VisualStudio.Threading.JoinableTask})">
            <summary>
            Recursively adds this joinable and all its dependencies to the specified set, that are not yet completed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.OnSynchronousTaskStartToBlockWaiting(Microsoft.VisualStudio.Threading.JoinableTask,Microsoft.VisualStudio.Threading.JoinableTask@,System.Int32@)">
            <summary>
            When the current dependent node is a synchronous task, this method is called before the thread is blocked to wait it to complete.
            This adds the current task to the dependingSynchronousTaskTracking list of the task itself (which will propergate through its dependencies.)
            After the task is finished, <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.OnSynchronousTaskEndToBlockWaiting(Microsoft.VisualStudio.Threading.JoinableTask)" /> is called to revert this change.
            This method is expected to be used with the JTF lock.
            </summary>
            <param name="taskItem">The current joinableTask or collection.</param>
            <param name="taskHasPendingRequests">Return the JoinableTask which has already had pending requests to be handled.</param>
            <param name="pendingRequestsCount">The number of pending requests.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.OnSynchronousTaskEndToBlockWaiting(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            When the current dependent node is a synchronous task, this method is called after the synchronous is completed, and the thread is no longer blocked.
            This removes the current task from the dependingSynchronousTaskTracking list of the task itself (and propergate through its dependencies.)
            It reverts the data structure change done in the <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.OnSynchronousTaskStartToBlockWaiting(Microsoft.VisualStudio.Threading.JoinableTask,Microsoft.VisualStudio.Threading.JoinableTask@,System.Int32@)" />.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.OnTaskCompleted(Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            Remove all synchronous tasks tracked by the this task.
            This is called when this task is completed.
            This method is expected to be used with the JTF lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.GetDependentTasksFromCandidates(System.Collections.Generic.IEnumerable{Microsoft.VisualStudio.Threading.JoinableTask},System.Collections.Generic.IEnumerable{Microsoft.VisualStudio.Threading.JoinableTask})">
            <summary>
            Get all tasks inside the candidate sets tasks, which are depended by one or more task in the source tasks list.
            </summary>
            <param name="sourceTasks">A collection of JoinableTasks represents source tasks.</param>
            <param name="candidateTasks">A collection of JoinableTasks which represents candidates.</param>
            <returns>A set of tasks matching the condition.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.CleanUpPotentialUnreachableDependentItems(Microsoft.VisualStudio.Threading.JoinableTask,System.Collections.Generic.HashSet{Microsoft.VisualStudio.Threading.IJoinableTaskDependent}@)">
            <summary>
            Computes dependency graph to clean up all potential unreachable dependents items.
            </summary>
            <param name="syncTask">A thread blocking sychornizing task.</param>
            <param name="allReachableNodes">Returns all reachable nodes in the connected dependency graph, if unreachable dependency is found.</param>
            <returns>True if it removes any unreachable items.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.RemoveUnreachableDependentItems(Microsoft.VisualStudio.Threading.JoinableTask,System.Collections.Generic.HashSet{Microsoft.VisualStudio.Threading.IJoinableTaskDependent},System.Collections.Generic.HashSet{Microsoft.VisualStudio.Threading.IJoinableTaskDependent})">
            <summary>
            Force to clean up all unreachable dependent item, so they are not marked to block the syncTask.
            </summary>
            <param name="syncTask">The thread blocking task.</param>
            <param name="unreachableItems">Unreachable dependent items.</param>
            <param name="reachableItems">All reachable items.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData">
            <summary>
            Preserve data for the JoinableTask dependency tree. It is holded inside either a <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" /> or a <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCollection" />.
            Do not call methods/properties directly anywhere out of <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.childDependentNodes">
            <summary>
            A map of jobs that we should be willing to dequeue from when we control the UI thread, and a ref count. Lazily constructed.
            </summary>
            <remarks>
            When the value in an entry is decremented to 0, the entry is removed from the map.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.dependingSynchronousTaskTracking">
            <summary>
            The head of a singly linked list of records to track which task may process events of this task.
            This list should contain only tasks which need be completed synchronously, and depends on this task.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.HasNoChildDependentNode">
            <summary>
            Gets a value indicating whether the <see cref="F:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.childDependentNodes" /> is empty.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.GetAllDirectlyDependentJoinableTasks(Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            Gets a snapshot of all joined tasks.
            FOR DIAGNOSTICS COLLECTION ONLY.
            This method is expected to be used with the JTF lock.
            </summary>
            <param name="taskOrCollection">The current joinableTask or collection contains this data.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.AddDependency(Microsoft.VisualStudio.Threading.IJoinableTaskDependent,Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            Adds a <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData" /> instance as one that is relevant to the async operation.
            </summary>
            <param name="parentTaskOrCollection">The current joinableTask or collection contains to add a dependency.</param>
            <param name="joinChild">The <see cref="T:Microsoft.VisualStudio.Threading.IJoinableTaskDependent" /> to join as a child.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.RemoveDependency(Microsoft.VisualStudio.Threading.IJoinableTaskDependent,Microsoft.VisualStudio.Threading.IJoinableTaskDependent,System.Boolean)">
            <summary>
            Removes a <see cref="T:Microsoft.VisualStudio.Threading.IJoinableTaskDependent" /> instance as one that is no longer relevant to the async operation.
            </summary>
            <param name="parentTaskOrCollection">The current joinableTask or collection contains to remove a dependency.</param>
            <param name="joinChild">The <see cref="T:Microsoft.VisualStudio.Threading.IJoinableTaskDependent" /> to join as a child.</param>
            <param name="forceCleanup">Ignore refCount, it is being used when the child task is completed.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.AddSelfAndDescendentOrJoinedJobs(Microsoft.VisualStudio.Threading.IJoinableTaskDependent,System.Collections.Generic.HashSet{Microsoft.VisualStudio.Threading.JoinableTask})">
            <summary>
            Recursively adds this joinable and all its dependencies to the specified set, that are not yet completed.
            </summary>
            <param name="taskOrCollection">The current joinableTask or collection contains this data.</param>
            <param name="joinables">A collection to hold <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" /> found.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.OnSynchronousTaskStartToBlockWaiting(Microsoft.VisualStudio.Threading.JoinableTask,Microsoft.VisualStudio.Threading.JoinableTask@,System.Int32@)">
            <summary>
            When the current dependent node is a synchronous task, this method is called before the thread is blocked to wait it to complete.
            This adds the current task to the <see cref="F:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.dependingSynchronousTaskTracking" /> of the task itself (which will propergate through its dependencies.)
            After the task is finished, <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.OnSynchronousTaskEndToBlockWaiting(Microsoft.VisualStudio.Threading.JoinableTask)" /> is called to revert this change.
            This method is expected to be used with the JTF lock.
            </summary>
            <param name="syncTask">The synchronized joinableTask.</param>
            <param name="taskHasPendingRequests">Return the JoinableTask which has already had pending requests to be handled.</param>
            <param name="pendingRequestsCount">The number of pending requests.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.OnSynchronousTaskEndToBlockWaiting(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            When the current dependent node is a synchronous task, this method is called after the synchronous is completed, and the thread is no longer blocked.
            This removes the current task from the <see cref="F:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.dependingSynchronousTaskTracking" /> of the task itself (and propergate through its dependencies.)
            It reverts the data structure change done in the <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.OnSynchronousTaskStartToBlockWaiting(Microsoft.VisualStudio.Threading.JoinableTask,Microsoft.VisualStudio.Threading.JoinableTask@,System.Int32@)" />.
            </summary>
            <param name="syncTask">The synchronized joinableTask.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.ComputeSelfAndDescendentOrJoinedJobsAndRemainTasks(Microsoft.VisualStudio.Threading.IJoinableTaskDependent,System.Collections.Generic.HashSet{Microsoft.VisualStudio.Threading.IJoinableTaskDependent},System.Collections.Generic.HashSet{Microsoft.VisualStudio.Threading.IJoinableTaskDependent})">
            <summary>
            Compute all reachable nodes from a synchronous task. Because we use the result to clean up invalid
            items from the remain task, we will remove valid task from the collection, and stop immediately if nothing is left.
            </summary>
            <param name="taskOrCollection">The current joinableTask or collection owns the data.</param>
            <param name="reachableNodes">All reachable dependency nodes. This is not a completed list, if there is no remain node.</param>
            <param name="remainNodes">Remain dependency nodes we want to check. After the execution, it will retain non-reachable nodes.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.RemoveUnreachableDependentItems(Microsoft.VisualStudio.Threading.JoinableTask,System.Collections.Generic.HashSet{Microsoft.VisualStudio.Threading.IJoinableTaskDependent},System.Collections.Generic.HashSet{Microsoft.VisualStudio.Threading.IJoinableTaskDependent})">
            <summary>
            Force to clean up all unreachable dependent item, so they are not marked to block the syncTask.
            </summary>
            <param name="syncTask">The thread blocking task.</param>
            <param name="unreachableItems">Unreachable dependent items.</param>
            <param name="reachableItemsReadOnlySet">All reachable items.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.GetDirectDependentNodes">
            <summary>
            Gets all dependent nodes registered in the <see cref="F:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.childDependentNodes" />
            This method is expected to be used with the JTF lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.HasDirectDependency(Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            Checks whether a dependent node is inside <see cref="F:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.childDependentNodes" />.
            This method is expected to be used with the JTF lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.HasMainThreadSynchronousTaskWaiting(Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            Gets a value indicating whether the main thread is waiting for the task's completion
            This method is expected to be used with the JTF lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.MaybeHasMainThreadSynchronousTaskWaiting">
            <summary>
            Gets a likely value whether the main thread is blocked for the caller's completion.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.OnTaskCompleted(Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            Remove all synchronous tasks tracked by the this task.
            This is called when this task is completed.
            This method is expected to be used with the JTF lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.IsDependingSynchronousTask(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Check whether a task is being tracked in our tracking list.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.GetDependingSynchronousTasks(System.Boolean)">
            <summary>
            Calculate the collection of events we need trigger after we enqueue a request.
            This method is expected to be used with the JTF lock.
            </summary>
            <param name="forMainThread">True if we want to find tasks to process the main thread queue. Otherwise tasks to process the background queue.</param>
            <returns>The collection of synchronous tasks we need notify.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.AddDependingSynchronousTaskToChild(Microsoft.VisualStudio.Threading.IJoinableTaskDependent,Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            Applies all synchronous tasks tracked by this task to a new child/dependent task.
            </summary>
            <param name="dependentNode">The current joinableTask or collection owns the data.</param>
            <param name="child">The new child task.</param>
            <returns>Pairs of synchronous tasks we need notify and the event source triggering it, plus the number of pending events.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.AddDependingSynchronousTask(Microsoft.VisualStudio.Threading.IJoinableTaskDependent,Microsoft.VisualStudio.Threading.JoinableTask,System.Int32@)">
            <summary>
            Tracks a new synchronous task for this task.
            A synchronous task is a task blocking a thread and waits it to be completed.  We may want the blocking thread
            to process events from this task.
            </summary>
            <param name="taskOrCollection">The current joinableTask or collection.</param>
            <param name="synchronousTask">The synchronous task.</param>
            <param name="totalEventsPending">The total events need be processed.</param>
            <returns>The task causes us to trigger the event of the synchronous task, so it can process new events.  Null means we don't need trigger any event.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.RemoveDependingSynchronousTask(Microsoft.VisualStudio.Threading.IJoinableTaskDependent,Microsoft.VisualStudio.Threading.JoinableTask,System.Boolean)">
            <summary>
            Remove a synchronous task from the tracking list.
            </summary>
            <param name="taskOrCollection">The current joinableTask or collection.</param>
            <param name="syncTask">The synchronous task.</param>
            <param name="force">We always remove it from the tracking list if it is true.  Otherwise, we keep tracking the reference count.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.RemoveDependingSynchronousTaskFrom(System.Collections.Generic.IReadOnlyList{Microsoft.VisualStudio.Threading.IJoinableTaskDependent},Microsoft.VisualStudio.Threading.JoinableTask,System.Boolean)">
            <summary>
            Remove a synchronous task from the tracking list of a list of tasks.
            </summary>
            <param name="tasks">A list of tasks we need update the tracking list.</param>
            <param name="syncTask">The synchronous task we want to remove.</param>
            <param name="force">We always remove it from the tracking list if it is true.  Otherwise, we keep tracking the reference count.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.RemoveDependingSynchronousTask(Microsoft.VisualStudio.Threading.IJoinableTaskDependent,Microsoft.VisualStudio.Threading.JoinableTask,System.Collections.Generic.HashSet{Microsoft.VisualStudio.Threading.IJoinableTaskDependent},System.Collections.Generic.HashSet{Microsoft.VisualStudio.Threading.IJoinableTaskDependent}@)">
            <summary>
            Remove a synchronous task from the tracking list of this task.
            </summary>
            <param name="taskOrCollection">The current joinableTask or collection.</param>
            <param name="task">The synchronous task.</param>
            <param name="reachableNodesReadOnlySet">
            If it is not null, it will contain all dependency nodes which can track the synchronous task. We will ignore reference count in that case.
            </param>
            <param name="remainingDependentNodes">This will retain the tasks which still tracks the synchronous task.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.CountOfDependingSynchronousTasks">
            <summary>
            Get how many number of synchronous tasks in our tracking list.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.RemoveDependingSynchronousTaskFromChild(Microsoft.VisualStudio.Threading.IJoinableTaskDependent)">
            <summary>
            Removes all synchronous tasks we applies to a dependent task, after the relationship is removed.
            </summary>
            <param name="child">The original dependent task.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.PendingNotification">
            <summary>
            The record of a pending notification we need send to the synchronous task that we have some new messages to process.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.PendingNotification.SynchronousTask">
            <summary>
            Gets the synchronous task which need process new messages.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.PendingNotification.TaskHasPendingMessages">
            <summary>
            Gets one JoinableTask which may have pending messages. We may have multiple new JoinableTasks which contains pending messages.
            This is just one of them.  It gives the synchronous task a way to start quickly without searching all messages.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.PendingNotification.NewPendingMessagesCount">
            <summary>
            Gets the total number of new pending messages.  The real number could be less than that, but should not be more than that.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.DependentSynchronousTask">
            <summary>
            A single linked list to maintain synchronous JoinableTask depends on the current task,
             which may process the queue of the current task.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.DependentSynchronousTask.Next">
            <summary>
            Gets or sets the chain of the single linked list.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.DependentSynchronousTask.SynchronousTask">
            <summary>
            Gets the synchronous task.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskDependencyGraph.JoinableTaskDependentData.DependentSynchronousTask.ReferenceCount">
            <summary>
            Gets or sets the reference count.  We remove the item from the list, if it reaches 0.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory">
            <summary>
            A factory for starting asynchronous tasks that can mitigate deadlocks
            when the tasks require the Main thread of an application and the Main
            thread may itself be blocking on the completion of a task.
            </summary>
            <remarks>
            For more complete comments please see the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" />.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.owner">
            <summary>
            The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> that owns this instance.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.jobCollection">
            <summary>
            The collection to add all created tasks to. May be <c>null</c>.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.hangDetectionTimeout">
            <summary>
            Backing field for the <see cref="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.HangDetectionTimeout" /> property.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory" /> class.
            </summary>
            <param name="owner">The context for the tasks created by this factory.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory" /> class
            that adds all generated jobs to the specified collection.
            </summary>
            <param name="collection">The collection that all tasks created by this factory will belong to till they complete.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskContext,Microsoft.VisualStudio.Threading.JoinableTaskCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory" /> class.
            </summary>
            <param name="owner">The context for the tasks created by this factory.</param>
            <param name="collection">The collection that all tasks created by this factory will belong to till they complete. May be null.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Context">
            <summary>
            Gets the joinable task context to which this factory belongs.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.ApplicableJobSyncContext">
            <summary>
            Gets the synchronization context to apply before executing work associated with this factory.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Collection">
            <summary>
            Gets the collection to which created tasks belong until they complete. May be null.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.HangDetectionTimeout">
            <summary>
            Gets or sets the timeout after which no activity while synchronously blocking
            suggests a hang has occurred.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.UnderlyingSynchronizationContext">
            <summary>
            Gets the underlying <see cref="T:System.Threading.SynchronizationContext" /> that controls the main thread in the host.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SwitchToMainThreadAsync(System.Threading.CancellationToken)">
             <summary>
             Gets an awaitable whose continuations execute on the synchronization context that this instance was initialized with,
             in such a way as to mitigate both deadlocks and reentrancy.
             </summary>
             <param name="cancellationToken">
             A token whose cancellation will immediately schedule the continuation
             on a threadpool thread and will cause the continuation to throw <see cref="T:System.OperationCanceledException" />,
             even if the caller is already on the main thread.
             </param>
             <returns>An awaitable.</returns>
             <exception cref="T:System.OperationCanceledException">
             Thrown back at the awaiting caller if <paramref name="cancellationToken" /> is canceled,
             even if the caller is already on the main thread.
             </exception>
             <remarks>
             <example>
             <code>
             private async Task SomeOperationAsync() {
                 // on the caller's thread.
                 await DoAsync();
            
                 // Now switch to a threadpool thread explicitly.
                 await TaskScheduler.Default;
            
                 // Now switch to the Main thread to talk to some STA object.
                 await this.JobContext.SwitchToMainThreadAsync();
                 STAService.DoSomething();
             }
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SwitchToMainThreadAsync(System.Boolean,System.Threading.CancellationToken)">
             <summary>
             Gets an awaitable whose continuations execute on the synchronization context that this instance was initialized with,
             in such a way as to mitigate both deadlocks and reentrancy.
             </summary>
             <param name="alwaysYield">A value indicating whether the caller should yield even if
             already executing on the main thread.</param>
             <param name="cancellationToken">
             A token whose cancellation will immediately schedule the continuation
             on a threadpool thread and will cause the continuation to throw <see cref="T:System.OperationCanceledException" />,
             even if the caller is already on the main thread.
             </param>
             <returns>An awaitable.</returns>
             <exception cref="T:System.OperationCanceledException">
             Thrown back at the awaiting caller if <paramref name="cancellationToken" /> is canceled,
             even if the caller is already on the main thread.
             </exception>
             <remarks>
             <example>
             <code>
             private async Task SomeOperationAsync()
             {
                 // This first part can be on the caller's thread, whatever that is.
                 DoSomething();
            
                 // Now switch to the Main thread to talk to some STA object.
                 // Supposing it is also important to *not* do this step on our caller's callstack,
                 // be sure we yield even if we're on the UI thread.
                 await this.JoinableTaskFactory.SwitchToMainThreadAsync(alwaysYield: true);
                 STAService.DoSomething();
             }
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Run(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Runs the specified asynchronous method to completion while synchronously blocking the calling thread.
            </summary>
            <param name="asyncMethod">The asynchronous method to execute.</param>
            <remarks>
            <para>Any exception thrown by the delegate is rethrown in its original type to the caller of this method.</para>
            <para>When the delegate resumes from a yielding await, the default behavior is to resume in its original context
            as an ordinary async method execution would. For example, if the caller was on the main thread, execution
            resumes after an await on the main thread; but if it started on a threadpool thread it resumes on a threadpool thread.</para>
            <example>
            <code>
            // On threadpool or Main thread, this method will block
            // the calling thread until all async operations in the
            // delegate complete.
            joinableTaskFactory.Run(async delegate {
                // still on the threadpool or Main thread as before.
                await OperationAsync();
                // still on the threadpool or Main thread as before.
                await Task.Run(async delegate {
                     // Now we're on a threadpool thread.
                     await Task.Yield();
                     // still on a threadpool thread.
                });
                // Now back on the Main thread (or threadpool thread if that's where we started).
            });
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Run(System.Func{System.Threading.Tasks.Task},Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions)">
            <summary>
            Runs the specified asynchronous method to completion while synchronously blocking the calling thread.
            </summary>
            <param name="asyncMethod">The asynchronous method to execute.</param>
            <param name="creationOptions">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions" /> used to customize the task's behavior.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Runs the specified asynchronous method to completion while synchronously blocking the calling thread.
            </summary>
            <typeparam name="T">The type of value returned by the asynchronous operation.</typeparam>
            <param name="asyncMethod">The asynchronous method to execute.</param>
            <returns>The result of the Task returned by <paramref name="asyncMethod" />.</returns>
            <remarks>
            <para>Any exception thrown by the delegate is rethrown in its original type to the caller of this method.</para>
            <para>When the delegate resumes from a yielding await, the default behavior is to resume in its original context
            as an ordinary async method execution would. For example, if the caller was on the main thread, execution
            resumes after an await on the main thread; but if it started on a threadpool thread it resumes on a threadpool thread.</para>
            <para>See the <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Run(System.Func{System.Threading.Tasks.Task})" /> overload documentation for an example.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Run``1(System.Func{System.Threading.Tasks.Task{``0}},Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions)">
            <summary>
            Runs the specified asynchronous method to completion while synchronously blocking the calling thread.
            </summary>
            <typeparam name="T">The type of value returned by the asynchronous operation.</typeparam>
            <param name="asyncMethod">The asynchronous method to execute.</param>
            <param name="creationOptions">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions" /> used to customize the task's behavior.</param>
            <returns>The result of the Task returned by <paramref name="asyncMethod" />.</returns>
            <remarks>
            <para>Any exception thrown by the delegate is rethrown in its original type to the caller of this method.</para>
            <para>When the delegate resumes from a yielding await, the default behavior is to resume in its original context
            as an ordinary async method execution would. For example, if the caller was on the main thread, execution
            resumes after an await on the main thread; but if it started on a threadpool thread it resumes on a threadpool thread.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.RunAsync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Invokes an async delegate on the caller's thread, and yields back to the caller when the async method yields.
            The async delegate is invoked in such a way as to mitigate deadlocks in the event that the async method
            requires the main thread while the main thread is blocked waiting for the async method's completion.
            </summary>
            <param name="asyncMethod">The method that, when executed, will begin the async operation.</param>
            <returns>An object that tracks the completion of the async operation, and allows for later synchronous blocking of the main thread for completion if necessary.</returns>
            <remarks>
            <para>Exceptions thrown by the delegate are captured by the returned <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" />.</para>
            <para>When the delegate resumes from a yielding await, the default behavior is to resume in its original context
            as an ordinary async method execution would. For example, if the caller was on the main thread, execution
            resumes after an await on the main thread; but if it started on a threadpool thread it resumes on a threadpool thread.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.RunAsync(System.Func{System.Threading.Tasks.Task},Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions)">
            <summary>
            Invokes an async delegate on the caller's thread, and yields back to the caller when the async method yields.
            The async delegate is invoked in such a way as to mitigate deadlocks in the event that the async method
            requires the main thread while the main thread is blocked waiting for the async method's completion.
            </summary>
            <param name="asyncMethod">The method that, when executed, will begin the async operation.</param>
            <returns>An object that tracks the completion of the async operation, and allows for later synchronous blocking of the main thread for completion if necessary.</returns>
            <param name="creationOptions">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions" /> used to customize the task's behavior.</param>
            <remarks>
            <para>Exceptions thrown by the delegate are captured by the returned <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" />.</para>
            <para>When the delegate resumes from a yielding await, the default behavior is to resume in its original context
            as an ordinary async method execution would. For example, if the caller was on the main thread, execution
            resumes after an await on the main thread; but if it started on a threadpool thread it resumes on a threadpool thread.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.RunAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Invokes an async delegate on the caller's thread, and yields back to the caller when the async method yields.
            The async delegate is invoked in such a way as to mitigate deadlocks in the event that the async method
            requires the main thread while the main thread is blocked waiting for the async method's completion.
            </summary>
            <typeparam name="T">The type of value returned by the asynchronous operation.</typeparam>
            <param name="asyncMethod">The method that, when executed, will begin the async operation.</param>
            <returns>
            An object that tracks the completion of the async operation, and allows for later synchronous blocking of the main thread for completion if necessary.
            </returns>
            <remarks>
            <para>Exceptions thrown by the delegate are captured by the returned <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" />.</para>
            <para>When the delegate resumes from a yielding await, the default behavior is to resume in its original context
            as an ordinary async method execution would. For example, if the caller was on the main thread, execution
            resumes after an await on the main thread; but if it started on a threadpool thread it resumes on a threadpool thread.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.RunAsync``1(System.Func{System.Threading.Tasks.Task{``0}},Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions)">
            <summary>
            Invokes an async delegate on the caller's thread, and yields back to the caller when the async method yields.
            The async delegate is invoked in such a way as to mitigate deadlocks in the event that the async method
            requires the main thread while the main thread is blocked waiting for the async method's completion.
            </summary>
            <typeparam name="T">The type of value returned by the asynchronous operation.</typeparam>
            <param name="asyncMethod">The method that, when executed, will begin the async operation.</param>
            <param name="creationOptions">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions" /> used to customize the task's behavior.</param>
            <returns>
            An object that tracks the completion of the async operation, and allows for later synchronous blocking of the main thread for completion if necessary.
            </returns>
            <remarks>
            <para>Exceptions thrown by the delegate are captured by the returned <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask" />.</para>
            <para>When the delegate resumes from a yielding await, the default behavior is to resume in its original context
            as an ordinary async method execution would. For example, if the caller was on the main thread, execution
            resumes after an await on the main thread; but if it started on a threadpool thread it resumes on a threadpool thread.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.RequestSwitchToMainThread(System.Action)">
            <summary>
            Responds to calls to <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.OnCompleted(System.Action)" />
            by scheduling a continuation to execute on the Main thread.
            </summary>
            <param name="callback">The callback to invoke.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.PostToUnderlyingSynchronizationContextOrThreadPool(Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector)">
            <summary>
            Posts a callback to the main thread via the underlying dispatcher,
            or to the threadpool when no dispatcher exists on the main thread.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Run(System.Func{System.Threading.Tasks.Task},Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions,System.Delegate)">
            <summary>Runs the specified asynchronous method.</summary>
            <param name="asyncMethod">The asynchronous method to execute.</param>
            <param name="creationOptions">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions" /> used to customize the task's behavior.</param>
            <param name="entrypointOverride">The delegate to record as the entrypoint for this JoinableTask.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.PostToUnderlyingSynchronizationContext(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Posts a message to the specified underlying SynchronizationContext for processing when the main thread
            is freely available.
            </summary>
            <param name="callback">The callback to invoke.</param>
            <param name="state">State to pass to the callback.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.OnTransitioningToMainThread(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Raised when a joinable task has requested a transition to the main thread.
            </summary>
            <param name="joinableTask">The task requesting the transition to the main thread.</param>
            <remarks>
            This event may be raised on any thread, including the main thread.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.OnTransitionedToMainThread(Microsoft.VisualStudio.Threading.JoinableTask,System.Boolean)">
            <summary>
            Raised whenever a joinable task has completed a transition to the main thread.
            </summary>
            <param name="joinableTask">The task whose request to transition to the main thread has completed.</param>
            <param name="canceled">A value indicating whether the transition was cancelled before it was fulfilled.</param>
            <remarks>
            This event is usually raised on the main thread, but can be on another thread when <paramref name="canceled" /> is <c>true</c>.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.WaitSynchronously(System.Threading.Tasks.Task)">
            <summary>
            Synchronously blocks the calling thread for the completion of the specified task.
            If running on the main thread, any applicable message pump is suppressed
            while the thread sleeps.
            </summary>
            <param name="task">The task whose completion is being waited on.</param>
            <remarks>
            Implementations should take care that exceptions from faulted or canceled tasks
            not be thrown back to the caller.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.WaitSynchronouslyCore(System.Threading.Tasks.Task)">
            <summary>
            Synchronously blocks the calling thread for the completion of the specified task.
            </summary>
            <param name="task">The task whose completion is being waited on.</param>
            <remarks>
            Implementations should take care that exceptions from faulted or canceled tasks
            not be thrown back to the caller.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.IsWaitingOnLongRunningTask">
            <summary>
            Check whether the current joinableTask is waiting on a long running task.
            </summary>
            <returns>Return true if the current synchronous task on the thread is waiting on a long running task.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Add(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Adds the specified joinable task to the applicable collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.VerifyNoNonConcurrentSyncContext">
            <summary>
            Throws an exception if an active AsyncReaderWriterLock
            upgradeable read or write lock is held by the caller.
            </summary>
            <remarks>
            This is important to call from the Run and Run{T} methods because
            if they are called from within an ARWL upgradeable read or write lock,
            then Run will synchronously block while inside the semaphore held
            by the ARWL that prevents concurrency. If the delegate within Run
            yields and then tries to reacquire the ARWL lock, it will be unable
            to re-enter the semaphore, leading to a deadlock.
            Instead, callers who hold UR/W locks should never call Run, or should
            switch to the STA thread first in order to exit the semaphore before
            calling the Run method.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.RunAsync(System.Func{System.Threading.Tasks.Task},System.Boolean,Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions,System.Delegate)">
            <summary>
            Wraps the invocation of an async method such that it may
            execute asynchronously, but may potentially be
            synchronously completed (waited on) in the future.
            </summary>
            <param name="asyncMethod">The asynchronous method to execute.</param>
            <param name="synchronouslyBlocking">A value indicating whether the launching thread will synchronously block for this job's completion.</param>
            <param name="creationOptions">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions" /> used to customize the task's behavior.</param>
            <param name="entrypointOverride">The entry method's info for diagnostics.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaitable">
            <summary>
            An awaitable struct that facilitates an asynchronous transition to the Main thread.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaitable.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskFactory,Microsoft.VisualStudio.Threading.JoinableTask,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaitable" /> struct.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaitable.GetAwaiter">
            <summary>
            Gets the awaiter.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter">
            <summary>
            An awaiter struct that facilitates an asynchronous transition to the Main thread.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.cancellationRegistrationPtr">
            <summary>
            Holds the reference to the <see cref="T:System.Threading.CancellationTokenRegistration" /> struct, so that all the copies of <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter" /> will hold
            the same <see cref="T:System.Threading.CancellationTokenRegistration" /> object.
            </summary>
            <remarks>
            This must be initialized to either null or an <see cref="T:System.Nullable`1" /> object holding no value.
            If this starts as an <see cref="T:System.Nullable`1" /> object object holding no value, then it means we are interested in the cancellation,
            and its state would be changed following one of these 2 patterns determined by the execution order.
            1. if <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.OnCompleted(System.Action)" /> finishes before <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.GetResult" /> is being executed on main thread,
            then this will hold the real registered value after <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.OnCompleted(System.Action)" />, and <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.GetResult" />
            will dispose that value and set a default value of <see cref="T:System.Threading.CancellationTokenRegistration" />.
            2. if <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.GetResult" /> is executed on main thread before <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.OnCompleted(System.Action)" /> registers the cancellation,
            then this will hold a default value of <see cref="T:System.Threading.CancellationTokenRegistration" />, and <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.OnCompleted(System.Action)" />
            would not touch it.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskFactory,Microsoft.VisualStudio.Threading.JoinableTask,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter" /> struct.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.IsCompleted">
            <summary>
            Gets a value indicating whether the caller is already on the Main thread.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>
            Schedules a continuation for execution on the Main thread
            without capturing the ExecutionContext.
            </summary>
            <param name="continuation">The action to invoke when the operation completes.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.OnCompleted(System.Action)">
            <summary>
            Schedules a continuation for execution on the Main thread.
            </summary>
            <param name="continuation">The action to invoke when the operation completes.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.GetResult">
            <summary>
            Called on the Main thread to prepare it to execute the continuation.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.OnCompleted(System.Action,System.Boolean)">
            <summary>
            Schedules a continuation for execution on the Main thread.
            </summary>
            <param name="continuation">The action to invoke when the operation completes.</param>
            <param name="flowExecutionContext">A value indicating whether to capture and reapply the current ExecutionContext for the continuation.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.RunFramework">
            <summary>
            A value to construct with a C# using block in all the Run method overloads
            to setup and teardown the boilerplate stuff.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.RunFramework.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskFactory,Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.RunFramework" /> struct
            and sets up the synchronization contexts for the
            <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Run(System.Func{System.Threading.Tasks.Task})" /> family of methods.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.RunFramework.Dispose">
            <summary>
            Reverts the execution context to its previous state before this struct was created.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector">
            <summary>
            A delegate wrapper that ensures the delegate is only invoked at most once.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.ExecuteOnce">
            <summary>
            Executes the delegate if it has not already executed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.ExecuteOnceWaitCallback">
            <summary>
            Executes the delegate if it has not already executed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.job">
            <summary>
            The job that created this wrapper.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.invokeDelegate">
            <summary>
            The delegate to invoke.  <c>null</c> if it has already been invoked.
            </summary>
            <value>May be of type <see cref="T:System.Action" /> or <see cref="T:System.Threading.SendOrPostCallback" />.</value>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.state">
            <summary>
            The value to pass to the delegate if it is a <see cref="T:System.Threading.SendOrPostCallback" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.executingCallbacks">
            <summary>
            Stores execution callbacks for <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.AddExecutingCallback(Microsoft.VisualStudio.Threading.JoinableTask.ExecutionQueue)" />.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.#ctor(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector" /> class.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.HasBeenExecuted">
            <summary>
            Gets a value indicating whether this instance has already executed.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.DelegateLabel">
            <summary>
            Gets a string that describes the delegate that this instance invokes.
            FOR DIAGNOSTIC PURPOSES ONLY.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.Create(Microsoft.VisualStudio.Threading.JoinableTask,System.Action)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector" /> class.
            </summary>
            <param name="job">The joinable task responsible for this work.</param>
            <param name="action">The delegate being wrapped.</param>
            <returns>An instance of <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector" />.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.Create(Microsoft.VisualStudio.Threading.JoinableTask,System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector" /> class
            that describes the specified callback.
            </summary>
            <param name="job">The joinable task responsible for this work.</param>
            <param name="callback">The callback to invoke.</param>
            <param name="state">The state object to pass to the callback.</param>
            <returns>An instance of <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector" />.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.AddExecutingCallback(Microsoft.VisualStudio.Threading.JoinableTask.ExecutionQueue)">
            <summary>
            Registers for a callback when this instance is executed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.RemoveExecutingCallback(Microsoft.VisualStudio.Threading.JoinableTask.ExecutionQueue)">
            <summary>
            Unregisters a callback for when this instance is executed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.WalkAsyncReturnStackFrames">
            <summary>
            Walk the continuation objects inside "async state machines" to generate the return callstack.
            FOR DIAGNOSTIC PURPOSES ONLY.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.TryExecute">
            <summary>
            Executes the delegate if it has not already executed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.OnExecuting">
            <summary>
            Invokes <see cref="M:Microsoft.VisualStudio.Threading.JoinableTask.ExecutionQueue.OnExecuting(System.Object,System.EventArgs)" /> handler.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTask`1">
            <summary>
            Tracks asynchronous operations and provides the ability to Join those operations to avoid
            deadlocks while synchronously blocking the Main thread for the operation's completion.
            </summary>
            <typeparam name="T">The type of value returned by the asynchronous operation.</typeparam>
            <remarks>
            For more complete comments please see the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" />.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask`1.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskFactory,System.Boolean,Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions,System.Delegate)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask`1" /> class.
            </summary>
            <param name="owner">The instance that began the async operation.</param>
            <param name="synchronouslyBlocking">A value indicating whether the launching thread will synchronously block for this job's completion.</param>
            <param name="creationOptions">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCreationOptions" /> used to customize the task's behavior.</param>
            <param name="initialDelegate">The entry method's info for diagnostics.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask`1.Task">
            <summary>
            Gets the asynchronous task that completes when the async operation completes.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask`1.JoinAsync(System.Threading.CancellationToken)">
            <summary>
            Joins any main thread affinity of the caller with the asynchronous operation to avoid deadlocks
            in the event that the main thread ultimately synchronously blocks waiting for the operation to complete.
            </summary>
            <param name="cancellationToken">A cancellation token that will exit this method before the task is completed.</param>
            <returns>A task that completes after the asynchronous operation completes and the join is reverted, with the result of the operation.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask`1.Join(System.Threading.CancellationToken)">
            <summary>
            Synchronously blocks the calling thread until the operation has completed.
            If the calling thread is the Main thread, deadlocks are mitigated.
            </summary>
            <param name="cancellationToken">A cancellation token that will exit this method before the task is completed.</param>
            <returns>The result of the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask`1.GetAwaiter">
            <summary>
            Gets an awaiter that is equivalent to calling <see cref="M:Microsoft.VisualStudio.Threading.JoinableTask`1.JoinAsync(System.Threading.CancellationToken)" />.
            </summary>
            <returns>A task whose result is the result of the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask`1.CreateTaskCompletionSource">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask`1.GetTaskFromCompletionSource(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask`1.CompleteTaskSourceFromWrappedTask(System.Threading.Tasks.Task,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.LightUps">
            <summary>
            A non-generic class used to store statics that do not vary by generic type argument.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.LightUps.ForceWindows7Mode">
            <summary>
            Gets a value indicating whether we execute Windows 7 code even on later versions of Windows.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.LightUps.Windows8Version">
            <summary>
            The <see cref="P:System.OperatingSystem.Version" /> for Windows 8.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.LightUps.IsWindows8OrLater">
            <summary>
            Gets a value indicating whether the current operating system is Windows 8 or later.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ListOfOftenOne`1">
            <summary>
            A thread-safe collection optimized for very small number of non-null elements.
            </summary>
            <typeparam name="T">The type of elements to be stored.</typeparam>
            <remarks>
            The collection is alloc-free for storage, retrieval and enumeration of collection sizes of 0 or 1.
            Beyond that causes one allocation for an immutable array that contains the entire collection.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.value">
            <summary>
            The single value or array of values stored by this collection. Null if empty.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.GetEnumerator">
            <summary>
            Returns an enumerator for a current snapshot of the collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Returns an enumerator for a current snapshot of the collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator for a current snapshot of the collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.Add(`0)">
            <summary>
            Adds an element to the collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.Remove(`0)">
            <summary>
            Removes an element from the collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.Contains(`0)">
            <summary>
            Checks for reference equality between the specified value and an element of this collection.
            </summary>
            <param name="value">The value to check for.</param>
            <returns><c>true</c> if a match is found; <c>false</c> otherwise.</returns>
            <remarks>
            This method is intended to hide the Linq Contains extension method to avoid
            the boxing of this struct and its Enumerator.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.EnumerateAndClear">
            <summary>
            Atomically clears the collection's contents and returns an enumerator over the prior contents.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.Combine(System.Object,`0)">
            <summary>
            Combines the previous contents of the collection with one additional value.
            </summary>
            <param name="baseValue">The collection's prior contents.</param>
            <param name="value">The value to add to the collection.</param>
            <returns>The new value to store as the collection.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.Remove(System.Object,`0)">
            <summary>
            Removes a value from contents of the collection.
            </summary>
            <param name="baseValue">The collection's prior contents.</param>
            <param name="value">The value to remove from the collection.</param>
            <returns>The new value to store as the collection.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.NativeMethods">
            <summary>
            P/Invoke methods.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.NativeMethods.REG_NOTIFY_THREAD_AGNOSTIC">
            <summary>
            Indicates that the lifetime of the registration must not be tied to the lifetime of the thread issuing the RegNotifyChangeKeyValue call.
            Note: This flag value is only supported in Windows 8 and later.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.NativeMethods.WaitForMultipleObjects(System.UInt32,System.IntPtr[],System.Boolean,System.UInt32)">
            <summary>
            Really truly non pumping wait.
            Raw IntPtrs have to be used, because the marshaller does not support arrays of SafeHandle, only
            single SafeHandles.
            </summary>
            <param name="handleCount">The number of handles in the <paramref name="waitHandles" /> array.</param>
            <param name="waitHandles">The handles to wait for.</param>
            <param name="waitAll">A flag indicating whether all handles must be signaled before returning.</param>
            <param name="millisecondsTimeout">A timeout that will cause this method to return.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.NativeMethods.RegNotifyChangeKeyValue(Microsoft.Win32.SafeHandles.SafeRegistryHandle,System.Boolean,Microsoft.VisualStudio.Threading.RegistryChangeNotificationFilters,Microsoft.Win32.SafeHandles.SafeWaitHandle,System.Boolean)">
            <summary>
            Registers to receive notification of changes to a registry key.
            </summary>
            <param name="hKey">The handle to the registry key to watch.</param>
            <param name="watchSubtree"><c>true</c> to watch the keys descendent keys as well; <c>false</c> to watch only this key without descendents.</param>
            <param name="notifyFilter">The types of changes to watch for.</param>
            <param name="hEvent">A handle to the event to set when a change occurs.</param>
            <param name="asynchronous">If this parameter is TRUE, the function returns immediately and reports changes by signaling the specified event. If this parameter is FALSE, the function does not return until a change has occurred.</param>
            <returns>A win32 error code. ERROR_SUCCESS (0) if successful.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.NoMessagePumpSyncContext">
            <summary>
            A SynchronizationContext whose synchronously blocking Wait method does not allow
            any reentrancy via the message pump.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.NoMessagePumpSyncContext.DefaultInstance">
            <summary>
            A shared singleton.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.NoMessagePumpSyncContext.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.NoMessagePumpSyncContext" /> class.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.NoMessagePumpSyncContext.Default">
            <summary>
            Gets a shared instance of this class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.NoMessagePumpSyncContext.Wait(System.IntPtr[],System.Boolean,System.Int32)">
            <summary>
            Synchronously blocks without a message pump.
            </summary>
            <param name="waitHandles">An array of type <see cref="T:System.IntPtr" /> that contains the native operating system handles.</param>
            <param name="waitAll">true to wait for all handles; false to wait for any handle.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
            <returns>
            The array index of the object that satisfied the wait.
            </returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.NonConcurrentSynchronizationContext">
            <summary>
            A <see cref="T:System.Threading.SynchronizationContext" /> that executes messages in the order they are received.
            </summary>
            <remarks>
            Delegates will be invoked in the order they are received on the threadpool.
            No two delegates will ever be executed concurrently, but <see cref="M:Microsoft.VisualStudio.Threading.NonConcurrentSynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)" /> may permit
            a delegate to execute inline on another.
            Note that if the delegate invokes an async method, the delegate formally ends
            when the async method yields for the first time or returns, whichever comes first.
            Once that delegate returns the next delegate can be executed.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.NonConcurrentSynchronizationContext.queue">
            <summary>
            The queue of work to execute, if this is the original instance.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.NonConcurrentSynchronizationContext.sticky">
            <summary>
            A value indicating whether to set this instance as <see cref="P:System.Threading.SynchronizationContext.Current" /> when invoking delegates.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.NonConcurrentSynchronizationContext.copyOf">
            <summary>
            The original instance (on which <see cref="M:Microsoft.VisualStudio.Threading.NonConcurrentSynchronizationContext.CreateCopy" /> was called).
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.NonConcurrentSynchronizationContext.activeManagedThreadId">
            <summary>
            Set to the <see cref="P:System.Environment.CurrentManagedThreadId" /> when a delegate is currently executing.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.NonConcurrentSynchronizationContext.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.NonConcurrentSynchronizationContext" /> class.
            </summary>
            <param name="sticky">
            A value indicating whether to set this instance as <see cref="P:System.Threading.SynchronizationContext.Current" /> when invoking delegates.
            This has the effect that async methods that are invoked on this <see cref="T:System.Threading.SynchronizationContext" />
            will execute their continuations on this <see cref="T:System.Threading.SynchronizationContext" /> as well unless they use <see cref="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" /> with <c>false</c> as the argument.
            </param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.NonConcurrentSynchronizationContext.#ctor(Microsoft.VisualStudio.Threading.NonConcurrentSynchronizationContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.NonConcurrentSynchronizationContext" /> class
            that is a copy of an existing instance.
            </summary>
            <param name="copyFrom">The instance to copy from.</param>
        </member>
        <member name="E:Microsoft.VisualStudio.Threading.NonConcurrentSynchronizationContext.UnhandledException">
            <summary>
            Occurs when posted work throws an unhandled exception.
            </summary>
            <remarks>
            Any exception thrown from this handler will crash the process.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.NonConcurrentSynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.NonConcurrentSynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.NonConcurrentSynchronizationContext.CreateCopy">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.NonConcurrentSynchronizationContext.ProcessQueueAsync">
            <summary>
            Executes queued work on the threadpool, one at a time.
            </summary>
            <returns>A task that always completes successfully.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.NullableHelpers.AsNullableArgAction``1(System.Action{``0})">
            <summary>
            Converts a delegate which assumes an argument that is never null into a delegate which might be given a null value,
            without adding an explicit null check.
            </summary>
            <typeparam name="T">The type of argument to be passed to the delegate.</typeparam>
            <param name="action">The delegate which, according to the signature, does not expect <see langword="null" />.</param>
            <returns>The exact same referenced delegate, but with a signature that may expect <see langword="null" />.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.NullableHelpers.AsNullableArgFunc``2(System.Func{``0,``1})">
            <summary>
            Converts a delegate which assumes an argument that is never null into a delegate which might be given a null value,
            without adding an explicit null check.
            </summary>
            <typeparam name="TArg">The type of argument to be passed to the delegate.</typeparam>
            <typeparam name="TReturn">The type of value returned from the delegate.</typeparam>
            <param name="func">The delegate which, according to the signature, does not expect <see langword="null" />.</param>
            <returns>The exact same referenced delegate, but with a signature that may expect <see langword="null" />.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1">
            <summary>
            An incremental progress reporting mechanism that also allows
            asynchronous awaiting for all reports to be processed.
            </summary>
            <typeparam name="T">The type of message sent in progress updates.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.syncObject">
            <summary>
            The synchronization object.
            Applicable only when <see cref="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.joinableTaskFactory" /> is null.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.handler">
            <summary>
            The handler to invoke for each progress update.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.outstandingTasks">
            <summary>
            The set of progress reports that have started (but may not have finished yet).
            Applicable only when <see cref="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.joinableTaskFactory" /> is null.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.taskFactory">
            <summary>
            The factory to use for invoking the <see cref="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.handler" />.
            Applicable only when <see cref="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.joinableTaskFactory" /> is null.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.createdOnMainThread">
            <summary>
            A value indicating whether this instance was constructed on the main thread.
            Applicable only when <see cref="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.joinableTaskFactory" /> is not null.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.joinableTaskFactory">
            <summary>
            The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory" /> to use when invoking the <see cref="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.handler" /> to mitigate deadlocks.
            May be null.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.outstandingJoinableTasks">
            <summary>
            A collection of outstanding progress updates that have not completed execution.
            Applicable only when <see cref="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.joinableTaskFactory" /> is not null.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.#ctor(System.Action{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1" /> class.
            </summary>
            <param name="handler">
            A handler to invoke for each reported progress value.
            Depending on the <see cref="T:System.Threading.SynchronizationContext" /> instance that is captured when this constructor is invoked,
            it is possible that this handler instance could be invoked concurrently with itself.
            </param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.#ctor(System.Func{`0,System.Threading.Tasks.Task})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1" /> class.
            </summary>
            <param name="handler">
            A handler to invoke for each reported progress value.
            Depending on the <see cref="T:System.Threading.SynchronizationContext" /> instance that is captured when this constructor is invoked,
            it is possible that this handler instance could be invoked concurrently with itself.
            </param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.#ctor(System.Action{`0},Microsoft.VisualStudio.Threading.JoinableTaskFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1" /> class.
            </summary>
            <param name="handler">
            A handler to invoke for each reported progress value.
            It is possible that this handler instance could be invoked concurrently with itself.
            </param>
            <param name="joinableTaskFactory">A <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory" /> instance that can be used to mitigate deadlocks when <see cref="M:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.WaitAsync(System.Threading.CancellationToken)" /> is called and the <paramref name="handler" /> requires the main thread.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.#ctor(System.Func{`0,System.Threading.Tasks.Task},Microsoft.VisualStudio.Threading.JoinableTaskFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1" /> class.
            </summary>
            <param name="handler">
            A handler to invoke for each reported progress value.
            It is possible that this handler instance could be invoked concurrently with itself.
            </param>
            <param name="joinableTaskFactory">A <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory" /> instance that can be used to mitigate deadlocks when <see cref="M:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.WaitAsync(System.Threading.CancellationToken)" /> is called and the <paramref name="handler" /> requires the main thread.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.System#IProgress{T}#Report(`0)">
            <summary>
            Receives a progress update.
            </summary>
            <param name="value">The value representing the updated progress.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.WaitAsync">
            <summary>
            Returns a task that completes when all reported progress has executed.
            </summary>
            <returns>A task that completes when all progress is complete.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.WaitAsync(System.Threading.CancellationToken)">
            <summary>
            Returns a task that completes when all reported progress has executed.
            </summary>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>A task that completes when all progress is complete.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.Report(`0)">
            <summary>
            Receives a progress update.
            </summary>
            <param name="value">The value representing the updated progress.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore">
            <summary>
            A <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory" />-aware semaphore that allows reentrancy without consuming another slot in the semaphore.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.joinableTaskFactory">
            <summary>
            The factory to wrap all pending and active semaphore requests with to mitigate deadlocks.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.joinableTaskCollection">
            <summary>
            The collection of all semaphore holders (and possibly waiters), which waiters should join to mitigate deadlocks.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.semaphore">
            <summary>
            The underlying semaphore primitive.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.#ctor(System.Int32,Microsoft.VisualStudio.Threading.JoinableTaskContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore" /> class.
            </summary>
            <param name="initialCount">The initial number of concurrent operations to allow.</param>
            <param name="joinableTaskContext">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> to use to mitigate deadlocks.</param>
            <devremarks>
            This is private protected so that others cannot derive from this type but we can within the assembly.
            </devremarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore.ReentrancyMode">
            <summary>
            Describes ways the <see cref="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore" /> may behave when a semaphore request is made in a context that is already in the semaphore.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.ReentrancyMode.NotAllowed">
            <summary>
            Reject all requests when the caller has already entered the semaphore
            (and not yet exited) by throwing an <see cref="T:System.InvalidOperationException" />.
            </summary>
            <remarks>
            When reentrancy is not expected this is the recommended mode as it will prevent deadlocks
            when unexpected reentrancy is detected.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.ReentrancyMode.NotRecognized">
            <summary>
            Each request occupies a unique slot in the semaphore.
            Reentrancy is not recognized and may lead to deadlocks if the reentrancy level exceeds the count on the semaphore.
            This resembles the behavior of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncSemaphore" /> class.
            </summary>
            <remarks>
            If reentrancy is not in the design, but <see cref="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.ReentrancyMode.NotAllowed" /> leads to exceptions due to
            ExecutionContext flowing unexpectedly, this mode may be the best option.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.ReentrancyMode.Stack">
            <summary>
            A request made by a caller that is already in the semaphore is immediately executed,
            and shares the same semaphore slot with its parent.
            This nested request must exit before its parent (Strict LIFO/stack behavior).
            Exiting the semaphore before a child has or after the parent has will cause an
            <see cref="T:System.InvalidOperationException" /> to fault the <see cref="T:System.Threading.Tasks.Task" /> returned
            from <see cref="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.ExecuteAsync(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />.
            </summary>
            <remarks>
            When reentrancy is a requirement, this mode helps ensure that reentrancy only happens
            where code enters a semaphore, then awaits on other code that itself may enter the semaphore.
            When a violation occurs, this semaphore transitions into a faulted state, after which any call
            will throw an <see cref="T:System.InvalidOperationException" />.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.ReentrancyMode.Freeform">
            <summary>
            A request made by a caller that is already in the semaphore is immediately executed,
            and shares the same semaphore slot with its parent.
            The slot is only released when all requests have exited, which may be in any order.
            </summary>
            <remarks>
            This is the most permissive, but has the highest risk that leaked semaphore access will remain undetected.
            Leaked semaphore access is a condition where code is inappropriately considered parented to another semaphore holder,
            leading to it being allowed to run code within the semaphore, potentially in parallel with the actual semaphore holder.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.ReentrantSemaphore.CurrentCount">
            <summary>
            Gets the number of openings that remain in the semaphore.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.Create(System.Int32,Microsoft.VisualStudio.Threading.JoinableTaskContext,Microsoft.VisualStudio.Threading.ReentrantSemaphore.ReentrancyMode)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore" /> class.
            </summary>
            <param name="initialCount">The initial number of concurrent operations to allow.</param>
            <param name="joinableTaskContext">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> to use to mitigate deadlocks.</param>
            <param name="mode">How to respond to a semaphore request by a caller that has already entered the semaphore.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.ExecuteAsync(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Executes a given operation within the semaphore.
            </summary>
            <param name="operation">
            The delegate to invoke once the semaphore is entered. If a <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> was supplied to the constructor,
            this delegate will execute on the main thread if this is invoked on the main thread, otherwise it will be invoked on the
            threadpool. When no <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> is supplied to the constructor, this delegate will execute on the
            caller's context.
            </param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>A task that completes with the result of <paramref name="operation" />, after the semaphore has been exited.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.ExecuteAsync``1(System.Func{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)">
            <summary>
            Executes a given operation within the semaphore.
            </summary>
            <typeparam name="T">The type of value returned by the operation.</typeparam>
            <param name="operation">
            The delegate to invoke once the semaphore is entered. If a <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> was supplied to the constructor,
            this delegate will execute on the main thread if this is invoked on the main thread, otherwise it will be invoked on the
            threadpool. When no <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> is supplied to the constructor, this delegate will execute on the
            caller's context.
            </param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>A task that completes with the result of <paramref name="operation" />, after the semaphore has been exited.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.SuppressRelevance">
            <summary>
            Conceals evidence that the caller has entered this <see cref="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore" /> till its result is disposed.
            </summary>
            <returns>A value to dispose to restore visibility of any presence in this semaphore.</returns>
            <remarks>
            <para>This method is useful when the caller is about to spin off another operation (e.g. scheduling work to the threadpool)
            that it does not consider vital to its own completion, in order to prevent the spun off work from abusing the
            caller's right to the semaphore.</para>
            <para>This is a safe call to make whether or not the semaphore is currently held, or whether reentrancy is allowed on this instance.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.Dispose">
            <summary>
            Faults all pending semaphore waiters with <see cref="T:System.ObjectDisposedException" />
            and rejects all subsequent attempts to enter the semaphore with the same exception.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.Dispose(System.Boolean)">
            <summary>
            Disposes managed and unmanaged resources held by this instance.
            </summary>
            <param name="disposing"><c>true</c> if <see cref="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.Dispose" /> was called; <c>false</c> if the object is being finalized.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.ThrowIfFaulted">
            <summary>
            Throws an exception if this instance has been faulted.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.DisposeReleaserNoThrow(Microsoft.VisualStudio.Threading.AsyncSemaphore.Releaser)">
            <summary>
            Disposes the specfied release, swallowing certain exceptions.
            </summary>
            <param name="releaser">The releaser to dispose.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.IsJoinableTaskAware(Microsoft.VisualStudio.Threading.JoinableTaskFactory@,Microsoft.VisualStudio.Threading.JoinableTaskCollection@)">
            <summary>
            Gets a value indicating whether this instance is using Joinable Task aware or not.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.ExecuteCoreAsync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Executes the semaphore request.
            </summary>
            <param name="semaphoreUser">The delegate that requests the semaphore and executes code within it.</param>
            <returns>A value for the caller to await on.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.ExecuteCoreAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Executes the semaphore request.
            </summary>
            <param name="semaphoreUser">The delegate that requests the semaphore and executes code within it.</param>
            <returns>A value for the caller to await on.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore.RevertRelevance">
            <summary>
            A structure that hides any evidence that the caller has entered a <see cref="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore" /> till this value is disposed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.RevertRelevance.disposeAction">
            <summary>
            The delegate to invoke on disposal.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.RevertRelevance.semaphore">
            <summary>
            The instance that is suppressing relevance.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.RevertRelevance.state">
            <summary>
            The argument to pass to the delegate.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.RevertRelevance.#ctor(System.Action{Microsoft.VisualStudio.Threading.ReentrantSemaphore,System.Object},Microsoft.VisualStudio.Threading.ReentrantSemaphore,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore.RevertRelevance" /> struct.
            </summary>
            <param name="disposeAction">The delegate to invoke on disposal.</param>
            <param name="semaphore">The instance that is suppressing relevance.</param>
            <param name="state">The argument to pass to the delegate.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.RevertRelevance.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore.NotRecognizedSemaphore">
            <summary>
            An implementation of <see cref="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore" /> supporting the <see cref="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.ReentrancyMode.NotRecognized" /> mode.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.NotRecognizedSemaphore.#ctor(System.Int32,Microsoft.VisualStudio.Threading.JoinableTaskContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore.NotRecognizedSemaphore" /> class.
            </summary>
            <param name="initialCount">The initial number of concurrent operations to allow.</param>
            <param name="joinableTaskContext">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> to use to mitigate deadlocks.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.NotRecognizedSemaphore.ExecuteAsync(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.NotRecognizedSemaphore.ExecuteAsync``1(System.Func{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore.NotAllowedSemaphore">
            <summary>
            An implementation of <see cref="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore" /> supporting the <see cref="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.ReentrancyMode.NotAllowed" /> mode.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.NotAllowedSemaphore.reentrancyDetection">
            <summary>
            The means to recognize that a caller has already entered the semaphore.
            </summary>
            <devremarks>
            We use <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> instead of just <see cref="T:System.Boolean" /> here for two reasons:
            1. Our own <see cref="T:Microsoft.VisualStudio.Threading.AsyncLocal`1" /> class requires a ref type for the generic type argument.
            2. (more importantly) we need all forks of an ExecutionContext to observe updates to the value.
               But ExecutionContext is copy-on-write so forks don't see changes to it.
               <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> lets us store and later update the boxed value of the existing box reference.
            </devremarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.NotAllowedSemaphore.#ctor(System.Int32,Microsoft.VisualStudio.Threading.JoinableTaskContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore.NotAllowedSemaphore" /> class.
            </summary>
            <param name="initialCount">The initial number of concurrent operations to allow.</param>
            <param name="joinableTaskContext">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> to use to mitigate deadlocks.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.NotAllowedSemaphore.ExecuteAsync(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.NotAllowedSemaphore.ExecuteAsync``1(System.Func{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.NotAllowedSemaphore.SuppressRelevance">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore.StackSemaphore">
            <summary>
            An implementation of <see cref="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore" /> supporting the <see cref="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.ReentrancyMode.Stack" /> mode.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.StackSemaphore.reentrantCount">
            <summary>
            The means to recognize that a caller has already entered the semaphore.
            </summary>
            <devremarks>
            We use <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> instead of just <see cref="T:Microsoft.VisualStudio.Threading.AsyncSemaphore.Releaser" /> here
            so that we have a unique identity for each Releaser that we can recognize as a means to verify
            the integrity of the "stack" of semaphore reentrant requests.
            </devremarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.StackSemaphore.faulted">
            <summary>
            A flag to indicate this instance was misused and the data it protects should not be touched as it may be corrupted.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.StackSemaphore.#ctor(System.Int32,Microsoft.VisualStudio.Threading.JoinableTaskContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore.StackSemaphore" /> class.
            </summary>
            <param name="initialCount">The initial number of concurrent operations to allow.</param>
            <param name="joinableTaskContext">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> to use to mitigate deadlocks.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.StackSemaphore.ExecuteAsync(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.StackSemaphore.ExecuteAsync``1(System.Func{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.StackSemaphore.SuppressRelevance">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.StackSemaphore.ThrowIfFaulted">
            <summary>
            Throws an exception if this instance has been faulted.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore.FreeformSemaphore">
            <summary>
            An implementation of <see cref="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore" /> supporting the <see cref="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.ReentrancyMode.Freeform" /> mode.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ReentrantSemaphore.FreeformSemaphore.reentrantCount">
            <summary>
            The means to recognize that a caller has already entered the semaphore.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.FreeformSemaphore.#ctor(System.Int32,Microsoft.VisualStudio.Threading.JoinableTaskContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.ReentrantSemaphore.FreeformSemaphore" /> class.
            </summary>
            <param name="initialCount">The initial number of concurrent operations to allow.</param>
            <param name="joinableTaskContext">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext" /> to use to mitigate deadlocks.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.FreeformSemaphore.ExecuteAsync(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.FreeformSemaphore.ExecuteAsync``1(System.Func{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ReentrantSemaphore.FreeformSemaphore.SuppressRelevance">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.RegistryChangeNotificationFilters">
            <summary>
            The various types of data within a registry key that generate notifications
            when changed.
            </summary>
            <remarks>
            This enum matches the Win32 REG_NOTIFY_CHANGE_* constants.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.RegistryChangeNotificationFilters.Subkey">
            <summary>
            Notify the caller if a subkey is added or deleted.
            Corresponds to Win32 value REG_NOTIFY_CHANGE_NAME.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.RegistryChangeNotificationFilters.Attributes">
            <summary>
            Notify the caller of changes to the attributes of the key,
            such as the security descriptor information.
            Corresponds to Win32 value REG_NOTIFY_CHANGE_ATTRIBUTES.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.RegistryChangeNotificationFilters.Value">
            <summary>
            Notify the caller of changes to a value of the key. This can
            include adding or deleting a value, or changing an existing value.
            Corresponds to Win32 value REG_NOTIFY_CHANGE_LAST_SET.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.RegistryChangeNotificationFilters.Security">
            <summary>
            Notify the caller of changes to the security descriptor of the key.
            Corresponds to Win32 value REG_NOTIFY_CHANGE_SECURITY.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext">
            <summary>
            A single-threaded synchronization context, akin to the DispatcherSynchronizationContext
            and WindowsFormsSynchronizationContext.
            </summary>
            <remarks>
            This must be created on the thread that will serve as the pumping thread.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.messageQueue">
            <summary>
            The list of posted messages to be executed. Must be locked for all access.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.ownedThreadId">
            <summary>
            The managed thread ID of the thread this instance owns.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext" /> class,
            with the new instance affinitized to the current thread.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.#ctor(Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext" /> class,
            as an equivalent copy to another instance.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.CreateCopy">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.PushFrame(Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.Frame)">
            <summary>
            Pushes a message pump on the current thread that will execute work scheduled using <see cref="M:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)" />.
            </summary>
            <param name="frame">The frame to represent this message pump, which controls when the message pump ends.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.Frame">
            <summary>
            A message pumping frame that may be pushed with <see cref="M:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.PushFrame(Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.Frame)" /> to pump messages
            on the owning thread.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.Frame.owner">
            <summary>
            The owning sync context.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.Frame.continue">
            <summary>
            Backing field for the <see cref="P:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.Frame.Continue" /> property.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.Frame.Continue">
            <summary>
            Gets or sets a value indicating whether a call to <see cref="M:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.PushFrame(Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.Frame)" /> with this <see cref="T:Microsoft.VisualStudio.Threading.SingleThreadedSynchronizationContext.Frame" />
            should continue pumping messages or should return to its caller.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.SpecializedSyncContext">
            <summary>
            A structure that applies and reverts changes to the <see cref="T:System.Threading.SynchronizationContext" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.SpecializedSyncContext.initialized">
            <summary>
            A flag indicating whether the non-default constructor was invoked.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.SpecializedSyncContext.prior">
            <summary>
            The SynchronizationContext to restore when <see cref="M:Microsoft.VisualStudio.Threading.SpecializedSyncContext.Dispose" /> is invoked.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.SpecializedSyncContext.appliedContext">
            <summary>
            The SynchronizationContext applied when this struct was constructed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.SpecializedSyncContext.checkForChangesOnRevert">
            <summary>
            A value indicating whether to check that the applied SyncContext is still the current one when the original is restored.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.SpecializedSyncContext.#ctor(System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.SpecializedSyncContext" /> struct.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.SpecializedSyncContext.Apply(System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Applies the specified <see cref="T:System.Threading.SynchronizationContext" /> to the caller's context.
            </summary>
            <param name="syncContext">The synchronization context to apply.</param>
            <param name="checkForChangesOnRevert">A value indicating whether to check that the applied SyncContext is still the current one when the original is restored.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.SpecializedSyncContext.Dispose">
            <summary>
            Reverts the SynchronizationContext to its previous instance.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.Strings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.AppliedSynchronizationContextNotAllowed">
            <summary>
              Looks up a localized string similar to Acquiring locks on threads with a SynchronizationContext applied is not allowed..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.CannotUpgradeNonUpgradeableLock">
            <summary>
              Looks up a localized string similar to A non-upgradeable read lock is held by the caller and cannot be upgraded..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.DangerousReadLockRequestFromWriteLockFork">
            <summary>
              Looks up a localized string similar to Dangerous request for read lock from fork of write lock..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.FrameMustBePushedFirst">
            <summary>
              Looks up a localized string similar to This instance must be pushed first..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.InvalidAfterCompleted">
            <summary>
              Looks up a localized string similar to Already transitioned to the Completed state..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.InvalidLock">
            <summary>
              Looks up a localized string similar to This operation can only be executed against a valid lock..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.InvalidWithoutLock">
            <summary>
              Looks up a localized string similar to A lock is required..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.JoinableTaskContextAndCollectionMismatch">
            <summary>
              Looks up a localized string similar to JoinableTask does not belong to the context this collection was instantiated with..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.JoinableTaskContextNodeAlreadyRegistered">
            <summary>
              Looks up a localized string similar to This node already registered..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.LazyValueFaulted">
            <summary>
              Looks up a localized string similar to Lazily created value faulted during construction..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.LazyValueNotCreated">
            <summary>
              Looks up a localized string similar to Lazily created value not yet constructed..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.LockCompletionAlreadyRequested">
            <summary>
              Looks up a localized string similar to This lock has already been marked for completion.  No new top-level locks can be serviced..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.MultipleContinuationsNotSupported">
            <summary>
              Looks up a localized string similar to Multiple continuations are not supported..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.NotAllowedUnderURorWLock">
            <summary>
              Looks up a localized string similar to This operation is not allowed while holding an active upgradeable read or write lock from an AsyncReaderWriterLock..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.PushFromWrongThread">
            <summary>
              Looks up a localized string similar to Message pump can only be run from the original thread..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.QueueEmpty">
            <summary>
              Looks up a localized string similar to The queue is empty..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.SemaphoreAlreadyHeld">
            <summary>
              Looks up a localized string similar to Semaphore is already held and reentrancy setting is '{0}'..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.SemaphoreMisused">
            <summary>
              Looks up a localized string similar to This semaphore has been misused and can no longer be used..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.SemaphoreStackNestingViolated">
            <summary>
              Looks up a localized string similar to Nested semaphore requests must be released in LIFO order when the reentrancy setting is: '{0}'.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.STAThreadCallerNotAllowed">
            <summary>
              Looks up a localized string similar to This operation cannot be completed on an STA thread..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.SwitchToMainThreadFailedToReachExpectedThread">
            <summary>
              Looks up a localized string similar to An attempt to switch to the main thread failed to reach the expected thread. Was the JoinableTaskContext initialized on the wrong thread or with a SynchronizationContext whose Post method does not execute its delegate on the main thread?.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.SyncContextFrameMismatchedAffinity">
            <summary>
              Looks up a localized string similar to This frame has already been used with a different instance..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.SyncContextNotSet">
            <summary>
              Looks up a localized string similar to No SynchronizationContext to reach the main thread has been set..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.ValueFactoryReentrancy">
            <summary>
              Looks up a localized string similar to The value factory has called for the value on the same instance..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.WriteLockOutlived">
            <summary>
              Looks up a localized string similar to Write lock out-lived by a nested read lock, which is not allowed..
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.TaskCompletionSourceWithoutInlining`1">
            <summary>
            A <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />-derivative that
            does not inline continuations if so configured.
            </summary>
            <typeparam name="T">The type of the task's resulting value.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TaskCompletionSourceWithoutInlining`1.exposedTask">
            <summary>
            The Task that we expose to others that may not inline continuations.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TaskCompletionSourceWithoutInlining`1.#ctor(System.Boolean,System.Threading.Tasks.TaskCreationOptions,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.TaskCompletionSourceWithoutInlining`1" /> class.
            </summary>
            <param name="allowInliningContinuations">
            <c>true</c> to allow continuations to be inlined; otherwise <c>false</c>.
            </param>
            <param name="options">
            TaskCreationOptions to pass on to the base constructor.
            </param>
            <param name="state">The state to set on the Task.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.TaskCompletionSourceWithoutInlining`1.Task">
            <summary>
            Gets the <see cref="P:Microsoft.VisualStudio.Threading.TaskCompletionSourceWithoutInlining`1.Task" /> that may never complete inline with completion of this <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.
            </summary>
            <devremarks>
            Return the base.Task if it is already completed since inlining continuations
            on the completer is no longer a concern. Also, when we are not inlining continuations,
            this.exposedTask completes slightly later than base.Task, and callers expect
            the Task we return to be complete as soon as they call TrySetResult.
            </devremarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TaskCompletionSourceWithoutInlining`1.AdjustFlags(System.Threading.Tasks.TaskCreationOptions,System.Boolean)">
            <summary>
            Modifies the specified flags to include RunContinuationsAsynchronously
            if wanted by the caller and supported by the platform.
            </summary>
            <param name="options">The base options supplied by the caller.</param>
            <param name="allowInliningContinuations"><c>true</c> to allow inlining continuations.</param>
            <returns>The possibly modified flags.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ThreadingEventSource">
            <summary>
            The ETW source for logging events for this library.
            </summary>
            <remarks>
            We use a fully-descriptive type name because the type name becomes the name
            of the ETW Provider.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ThreadingEventSource.Instance">
            <summary>
            The singleton instance used for logging.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ThreadingEventSource.ReaderWriterLockIssuedLockCountsEvent">
            <summary>
            The event ID for the <see cref="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.ReaderWriterLockIssued(System.Int32,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind,System.Int32,System.Int32)" /> event.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ThreadingEventSource.WaitReaderWriterLockStartEvent">
            <summary>
            The event ID for the <see cref="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.WaitReaderWriterLockStart(System.Int32,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind,System.Int32,System.Int32,System.Int32)" /> event.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ThreadingEventSource.WaitReaderWriterLockStopEvent">
            <summary>
            The event ID for the <see cref="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.WaitReaderWriterLockStop(System.Int32,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind)" /> event.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ThreadingEventSource.CompleteOnCurrentThreadStartEvent">
            <summary>
            The event ID for the <see cref="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.CompleteOnCurrentThreadStart(System.Int32,System.Boolean)" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ThreadingEventSource.CompleteOnCurrentThreadStopEvent">
            <summary>
            The event ID for the <see cref="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.CompleteOnCurrentThreadStop(System.Int32)" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ThreadingEventSource.WaitSynchronouslyStartEvent">
            <summary>
            The event ID for the <see cref="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.WaitSynchronouslyStart" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ThreadingEventSource.WaitSynchronouslyStopEvent">
            <summary>
            The event ID for the <see cref="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.WaitSynchronouslyStop" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ThreadingEventSource.PostExecutionStartEvent">
            <summary>
            The event ID for the <see cref="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.PostExecutionStart(System.Int32,System.Boolean)" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ThreadingEventSource.PostExecutionStopEvent">
            <summary>
            The event ID for the <see cref="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.PostExecutionStop(System.Int32)" />.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ThreadingEventSource.CircularJoinableTaskDependencyDetectedEvent">
            <summary>
            The event ID for the <see cref="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.CircularJoinableTaskDependencyDetected(System.Int32,System.Int32)" />.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.ReaderWriterLockIssued(System.Int32,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind,System.Int32,System.Int32)">
            <summary>
            Logs an issued lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.WaitReaderWriterLockStart(System.Int32,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind,System.Int32,System.Int32,System.Int32)">
            <summary>
            Logs a wait for a lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.WaitReaderWriterLockStop(System.Int32,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind)">
            <summary>
            Logs a lock that was issued after a contending lock was released.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.CompleteOnCurrentThreadStart(System.Int32,System.Boolean)">
            <summary>
            Enters a synchronously task.
            </summary>
            <param name="taskId">Hash code of the task.</param>
            <param name="isOnMainThread">Whether the task is on the main thread.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.CompleteOnCurrentThreadStop(System.Int32)">
            <summary>
            Exits a synchronously task.
            </summary>
            <param name="taskId">Hash code of the task.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.WaitSynchronouslyStart">
            <summary>
            The current thread starts to wait on execution requests.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.WaitSynchronouslyStop">
            <summary>
            The current thread gets an execution request.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.PostExecutionStart(System.Int32,System.Boolean)">
            <summary>
            Post a execution request to the queue.
            </summary>
            <param name="requestId">The request id.</param>
            <param name="mainThreadAffinitized">The execution need happen on the main thread.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.PostExecutionStop(System.Int32)">
            <summary>
            An execution request is processed.
            </summary>
            <param name="requestId">The request id.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingEventSource.CircularJoinableTaskDependencyDetected(System.Int32,System.Int32)">
            <summary>
            Circular JoinableTask dependency detected.
            </summary>
            <param name="initUnreachableCount">Initial count of unreachable nodes.</param>
            <param name="reachableCount">The size of the connected dependency graph.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ThreadingEventSource.Tasks">
            <summary>
            The names of constants in this class make up the middle term in
            the AsyncReaderWriterLock/LockRequest/Issued event name.
            </summary>
            <remarks>The name of this class is important for EventSource.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ThreadingEventSource.Opcodes">
            <summary>
            The names of constants in this class make up the last term in
            the AsyncReaderWriterLock/LockRequest/Issued event name.
            </summary>
            <remarks>The name of this class is important for EventSource.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ThreadingTools">
            <summary>
            Utility methods for working across threads.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.ApplyChangeOptimistically``1(``0@,System.Func{``0,``0})">
            <summary>
            Optimistically performs some value transformation based on some field and tries to apply it back to the field,
            retrying as many times as necessary until no other thread is manipulating the same field.
            </summary>
            <typeparam name="T">The type of data.</typeparam>
            <param name="hotLocation">The field that may be manipulated by multiple threads.</param>
            <param name="applyChange">A function that receives the unchanged value and returns the changed value.</param>
            <returns>
            <c>true</c> if the location's value is changed by applying the result of the <paramref name="applyChange" /> function;
            <c>false</c> if the location's value remained the same because the last invocation of <paramref name="applyChange" /> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.ApplyChangeOptimistically``2(``0@,``1,System.Func{``0,``1,``0})">
            <summary>
            Optimistically performs some value transformation based on some field and tries to apply it back to the field,
            retrying as many times as necessary until no other thread is manipulating the same field.
            </summary>
            <remarks>
            Use this overload when <paramref name="applyChange" /> requires a single item, as is common when updating immutable
            collection types. By passing the item as a method operand, the caller may be able to avoid allocating a closure
            object for every call.
            </remarks>
            <typeparam name="T">The type of data to apply the change to.</typeparam>
            <typeparam name="TArg">The type of argument passed to the <paramref name="applyChange" />.</typeparam>
            <param name="hotLocation">The field that may be manipulated by multiple threads.</param>
            <param name="applyChangeArgument">An argument to pass to <paramref name="applyChange" />.</param>
            <param name="applyChange">A function that receives both the unchanged value and <paramref name="applyChangeArgument" />, then returns the changed value.</param>
            <returns>
            <c>true</c> if the location's value is changed by applying the result of the <paramref name="applyChange" /> function;
            <c>false</c> if the location's value remained the same because the last invocation of <paramref name="applyChange" /> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.WithCancellation``1(System.Threading.Tasks.Task{``0},System.Threading.CancellationToken)">
            <summary>
            Wraps a task with one that will complete as cancelled based on a cancellation token,
            allowing someone to await a task but be able to break out early by cancelling the token.
            </summary>
            <typeparam name="T">The type of value returned by the task.</typeparam>
            <param name="task">The task to wrap.</param>
            <param name="cancellationToken">The token that can be canceled to break out of the await.</param>
            <returns>The wrapping task.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.WithCancellation(System.Threading.Tasks.Task,System.Threading.CancellationToken)">
            <summary>
            Wraps a task with one that will complete as cancelled based on a cancellation token,
            allowing someone to await a task but be able to break out early by cancelling the token.
            </summary>
            <param name="task">The task to wrap.</param>
            <param name="cancellationToken">The token that can be canceled to break out of the await.</param>
            <returns>The wrapping task.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.Apply(System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Applies the specified <see cref="T:System.Threading.SynchronizationContext" /> to the caller's context.
            </summary>
            <param name="syncContext">The synchronization context to apply.</param>
            <param name="checkForChangesOnRevert">A value indicating whether to check that the applied SyncContext is still the current one when the original is restored.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.WithCancellation(System.Threading.Tasks.Task,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Wraps a task with one that will complete as cancelled based on a cancellation token,
            allowing someone to await a task but be able to break out early by cancelling the token.
            </summary>
            <param name="task">The task to wrap.</param>
            <param name="continueOnCapturedContext">A value indicating whether *internal* continuations required to respond to cancellation should run on the current <see cref="T:System.Threading.SynchronizationContext" />.</param>
            <param name="cancellationToken">The token that can be canceled to break out of the await.</param>
            <returns>The wrapping task.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.AttachCancellation``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.CancellationToken,Microsoft.VisualStudio.Threading.ThreadingTools.ICancellationNotification)">
            <summary>
            Cancels a <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> if a given <see cref="T:System.Threading.CancellationToken" /> is canceled.
            </summary>
            <typeparam name="T">The type of value returned by a successfully completed <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
            <param name="taskCompletionSource">The <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> to cancel.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" />.</param>
            <param name="cancellationCallback">A callback to invoke when cancellation occurs.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.WithCancellationSlow``1(System.Threading.Tasks.Task{``0},System.Threading.CancellationToken)">
            <summary>
            Wraps a task with one that will complete as cancelled based on a cancellation token,
            allowing someone to await a task but be able to break out early by cancelling the token.
            </summary>
            <typeparam name="T">The type of value returned by the task.</typeparam>
            <param name="task">The task to wrap.</param>
            <param name="cancellationToken">The token that can be canceled to break out of the await.</param>
            <returns>The wrapping task.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.WithCancellationSlow(System.Threading.Tasks.Task,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Wraps a task with one that will complete as cancelled based on a cancellation token,
            allowing someone to await a task but be able to break out early by cancelling the token.
            </summary>
            <param name="task">The task to wrap.</param>
            <param name="continueOnCapturedContext">A value indicating whether *internal* continuations required to respond to cancellation should run on the current <see cref="T:System.Threading.SynchronizationContext" />.</param>
            <param name="cancellationToken">The token that can be canceled to break out of the await.</param>
            <returns>The wrapping task.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ThreadingTools.CancelableTaskCompletionSource`1">
            <summary>
            A state object for tracking cancellation and a TaskCompletionSource.
            </summary>
            <typeparam name="T">The type of value returned from a task.</typeparam>
            <remarks>
            We use this class so that we only allocate one object to support all continuations
            required for cancellation handling, rather than a special closure and delegate for each one.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ThreadingTools.CancelableTaskCompletionSource`1.ownerThreadId">
            <summary>
            The ID of the thread on which this instance was created.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.CancelableTaskCompletionSource`1.#ctor(System.Threading.Tasks.TaskCompletionSource{`0},Microsoft.VisualStudio.Threading.ThreadingTools.ICancellationNotification,System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.ThreadingTools.CancelableTaskCompletionSource`1" /> class.
            </summary>
            <param name="taskCompletionSource">The task completion source.</param>
            <param name="cancellationCallback">A callback to invoke when cancellation occurs.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.ThreadingTools.CancelableTaskCompletionSource`1.CancellationToken">
            <summary>
            Gets the cancellation token.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.ThreadingTools.CancelableTaskCompletionSource`1.TaskCompletionSource">
            <summary>
            Gets the Task completion source.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.ThreadingTools.CancelableTaskCompletionSource`1.CancellationTokenRegistration">
            <summary>
            Gets or sets the cancellation token registration.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.ThreadingTools.CancelableTaskCompletionSource`1.ContinuationScheduled">
            <summary>
            Gets or sets a value indicating whether the continuation has been scheduled (and not run inline).
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.ThreadingTools.CancelableTaskCompletionSource`1.OnOwnerThread">
            <summary>
            Gets a value indicating whether the caller is on the same thread as the one that created this instance.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.TplExtensions">
            <summary>
            Extensions to the Task Parallel Library.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.CompletedTask">
            <summary>
            A singleton completed task.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.CanceledTask">
            <summary>
            A task that is already canceled.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.TrueTask">
            <summary>
            A completed task with a <c>true</c> result.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.FalseTask">
            <summary>
            A completed task with a <c>false</c> result.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.WaitWithoutInlining(System.Threading.Tasks.Task)">
            <summary>
            Wait on a task without possibly inlining it to the current thread.
            </summary>
            <param name="task">The task to wait on.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.WithTimeout(System.Threading.Tasks.Task,System.TimeSpan)">
            <summary>
            Returns a task that completes as the original task completes or when a timeout expires,
            whichever happens first.
            </summary>
            <param name="task">The task to wait for.</param>
            <param name="timeout">The maximum time to wait.</param>
            <returns>
            A task that completes with the result of the specified <paramref name="task" /> or
            faults with a <see cref="T:System.TimeoutException" /> if <paramref name="timeout" /> elapses first.
            </returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.WithTimeout``1(System.Threading.Tasks.Task{``0},System.TimeSpan)">
            <summary>
            Returns a task that completes as the original task completes or when a timeout expires,
            whichever happens first.
            </summary>
            <typeparam name="T">The type of value returned by the original task.</typeparam>
            <param name="task">The task to wait for.</param>
            <param name="timeout">The maximum time to wait.</param>
            <returns>
            A task that completes with the result of the specified <paramref name="task" /> or
            faults with a <see cref="T:System.TimeoutException" /> if <paramref name="timeout" /> elapses first.
            </returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.ApplyResultTo``1(System.Threading.Tasks.Task{``0},System.Threading.Tasks.TaskCompletionSource{``0})">
            <summary>
            Applies one task's results to another.
            </summary>
            <typeparam name="T">The type of value returned by a task.</typeparam>
            <param name="task">The task whose completion should be applied to another.</param>
            <param name="tcs">The task that should receive the completion status.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.ApplyResultTo``1(System.Threading.Tasks.Task,System.Threading.Tasks.TaskCompletionSource{``0})">
            <summary>
            Applies one task's results to another.
            </summary>
            <typeparam name="T">The type of value returned by a task.</typeparam>
            <param name="task">The task whose completion should be applied to another.</param>
            <param name="tcs">The task that should receive the completion status.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.AttachToParent``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Creates a task that is attached to the parent task, but produces the same result as an existing task.
            </summary>
            <typeparam name="T">The type of value produced by the task.</typeparam>
            <param name="task">The task to wrap with an AttachedToParent task.</param>
            <returns>A task that is attached to parent.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.AttachToParent(System.Threading.Tasks.Task)">
            <summary>
            Creates a task that is attached to the parent task, but produces the same result as an existing task.
            </summary>
            <param name="task">The task to wrap with an AttachedToParent task.</param>
            <returns>A task that is attached to parent.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.AppendAction(System.Threading.Tasks.Task,System.Action,System.Threading.Tasks.TaskContinuationOptions,System.Threading.CancellationToken)">
            <summary>
            Schedules some action for execution at the conclusion of a task, regardless of the task's outcome.
            </summary>
            <param name="task">The task that should complete before the posted <paramref name="action" /> is invoked.</param>
            <param name="action">The action to execute after <paramref name="task" /> has completed.</param>
            <param name="options">The task continuation options to apply.</param>
            <param name="cancellation">The cancellation token that signals the continuation should not execute (if it has not already begun).</param>
            <returns>
            The task that will execute the action.
            </returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskToCompletion``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskCompletionSource{``0})">
            <summary>
            Gets a task that will eventually produce the result of another task, when that task finishes.
            If that task is instead canceled, its successor will be followed for its result, iteratively.
            </summary>
            <typeparam name="T">The type of value returned by the task.</typeparam>
            <param name="taskToFollow">The task whose result should be returned by the following task.</param>
            <param name="ultimateCancellation">A token whose cancellation signals that the following task should be cancelled.</param>
            <param name="taskThatFollows">The TaskCompletionSource whose task is to follow.  Leave at <c>null</c> for a new task to be created.</param>
            <returns>The following task.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowAwaitable(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Returns an awaitable for the specified task that will never throw, even if the source task
            faults or is canceled.
            </summary>
            <param name="task">The task whose completion should signal the completion of the returned awaitable.</param>
            <param name="captureContext">if set to <c>true</c> the continuation will be scheduled on the caller's context; <c>false</c> to always execute the continuation on the threadpool.</param>
            <returns>An awaitable.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.Forget(System.Threading.Tasks.Task)">
            <summary>
            Consumes a task and doesn't do anything with it.  Useful for fire-and-forget calls to async methods within async methods.
            </summary>
            <param name="task">The task whose result is to be ignored.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.Forget(System.Threading.Tasks.ValueTask)">
            <summary>
            Consumes a <see cref="T:System.Threading.Tasks.ValueTask" /> and allows it to be recycled, if applicable.  Useful for fire-and-forget calls to async methods within async methods.
            NOTE: APIs should not generally return <see cref="T:System.Threading.Tasks.ValueTask" /> if callers aren't 99.9999% likely to await the result immediately.
            </summary>
            <param name="task">The task whose result is to be ignored.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.Forget``1(System.Threading.Tasks.ValueTask{``0})">
            <summary>
            Consumes a ValueTask and allows it to be recycled, if applicable.  Useful for fire-and-forget calls to async methods within async methods.
            NOTE: APIs should not generally return <see cref="T:System.Threading.Tasks.ValueTask`1" /> if callers aren't 99.9999% likely to await the result immediately.
            </summary>
            <typeparam name="T">The type of value produced by the <paramref name="task" />.</typeparam>
            <param name="task">The task whose result is to be ignored.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.InvokeAsync(Microsoft.VisualStudio.Threading.AsyncEventHandler,System.Object,System.EventArgs)">
            <summary>
            Invokes asynchronous event handlers, returning a task that completes when all event handlers have been invoked.
            Each handler is fully executed (including continuations) before the next handler in the list is invoked.
            </summary>
            <param name="handlers">The event handlers.  May be <c>null</c>.</param>
            <param name="sender">The event source.</param>
            <param name="args">The event argument.</param>
            <returns>The task that completes when all handlers have completed.</returns>
            <exception cref="T:System.AggregateException">Thrown if any handlers fail. It contains a collection of all failures.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.InvokeAsync``1(Microsoft.VisualStudio.Threading.AsyncEventHandler{``0},System.Object,``0)">
            <summary>
            Invokes asynchronous event handlers, returning a task that completes when all event handlers have been invoked.
            Each handler is fully executed (including continuations) before the next handler in the list is invoked.
            </summary>
            <typeparam name="TEventArgs">The type of argument passed to each handler.</typeparam>
            <param name="handlers">The event handlers.  May be <c>null</c>.</param>
            <param name="sender">The event source.</param>
            <param name="args">The event argument.</param>
            <returns>The task that completes when all handlers have completed.  The task is faulted if any handlers throw an exception.</returns>
            <exception cref="T:System.AggregateException">Thrown if any handlers fail. It contains a collection of all failures.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.ToApm``1(System.Threading.Tasks.Task{``0},System.AsyncCallback,System.Object)">
            <summary>
            Converts a TPL task to the APM Begin-End pattern.
            </summary>
            <typeparam name="TResult">The result value to be returned from the End method.</typeparam>
            <param name="task">The task that came from the async method.</param>
            <param name="callback">The optional callback to invoke when the task is completed.</param>
            <param name="state">The state object provided by the caller of the Begin method.</param>
            <returns>A task (that implements <see cref="T:System.IAsyncResult" /> that should be returned from the Begin method.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.ToApm(System.Threading.Tasks.Task,System.AsyncCallback,System.Object)">
            <summary>
            Converts a TPL task to the APM Begin-End pattern.
            </summary>
            <param name="task">The task that came from the async method.</param>
            <param name="callback">The optional callback to invoke when the task is completed.</param>
            <param name="state">The state object provided by the caller of the Begin method.</param>
            <returns>A task (that implements <see cref="T:System.IAsyncResult" /> that should be returned from the Begin method.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.ToTask(System.Threading.WaitHandle,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Creates a TPL Task that returns <c>true</c> when a <see cref="T:System.Threading.WaitHandle" /> is signaled or returns <c>false</c> if a timeout occurs first.
            </summary>
            <param name="handle">The handle whose signal triggers the task to be completed.  Do not use a <see cref="T:System.Threading.Mutex" /> here.</param>
            <param name="timeout">The timeout (in milliseconds) after which the task will return <c>false</c> if the handle is not signaled by that time.</param>
            <param name="cancellationToken">A token whose cancellation will cause the returned Task to immediately complete in a canceled state.</param>
            <returns>
            A Task that completes when the handle is signaled or times out, or when the caller's cancellation token is canceled.
            If the task completes because the handle is signaled, the task's result is <c>true</c>.
            If the task completes because the handle is not signaled prior to the timeout, the task's result is <c>false</c>.
            </returns>
            <remarks>
            The completion of the returned task is asynchronous with respect to the code that actually signals the wait handle.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.ApplyResultTo``1(System.Threading.Tasks.Task{``0},System.Threading.Tasks.TaskCompletionSource{``0},System.Boolean)">
            <summary>
            Applies one task's results to another.
            </summary>
            <typeparam name="T">The type of value returned by a task.</typeparam>
            <param name="task">The task whose completion should be applied to another.</param>
            <param name="tcs">The task that should receive the completion status.</param>
            <param name="inlineSubsequentCompletion">
            <c>true</c> to complete the supplied <paramref name="tcs" /> as efficiently as possible (inline with the completion of <paramref name="task" />);
            <c>false</c> to complete the <paramref name="tcs" /> asynchronously.
            Note if <paramref name="task" /> is completed when this method is invoked, then <paramref name="tcs" /> is always completed synchronously.
            </param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.CanceledTaskOfT``1">
            <summary>
            Returns a reusable task that is already canceled.
            </summary>
            <typeparam name="T">The type parameter for the returned task.</typeparam>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.FaultedTask``1(System.Exception)">
            <summary>
            Returns a <see cref="T:System.Threading.Tasks.Task`1" /> that has been faulted with the specified exception.
            </summary>
            <typeparam name="T">The type of value that might have been returned from the <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
            <param name="ex">The exception used to fault the <see cref="T:System.Threading.Tasks.Task`1" />.</param>
            <returns>The faulted task.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.ApplyCompletedTaskResultTo``1(System.Threading.Tasks.Task{``0},System.Threading.Tasks.TaskCompletionSource{``0})">
            <summary>
            Applies a completed task's results to another.
            </summary>
            <typeparam name="T">The type of value returned by a task.</typeparam>
            <param name="completedTask">The task whose completion should be applied to another.</param>
            <param name="taskCompletionSource">The task that should receive the completion status.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.ApplyCompletedTaskResultTo``1(System.Threading.Tasks.Task,System.Threading.Tasks.TaskCompletionSource{``0},``0)">
            <summary>
            Applies a completed task's results to another.
            </summary>
            <typeparam name="T">The type of value returned by a task.</typeparam>
            <param name="completedTask">The task whose completion should be applied to another.</param>
            <param name="taskCompletionSource">The task that should receive the completion status.</param>
            <param name="valueOnRanToCompletion">The value to set on the completion source when the source task runs to completion.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskToCompletionHelper``1(Microsoft.VisualStudio.Threading.TplExtensions.TaskCompletionSource{Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState{``0},``0},System.Threading.Tasks.Task{``0})">
            <summary>
            Gets a task that will eventually produce the result of another task, when that task finishes.
            If that task is instead canceled, its successor will be followed for its result, iteratively.
            </summary>
            <typeparam name="T">The type of value returned by the task.</typeparam>
            <param name="tcs">The TaskCompletionSource whose task is to follow.</param>
            <param name="currentTask">The current task.</param>
            <returns>
            The following task.
            </returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaitable">
            <summary>
            An awaitable that wraps a task and never throws an exception when waited on.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaitable.task">
            <summary>
            The task.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaitable.captureContext">
            <summary>
            A value indicating whether the continuation should be scheduled on the current sync context.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaitable.#ctor(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaitable" /> struct.
            </summary>
            <param name="task">The task.</param>
            <param name="captureContext">Whether the continuation should be scheduled on the current sync context.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaitable.GetAwaiter">
            <summary>
            Gets the awaiter.
            </summary>
            <returns>The awaiter.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaiter">
            <summary>
            An awaiter that wraps a task and never throws an exception when waited on.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaiter.task">
            <summary>
            The task.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaiter.captureContext">
            <summary>
            A value indicating whether the continuation should be scheduled on the current sync context.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaiter.#ctor(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaiter" /> struct.
            </summary>
            <param name="task">The task.</param>
            <param name="captureContext">if set to <c>true</c> [capture context].</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaiter.IsCompleted">
            <summary>
            Gets a value indicating whether the task has completed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaiter.OnCompleted(System.Action)">
            <summary>
            Schedules a delegate for execution at the conclusion of a task's execution.
            </summary>
            <param name="continuation">The action.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>
            Schedules a delegate for execution at the conclusion of a task's execution
            without capturing the ExecutionContext.
            </summary>
            <param name="continuation">The action.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaiter.GetResult">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState`1">
            <summary>
            A state bag for the <see cref="M:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskToCompletion``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskCompletionSource{``0})" /> method.
            </summary>
            <typeparam name="T">The type of value ultimately returned.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState`1.getTaskToFollow">
            <summary>
            The delegate that returns the task to follow.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState`1.#ctor(System.Func{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState`1" /> struct.
            </summary>
            <param name="getTaskToFollow">The get task to follow.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState`1.#ctor(System.Func{System.Threading.Tasks.Task{`0}},System.Threading.CancellationTokenRegistration,System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState`1" /> struct.
            </summary>
            <param name="getTaskToFollow">The get task to follow.</param>
            <param name="registeredCallback">The cancellation token registration to dispose of when the task completes normally.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState`1.UltimateCancellation">
            <summary>
            Gets the ultimate cancellation token.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState`1.RegisteredCallback">
            <summary>
            Gets the cancellation token registration to dispose of when the task completes normally.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState`1.CurrentTask">
            <summary>
            Gets the current task to follow.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.TplExtensions.CanceledTaskOfTCache`1">
            <summary>
            A cache for canceled <see cref="T:System.Threading.Tasks.Task`1" /> instances.
            </summary>
            <typeparam name="T">The type parameter for the returned task.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.CanceledTaskOfTCache`1.CanceledTask">
            <summary>
            A task that is already canceled.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.TplExtensions.TaskCompletionSource`2">
            <summary>
            A task completion source that contains additional state.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.TaskCompletionSource`2.#ctor(`0,System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.TplExtensions.TaskCompletionSource`2" /> class.
            </summary>
            <param name="sourceState">The state to store in the <see cref="P:Microsoft.VisualStudio.Threading.TplExtensions.TaskCompletionSource`2.SourceState" /> property.</param>
            <param name="taskState">State of the task.</param>
            <param name="options">The options.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.TplExtensions.TaskCompletionSource`2.SourceState">
            <summary>
            Gets or sets the state passed into the constructor.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2">
            <summary>
            Dictionary that does not prevent keys from being garbage collected.
            </summary>
            <typeparam name="TKey">Type of key, without the WeakReference wrapper.</typeparam>
            <typeparam name="TValue">Type of value.</typeparam>
            <remarks>
            See also Microsoft.Build.Collections.WeakDictionary.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.dictionary">
            <summary>
            The dictionary used internally to store the keys and values.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.keyComparer">
            <summary>
            The key comparer to use for hashing and equality checks.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.capacity">
            <summary>
            The dictionary's initial capacity, and the capacity beyond which we will resist to grow
            by scavenging for collected keys first.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2" /> class.
            </summary>
            <param name="keyComparer">The key comparer to use. A <c>null</c> value indicates the default comparer will be used.</param>
            <param name="capacity">The initial capacity of the dictionary. Growth beyond this capacity will first induce a scavenge operation.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.Count">
            <summary>
            Gets the number of entries in this dictionary.
            Some entries may represent keys or values that have already been garbage collected.
            To clean these out call <see cref="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.Scavenge" />.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.Keys">
            <summary>
            Gets all key values in the dictionary.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.Item(`0)">
            <summary>
            Obtains the value for a given key.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.ContainsKey(`0)">
            <summary>
            Whether there is a key present with the specified key.
            </summary>
            <remarks>
            As usual, don't just call Contained as the wrapped value may be null.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value for the provided key.
            Returns true if the key is found, otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.Remove(`0)">
            <summary>
            Removes an entry with the specified key.
            Returns true if found, false otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.Scavenge">
            <summary>
            Remove any entries from the dictionary that represent keys
            that have been garbage collected.
            </summary>
            <returns>The number of entries removed.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.Clear">
            <summary>
            Empty the collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.GetEnumerator">
            <summary>
            See IEnumerable&lt;T&gt;.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey,TValue}}#GetEnumerator">
            <summary>
            See IEnumerable&lt;T&gt;.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            See IEnumerable.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.Any">
            <summary>
            Whether the collection contains any item.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1">
            <summary>
            Strongly typed wrapper around a weak reference that caches
            the target's hash code so that it can be used in a hashtable.
            </summary>
            <typeparam name="T">Type of the target of the weak reference.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1.hashcode">
            <summary>
            Cache the hashcode so that it is still available even if the target has been
            collected. This allows this object to be still found in a table so it can be removed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1.weakReference">
            <summary>
            Backing weak reference.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1.notSoWeakTarget">
            <summary>
            Some of the instances are around just to do existence checks, and don't want
            to allocate WeakReference objects as they are short-lived.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1.#ctor(`2,System.Collections.Generic.IEqualityComparer{`2},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1" /> struct.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1.Target">
            <summary>
            Gets the target wrapped by this weak reference.  Null if the target has already been garbage collected.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1.IsAlive">
            <summary>
            Gets a value indicating whether the target has not been garbage collected yet.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1.GetHashCode">
            <summary>
            Returns the hashcode of the wrapped target.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1.Equals(System.Object)">
            <summary>
            Compares two structures.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1.Equals(Microsoft.VisualStudio.Threading.WeakKeyDictionary{`0,`1}.WeakReference{`2})">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.KeyEnumerator">
            <summary>
            A helper structure to implement <see cref="T:System.Collections.Generic.IEnumerator`1" />.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.KeyEnumerator.Current">
            <summary>
            Gets the current item of the enumerator.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.KeyEnumerator.MoveNext">
            <summary>
            Implements <see cref="M:System.Collections.IEnumerator.MoveNext" />.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.KeyEnumerable">
            <summary>
            A helper structure to enumerate keys in the dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.KeyEnumerable.System#Collections#Generic#IEnumerable{TKey}#GetEnumerator">
            <summary>
            Implements <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.KeyEnumerable.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Implements <see cref="M:System.Collections.IEnumerable.GetEnumerator" />.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.KeyEnumerable.GetEnumerator">
            <summary>
            Gets the Enumerator.
            </summary>
            <returns>A new KeyEnumerator.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReferenceEqualityComparer`1">
            <summary>
            Equality comparer for weak references that actually compares the
            targets of the weak references.
            </summary>
            <typeparam name="T">Type of the targets of the weak references to be compared.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReferenceEqualityComparer`1.underlyingComparer">
            <summary>
            Comparer to use if specified, otherwise null.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReferenceEqualityComparer`1.#ctor(System.Collections.Generic.IEqualityComparer{`2})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReferenceEqualityComparer`1" /> class
            with an explicitly specified comparer.
            </summary>
            <param name="comparer">
            May be null, in which case the default comparer for the type will be used.
            </param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReferenceEqualityComparer`1.GetHashCode(Microsoft.VisualStudio.Threading.WeakKeyDictionary{`0,`1}.WeakReference{`2})">
            <summary>
            Gets the hashcode.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReferenceEqualityComparer`1.Equals(Microsoft.VisualStudio.Threading.WeakKeyDictionary{`0,`1}.WeakReference{`2},Microsoft.VisualStudio.Threading.WeakKeyDictionary{`0,`1}.WeakReference{`2})">
            <summary>
            Compares the weak references for equality.
            </summary>
        </member>
        <member name="M:System.Diagnostics.RoslynDebug.Assert(System.Boolean)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean)" />
        </member>
        <member name="M:System.Diagnostics.RoslynDebug.Assert(System.Boolean,System.String)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String)" />
        </member>
    </members>
<Signature xmlns="http://www.w3.org/2000/09/xmldsig#"><SignedInfo><CanonicalizationMethod Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" /><SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256" /><Reference URI=""><Transforms><Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature" /><Transform Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" /></Transforms><DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256" /><DigestValue>mjPIjCsaGQiOSiq4bvyBrvTp773E8L3mnupU2TbB3Co=</DigestValue></Reference></SignedInfo><SignatureValue>AWrkQK85cFcHH4Eqkf3B8fYdGEWOhvEuJlWK22mlZX5FeGsPY58Pkm6BJO4vrVWv9oiz/ZdzP4DS5QmLwqV/Do8pcXFuM3uDhpVYuRBQQKnbyI1Xl1lVbxyTKL9yNp4AjmOdEd+evZv/0sTTGEvrNXoi7IK5gHrhnvxsWDvyEhAeISE63X5WXCM8V2XHxo5uBv395TEpcGhbzEM5GRJQrvAUs0f1Riy5LnHq4Iq9bdHVrmCdSk+FEkMew/AhY7hElvxowLvK+EyoI0Ze2LxJVaJy+Saf7qO4qqYUL+JMtkDxNxcGr13kU/i3Y3jZ/0lZH/BBihPfItYz+8D0bb9c5A==</SignatureValue><KeyInfo><KeyValue><RSAKeyValue><Modulus>trsZWRAAo6nx5LhcqAsHy9uaHyPQ2VireMBI9yQUOPBj7dVLA7/N+AnKFFDzJ7P+grT6GkOE4cv5GzjoP8yQJ6yXojEKkXti7HW/zUiNoF11/ZWndf8j1Azl6OBjcD416tSWYvh2VfdW1K+mY83j49YPm3qbKnfxwtV0nI9H092gMS0cpCUsxMRAZlPXksrjsFLqvgq4rnULVhjHSVOudL/yps3zOOmOpaPzAp56b898xC+zzHVHcKo/52IRht1FSC8V+7QHTG8+yzfuljiKU9QONa8GqDlZ7/vFGveB8IY2ZrtUu98nle0WWTcaIRHoCYvWGLLF2u1GVFJAggPipw==</Modulus><Exponent>AQAB</Exponent></RSAKeyValue></KeyValue><X509Data><X509Certificate>MIIF/zCCA+egAwIBAgITMwAAAd9r8C6Sp0q00AAAAAAB3zANBgkqhkiG9w0BAQsFADB+MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSgwJgYDVQQDEx9NaWNyb3NvZnQgQ29kZSBTaWduaW5nIFBDQSAyMDExMB4XDTIwMTIxNTIxMzE0NVoXDTIxMTIwMjIxMzE0NVowdDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEeMBwGA1UEAxMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtrsZWRAAo6nx5LhcqAsHy9uaHyPQ2VireMBI9yQUOPBj7dVLA7/N+AnKFFDzJ7P+grT6GkOE4cv5GzjoP8yQJ6yXojEKkXti7HW/zUiNoF11/ZWndf8j1Azl6OBjcD416tSWYvh2VfdW1K+mY83j49YPm3qbKnfxwtV0nI9H092gMS0cpCUsxMRAZlPXksrjsFLqvgq4rnULVhjHSVOudL/yps3zOOmOpaPzAp56b898xC+zzHVHcKo/52IRht1FSC8V+7QHTG8+yzfuljiKU9QONa8GqDlZ7/vFGveB8IY2ZrtUu98nle0WWTcaIRHoCYvWGLLF2u1GVFJAggPipwIDAQABo4IBfjCCAXowHwYDVR0lBBgwFgYKKwYBBAGCN0wIAQYIKwYBBQUHAwMwHQYDVR0OBBYEFDj2zC/CHZDRrQnzJlT7byOlWfPjMFAGA1UdEQRJMEekRTBDMSkwJwYDVQQLEyBNaWNyb3NvZnQgT3BlcmF0aW9ucyBQdWVydG8gUmljbzEWMBQGA1UEBRMNMjMwMDEyKzQ2MzAwOTAfBgNVHSMEGDAWgBRIbmTlUAXTgqoXNzcitW2oynUClTBUBgNVHR8ETTBLMEmgR6BFhkNodHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vcGtpb3BzL2NybC9NaWNDb2RTaWdQQ0EyMDExXzIwMTEtMDctMDguY3JsMGEGCCsGAQUFBwEBBFUwUzBRBggrBgEFBQcwAoZFaHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3BraW9wcy9jZXJ0cy9NaWNDb2RTaWdQQ0EyMDExXzIwMTEtMDctMDguY3J0MAwGA1UdEwEB/wQCMAAwDQYJKoZIhvcNAQELBQADggIBAJ56h7Q8mFBWlQJLwCtHqqup4aC/eUmULt0Z6We7XUPPUEd/vuwPuIa6+1eMcZpAeQTm0tGCvjACxNNmrY8FoD3aWEOvFnSxq6CWR5G2XYBERvu7RExZd2iheCqaEmhjrJGV6Uz5wmjKNj16ADFTBqbEBELMIpmatyEN50UHwZSdD6DDHDf/j5LPGUy9QaD2LCaaJLenKpefaugsqWWCMIMifPdh6bbcmxyoNWbUC1JUl3HETJboD4BHDWSWoDxID2J4uG9dbJ40QIH9HckNMyPWi16k8VlFOaQiBYj09G9sLMc0agrchqqZBjPD/RmszvHmqJlSLQmAXCUgcgcf6UtHEmMAQRwGcSTg1KsUl6Ehg75k36lCV57Z1pC+KJKJNRYgg2eI6clzkLp2+noCF75IEO429rjtujsNJvEcJXg74TjK5x7LqYjj26Myq6EmuqWhbVUofPWm1EqKEfEHWXInppqBYXFpBMBYOLKc72DT+JyLNfd9utVsk2kTGaHHhrp+xgk9kZeud7lI/hfoPeHOtwIc0quJIXS+B5RSD9nj79vbJn1Jx7RqusmBQy509Kv2Pg4t48JaBfBFpJB0bUrl5RVG05sK/5Qw4G6WYioS0uwgUw499iNC+Yud9vrh3M8PNqGQ5mJmJiFEjG2ToEuuYe/e64+SSejpHhFCaAFc</X509Certificate><X509Certificate>MIIHejCCBWKgAwIBAgIKYQ6Q0gAAAAAAAzANBgkqhkiG9w0BAQsFADCBiDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEyMDAGA1UEAxMpTWljcm9zb2Z0IFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5IDIwMTEwHhcNMTEwNzA4MjA1OTA5WhcNMjYwNzA4MjEwOTA5WjB+MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSgwJgYDVQQDEx9NaWNyb3NvZnQgQ29kZSBTaWduaW5nIFBDQSAyMDExMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAq/D6chAcLq3YbqqCEE00uvK2WCGfQhsqa+laUKq4BjgaBEm6f8MMHt03a8YS2AvwOMKZBrDIOdUBFDFC04kNeWSHfpRgJGyvnkmc6Whe0t+bU7IKLMOv2akrrnoJr9eWWcpgGgXpZnboMlImEi/nqwhQz7NEt13YxC4Ddato88tt8zpcoRb0RrrgOGSsbmQ1eKagYw8t00CT+OPeBw3VXHmlSSnnDb6gE3e+lD3v++MrWhAfTVYoonpy4BI6t0le2O3tQ5GD2Xuye4Yb2T6xjF3oiU+EGvKhL1nkkDstrjNYxbc+/jLTswM9sbKvkjh+0p2ALPVOVpEhNSXDOW5kf1O6nA+tGSOEy/S6A4aN91/w0FK/jJSHvMAhdCVfGCi2zCcoOCWYOUo2z3yxkq4cI6epZuxhH2rhKEmdX4jiJV3TIUs+UsS1Vz8kA/DRelsv1SPjcF0PUUZ3s/gA4bysAoJf28AVs70b1FVL5zmhD+kjSbwYuER8ReTBw3J64HLnJN+/RpnF78IcV9uDjexNSTCnq47f7Fufr/zdsGbiwZeBe+3W7UvnSSmnEyimp31ngOaKYnhfsi+E11ecXL93KCjx7W3DKI8sj0A3T8HhhUSJxAlMxdSlQy90lfdu+HggWCwTXWCVmj5PM4TasIgX3p5O9JawvEagbJjS4NaIjAsCAwEAAaOCAe0wggHpMBAGCSsGAQQBgjcVAQQDAgEAMB0GA1UdDgQWBBRIbmTlUAXTgqoXNzcitW2oynUClTAZBgkrBgEEAYI3FAIEDB4KAFMAdQBiAEMAQTALBgNVHQ8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAfBgNVHSMEGDAWgBRyLToCMZBDuRQFTuHqp8cx0SOJNDBaBgNVHR8EUzBRME+gTaBLhklodHRwOi8vY3JsLm1pY3Jvc29mdC5jb20vcGtpL2NybC9wcm9kdWN0cy9NaWNSb29DZXJBdXQyMDExXzIwMTFfMDNfMjIuY3JsMF4GCCsGAQUFBwEBBFIwUDBOBggrBgEFBQcwAoZCaHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3BraS9jZXJ0cy9NaWNSb29DZXJBdXQyMDExXzIwMTFfMDNfMjIuY3J0MIGfBgNVHSAEgZcwgZQwgZEGCSsGAQQBgjcuAzCBgzA/BggrBgEFBQcCARYzaHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3BraW9wcy9kb2NzL3ByaW1hcnljcHMuaHRtMEAGCCsGAQUFBwICMDQeMiAdAEwAZQBnAGEAbABfAHAAbwBsAGkAYwB5AF8AcwB0AGEAdABlAG0AZQBuAHQALiAdMA0GCSqGSIb3DQEBCwUAA4ICAQBn8oalmOBUeRou09h0ZyKbC5YR4WOSmUKWfdJ5DJDBZV8uLD74w3LRbYP+vj/oCso7v0epo/Np22O/IjWll11lhJB9i0ZQVdgMknzSGksc8zxCi1LQsP1r4z4HLimb5j0bpdS1HXeUOeLpZMlEPXh6I/MTfaaQdION9MsmAkYqwooQu6SpBQyb7Wj6aC6VoCo/KmtYSWMfCWluWpiW5IP0wI/zRive/DvQvTXvbiWu5a8n7dDd8w6vmSiXmE0OPQvyCInWH8MyGOLwxS3OW560STkKxgrCxq2u5bLZ2xWIUUVYODJxJxp/sfQn+N4sOiBpmLJZiWhub6e3dMNABQamASooPoI/E01mC8CzTfXhj38cbxV9Rad25UAqZaPDXVJihsMdYzaXht/a8/jyFqGaJ+HNpZfQ7l1jQeNbB5yHPgZ3BtEGsXUfFL5hYbXw3MYbBL7fQccOKO7eZS/sl/ahXJbYANahRr1Z85elCUtIEJmAH9AAKcWxm6U/RXceNcbSoqKfenoi+kiVH6v7RyOA9Z74v2u3S5fi63V4GuzqN5l5GEv/1rMjaHXmr/r8i+sLgOppO6/8MO0ETI7f33VtY5E90Z1WTk+/gFcioXgRMiF670EKsT/7qMykXcGhiJtXcVZOSEXAQsmbdlsKgEhr/Xmfwb1tbWrJUnMTDXpQzQ==</X509Certificate><X509Certificate>MIIF7TCCA9WgAwIBAgIQP4vItfyfspZDtWnWbELhRDANBgkqhkiG9w0BAQsFADCBiDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEyMDAGA1UEAxMpTWljcm9zb2Z0IFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5IDIwMTEwHhcNMTEwMzIyMjIwNTI4WhcNMzYwMzIyMjIxMzA0WjCBiDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEyMDAGA1UEAxMpTWljcm9zb2Z0IFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5IDIwMTEwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCygEGqNThNE3IyaCJNuLLx/9VSvGzH9dJKjDbu0cJcfoyKrq8TKG/Ac+M6ztAlqFo6be+ouFmrEyNozQwph9FvgFyPRH9dkAFSWKxRxV8qh9zc2AodwQO5e7BW6KPeZGHCnvjzfLnsDbVU/ky2ZU+I8JxImQxCCwl8MVkXeQZ4KI2JOkwDJb5xalwL54RgpJki49KvhKSn+9GY7Qyp3pSJ4Q6g3MDOmT3qCFK7VnnkH4S6Hri0xElcTzFLh93dBWcmmYDgcRGjuKVB4qRTufcyKYMME782XgSzS0NHL2vikR7TmE/dQgfI6B0S/Jmpaz6SfsjWaTr8ZL22CZ3K/QwLopt3YEsDlKQwaRLWQi3BQUzK3Kr9j1uDRprZ/LHR47PJf0h6zSTwQY9cdNCssBAgBkm3xy0hyFfj0IbzA2j70M5xwYmZSmQBbP3sMJHPQTySx+W6hh1hhMdfgzlirrSSL0fzC/hV66AfWdC7dJse0Hbm8ukG1xDo+mTeacY1logC8Ea4PyeZb8txiSk190gWAjWP1Xl8TQLPX+uKg09FcYj5qQ1OcunCnAfPSRtOBA5jUYxe2ADBVSy2xuDCZU7JNDn1nLPEfuhhbhNfFcRf2X7tHc7uROzLLoax7Dj2cO2rXBPB2Q8Nx4CyVe0096yb5MPa50c8prWPMd/FS6/r8QIDAQABo1EwTzALBgNVHQ8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUci06AjGQQ7kUBU7h6qfHMdEjiTQwEAYJKwYBBAGCNxUBBAMCAQAwDQYJKoZIhvcNAQELBQADggIBAH9yzw+3xRXbm8BJyiZb/p4T5tPw0tuXX/JLP02zrhmu7deXoKzvqTqjwkGw5biRnhOBJAPmCf0/V0A5ISRW0RAvS0CpNoZLtFNXmvvxfomPEf4YbFGq6O0JlbXlccmh6Yd1phV/yX43VF50k8XDZ8wNT2uoFwxtCJJ+i92Bqi1wIcM9BhS7vyRep4TXPw8hIr1LAAbblxzYXtTFC1yHblCk6MM4pPvLLMWSZpuFXst6bJN8gClYW1e1QGm6CHmmZGIVnYeWRbVmIyADixxzoNOieTPgUFmG2y/lAiXqcyqfABTINseSO+lOAOzYVgm5M0kS0lQLAausR7aRKX1MtHWAUgHoyoL2n8ysnI8X6i8msKtyrAv+nlEex0NVZ09Rs1fWtuzuUrc66U7h14GIvE+OdbtLqPA1qibUZ2dJsnBMO5PcHd94kIZysjik0dySTclY6ysSXNQ7roxrsIPlAT/4CTL2kzU0Iq/dNw13CYArzUgA8YyZGUcFAenRv9FO0OYoQzeZpApKCNmacXPSqs0xE2N2oTdvkjgefRI8ZjLny23h/FKJ3crWZgWalmG+oijHHKOnNlA8OqTfSm7mhzvO6/DggTedEzxSjr25HTTGHdUKaj2YKXCMiSrRq4IQSB/c9O+lxbtVGjhjhE63bK2VVOxlIhBJF7jAHscPrFRH</X509Certificate></X509Data></KeyInfo><Object Id="ts-countersig"><X509Data><X509Certificate>MIIE9TCCA92gAwIBAgITMwAAAWH1ojNeoCokaQAAAAABYTANBgkqhkiG9w0BAQsFADB8MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSYwJAYDVQQDEx1NaWNyb3NvZnQgVGltZS1TdGFtcCBQQ0EgMjAxMDAeFw0yMTAxMTQxOTAyMjFaFw0yMjA0MTExOTAyMjFaMIHOMQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSkwJwYDVQQLEyBNaWNyb3NvZnQgT3BlcmF0aW9ucyBQdWVydG8gUmljbzEmMCQGA1UECxMdVGhhbGVzIFRTUyBFU046RDlERS1FMzlBLTQzRkUxJTAjBgNVBAMTHE1pY3Jvc29mdCBUaW1lLVN0YW1wIFNlcnZpY2UwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCXiJ2oQa1P/xs06ocVMgAvFF3LelCQpG9sRGSld4I4IJiwIXga8SZO7R/j8NrU3Mmqy0X5ldsaOaAZOaVvznA3P5/03E3kFOiSDeT5U3J9AvUZSkOrfTrlP1gMgMRk4yhOBDZ1I17cYjZQ/ytmRjC746UTgSoe07ZFCSumRlsP7k0WmzQcUYNd0745Bh1xFBAyfIpmnMPQQnkfS+rp3a99rY+HbjhSBw/JtXrN0jTffGauCAwT9wnG/h0IMaW3hyFJStMus5syJL3ze92ccHxrxb9PzGse/ViWNHA/KaAp2RYo3Ilq39Hg9U9v/ux4HsM63cT3UhaHJFEPEKLyAyGJAgMBAAGjggEbMIIBFzAdBgNVHQ4EFgQUVh6andYb+9UlY+SwHT3zROz4Sy8wHwYDVR0jBBgwFoAU1WM6XIoxkPNDe3xGG8UzaFqFbVUwVgYDVR0fBE8wTTBLoEmgR4ZFaHR0cDovL2NybC5taWNyb3NvZnQuY29tL3BraS9jcmwvcHJvZHVjdHMvTWljVGltU3RhUENBXzIwMTAtMDctMDEuY3JsMFoGCCsGAQUFBwEBBE4wTDBKBggrBgEFBQcwAoY+aHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3BraS9jZXJ0cy9NaWNUaW1TdGFQQ0FfMjAxMC0wNy0wMS5jcnQwDAYDVR0TAQH/BAIwADATBgNVHSUEDDAKBggrBgEFBQcDCDANBgkqhkiG9w0BAQsFAAOCAQEAEEwPW6lQZseU0zIc4/kPM1pD0F4AnEkIqstmGFhdIVq+RhIjdi7QPhFnbtcvKMrGWruAj+0szPFU0qt9QiyYjst/WeEbxKtpq9BH7Rb5l9gsUO2cs65IVjGWmUC5GGx+aGmyBcJ3Vt+J4ffNATmN/ebX5zUv2OjdH/o13aBZ+3yNnON0xWLFKiD1ozhyZaDHpLZQ+v7kumZ+MbHv5SLRZvn1jnAdgMclxAd2URHkoPY+/hqBJdcU/4iblf0qO05VncMmnELuJb9zAbL8c0SGyoWcKw2KIJqMifq8IEAfJikuPzNUg0bSKbWpqExSeek5Og7lF8dSbnU6HpYIxGT2uQ==</X509Certificate><X509Certificate>MIIGcTCCBFmgAwIBAgIKYQmBKgAAAAAAAjANBgkqhkiG9w0BAQsFADCBiDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEyMDAGA1UEAxMpTWljcm9zb2Z0IFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5IDIwMTAwHhcNMTAwNzAxMjEzNjU1WhcNMjUwNzAxMjE0NjU1WjB8MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSYwJAYDVQQDEx1NaWNyb3NvZnQgVGltZS1TdGFtcCBQQ0EgMjAxMDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKkdDbx3EYo6IOz8E5f1+n9plGt0VBDVpQoAgoX77XxoSyxfxcPlYcJ2tz5mK1vwFVMnBDEfQRsalR3OCROOfGEwWbEwRA/xYIiEVEMM1024OAizQt2TrNZzMFcmgqNFDdDq9UeBzb8kYDJYYEbyWEeGMoQedGFnkV+BVLHPk0ySwcSmXdFhE24oxhr5hoC732H8RsEnHSRnEnIaIYqvS2SJUGKxXf13Hz3wV3WsvYpCTUBR0Q+cBj5nf/VmwAOWRH7v0Ev9buWayrGo8noqCjHw2k4GkbaICDXoeByw6ZnNPOcvRLqn9NxkvaQBwSAJk3jN/LzAyURdXhacAQVPIk0CAwEAAaOCAeYwggHiMBAGCSsGAQQBgjcVAQQDAgEAMB0GA1UdDgQWBBTVYzpcijGQ80N7fEYbxTNoWoVtVTAZBgkrBgEEAYI3FAIEDB4KAFMAdQBiAEMAQTALBgNVHQ8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAfBgNVHSMEGDAWgBTV9lbLj+iiXGJo0T2UkFvXzpoYxDBWBgNVHR8ETzBNMEugSaBHhkVodHRwOi8vY3JsLm1pY3Jvc29mdC5jb20vcGtpL2NybC9wcm9kdWN0cy9NaWNSb29DZXJBdXRfMjAxMC0wNi0yMy5jcmwwWgYIKwYBBQUHAQEETjBMMEoGCCsGAQUFBzAChj5odHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vcGtpL2NlcnRzL01pY1Jvb0NlckF1dF8yMDEwLTA2LTIzLmNydDCBoAYDVR0gAQH/BIGVMIGSMIGPBgkrBgEEAYI3LgMwgYEwPQYIKwYBBQUHAgEWMWh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9QS0kvZG9jcy9DUFMvZGVmYXVsdC5odG0wQAYIKwYBBQUHAgIwNB4yIB0ATABlAGcAYQBsAF8AUABvAGwAaQBjAHkAXwBTAHQAYQB0AGUAbQBlAG4AdAAuIB0wDQYJKoZIhvcNAQELBQADggIBAAfmiFEN4sbgmD+BcQM9naOhIW+z66bM9TG+zwXiqf76V20ZMLPCxWbJat/15/B4vceoniXj+bzta1RXCCtRgkQS+7lTjMz0YBKKdsxAQEGb3FwX/1z5Xhc1mCRWS3TvQhDIr79/xn/yN31aPxzymXlKkVIArzgPF/UveYFl2am1a+THzvbKegBvSzBEJCI8z+0DpZaPWSm8tv0E4XCfMkon/VWvL/625Y4zu2JfmttXQOnxzplmkIz/amJ/3cVKC5Em4jnsGUpxY517IW3DnKOiPPp/fZZqkHimbdLhnPkd/DjYlPTGpQqWhqS9nhquBEKDuLWAmyI4ILUl5WTs9/S/fmNZJQ96LjlXdqJxqgaKD4kWumGnEcua2A5HmoDF0M2n0O99g/DhO3EJ3110mCIIYdqwUB5vvfHhAN/nMQekkzr3ZUd46PioSKv33nJ+YWtvd6mBy6cJrDm77MbL2IK0cs0d9LiFAR6A+xuJKlQ5slvayA1VmXqHczsI5pgt6o3gMy4SKfXAL1QnIffIrE7aKLixqduWsqdCosnPGUFN4Ib5KpqjEWYw07t0MkvfY3v1mYovG8chr1m1rtxEPJdQcdeh0sVV42neV8HR3jDA/czmTfsNv11P6Z0eGTgvvM9YBS7vDaBQNdrvCScc1bN+NR4Iuto229Nfj950iEkS</X509Certificate></X509Data><CounterSignature ts-format="cms-timestamp-message" xmlns="http://schemas.microsoft.com/xmldsig/timestamp/2003">MIAGCSqGSIb3DQEHAqCAMIISxgIBAzEPMA0GCWCGSAFlAwQCAQUAMIIBVQYLKoZIhvcNAQkQAQSgggFEBIIBQDCCATwCAQEGCisGAQQBhFkKAwEwMTANBglghkgBZQMEAgEFAAQgBj1m+3PAs3ELD3T1r8sxA9GXA2b5oPcqtOk0LKswoUwCBmBjLRA3oRgTMjAyMTA0MjIwMzEyMjcuOTkxWjAEgAIB9KCB1KSB0TCBzjELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEpMCcGA1UECxMgTWljcm9zb2Z0IE9wZXJhdGlvbnMgUHVlcnRvIFJpY28xJjAkBgNVBAsTHVRoYWxlcyBUU1MgRVNOOkQ5REUtRTM5QS00M0ZFMSUwIwYDVQQDExxNaWNyb3NvZnQgVGltZS1TdGFtcCBTZXJ2aWNloIIORDCCBPUwggPdoAMCAQICEzMAAAFh9aIzXqAqJGkAAAAAAWEwDQYJKoZIhvcNAQELBQAwfDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEmMCQGA1UEAxMdTWljcm9zb2Z0IFRpbWUtU3RhbXAgUENBIDIwMTAwHhcNMjEwMTE0MTkwMjIxWhcNMjIwNDExMTkwMjIxWjCBzjELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEpMCcGA1UECxMgTWljcm9zb2Z0IE9wZXJhdGlvbnMgUHVlcnRvIFJpY28xJjAkBgNVBAsTHVRoYWxlcyBUU1MgRVNOOkQ5REUtRTM5QS00M0ZFMSUwIwYDVQQDExxNaWNyb3NvZnQgVGltZS1TdGFtcCBTZXJ2aWNlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAl4idqEGtT/8bNOqHFTIALxRdy3pQkKRvbERkpXeCOCCYsCF4GvEmTu0f4/Da1NzJqstF+ZXbGjmgGTmlb85wNz+f9NxN5BTokg3k+VNyfQL1GUpDq3065T9YDIDEZOMoTgQ2dSNe3GI2UP8rZkYwu+OlE4EqHtO2RQkrpkZbD+5NFps0HFGDXdO+OQYdcRQQMnyKZpzD0EJ5H0vq6d2vfa2Ph244UgcPybV6zdI033xmrggME/cJxv4dCDGlt4chSUrTLrObMiS983vdnHB8a8W/T8xrHv1YljRwPymgKdkWKNyJat/R4PVPb/7seB7DOt3E91IWhyRRDxCi8gMhiQIDAQABo4IBGzCCARcwHQYDVR0OBBYEFFYemp3WG/vVJWPksB0980Ts+EsvMB8GA1UdIwQYMBaAFNVjOlyKMZDzQ3t8RhvFM2hahW1VMFYGA1UdHwRPME0wS6BJoEeGRWh0dHA6Ly9jcmwubWljcm9zb2Z0LmNvbS9wa2kvY3JsL3Byb2R1Y3RzL01pY1RpbVN0YVBDQV8yMDEwLTA3LTAxLmNybDBaBggrBgEFBQcBAQROMEwwSgYIKwYBBQUHMAKGPmh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9wa2kvY2VydHMvTWljVGltU3RhUENBXzIwMTAtMDctMDEuY3J0MAwGA1UdEwEB/wQCMAAwEwYDVR0lBAwwCgYIKwYBBQUHAwgwDQYJKoZIhvcNAQELBQADggEBABBMD1upUGbHlNMyHOP5DzNaQ9BeAJxJCKrLZhhYXSFavkYSI3Yu0D4RZ27XLyjKxlq7gI/tLMzxVNKrfUIsmI7Lf1nhG8SraavQR+0W+ZfYLFDtnLOuSFYxlplAuRhsfmhpsgXCd1bfieH3zQE5jf3m1+c1L9jo3R/6Nd2gWft8jZzjdMVixSog9aM4cmWgx6S2UPr+5LpmfjGx7+Ui0Wb59Y5wHYDHJcQHdlER5KD2Pv4agSXXFP+Im5X9KjtOVZ3DJpxC7iW/cwGy/HNEhsqFnCsNiiCajIn6vCBAHyYpLj8zVING0im1qahMUnnpOToO5RfHUm51Oh6WCMRk9rkwggZxMIIEWaADAgECAgphCYEqAAAAAAACMA0GCSqGSIb3DQEBCwUAMIGIMQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMTIwMAYDVQQDEylNaWNyb3NvZnQgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgMjAxMDAeFw0xMDA3MDEyMTM2NTVaFw0yNTA3MDEyMTQ2NTVaMHwxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29ycG9yYXRpb24xJjAkBgNVBAMTHU1pY3Jvc29mdCBUaW1lLVN0YW1wIFBDQSAyMDEwMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqR0NvHcRijog7PwTl/X6f2mUa3RUENWlCgCChfvtfGhLLF/Fw+Vhwna3PmYrW/AVUycEMR9BGxqVHc4JE458YTBZsTBED/FgiIRUQwzXTbg4CLNC3ZOs1nMwVyaCo0UN0Or1R4HNvyRgMlhgRvJYR4YyhB50YWeRX4FUsc+TTJLBxKZd0WETbijGGvmGgLvfYfxGwScdJGcSchohiq9LZIlQYrFd/XcfPfBXday9ikJNQFHRD5wGPmd/9WbAA5ZEfu/QS/1u5ZrKsajyeioKMfDaTgaRtogINeh4HLDpmc085y9Euqf03GS9pAHBIAmTeM38vMDJRF1eFpwBBU8iTQIDAQABo4IB5jCCAeIwEAYJKwYBBAGCNxUBBAMCAQAwHQYDVR0OBBYEFNVjOlyKMZDzQ3t8RhvFM2hahW1VMBkGCSsGAQQBgjcUAgQMHgoAUwB1AGIAQwBBMAsGA1UdDwQEAwIBhjAPBgNVHRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFNX2VsuP6KJcYmjRPZSQW9fOmhjEMFYGA1UdHwRPME0wS6BJoEeGRWh0dHA6Ly9jcmwubWljcm9zb2Z0LmNvbS9wa2kvY3JsL3Byb2R1Y3RzL01pY1Jvb0NlckF1dF8yMDEwLTA2LTIzLmNybDBaBggrBgEFBQcBAQROMEwwSgYIKwYBBQUHMAKGPmh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9wa2kvY2VydHMvTWljUm9vQ2VyQXV0XzIwMTAtMDYtMjMuY3J0MIGgBgNVHSABAf8EgZUwgZIwgY8GCSsGAQQBgjcuAzCBgTA9BggrBgEFBQcCARYxaHR0cDovL3d3dy5taWNyb3NvZnQuY29tL1BLSS9kb2NzL0NQUy9kZWZhdWx0Lmh0bTBABggrBgEFBQcCAjA0HjIgHQBMAGUAZwBhAGwAXwBQAG8AbABpAGMAeQBfAFMAdABhAHQAZQBtAGUAbgB0AC4gHTANBgkqhkiG9w0BAQsFAAOCAgEAB+aIUQ3ixuCYP4FxAz2do6Ehb7Prpsz1Mb7PBeKp/vpXbRkws8LFZslq3/Xn8Hi9x6ieJeP5vO1rVFcIK1GCRBL7uVOMzPRgEop2zEBAQZvcXBf/XPleFzWYJFZLdO9CEMivv3/Gf/I3fVo/HPKZeUqRUgCvOA8X9S95gWXZqbVr5MfO9sp6AG9LMEQkIjzP7QOllo9ZKby2/QThcJ8ySif9Va8v/rbljjO7Yl+a21dA6fHOmWaQjP9qYn/dxUoLkSbiOewZSnFjnXshbcOco6I8+n99lmqQeKZt0uGc+R38ONiU9MalCpaGpL2eGq4EQoO4tYCbIjggtSXlZOz39L9+Y1klD3ouOVd2onGqBooPiRa6YacRy5rYDkeagMXQzafQ732D8OE7cQnfXXSYIghh2rBQHm+98eEA3+cxB6STOvdlR3jo+KhIq/fecn5ha293qYHLpwmsObvsxsvYgrRyzR30uIUBHoD7G4kqVDmyW9rIDVWZeodzOwjmmC3qjeAzLhIp9cAvVCch98isTtoouLGp25ayp0Kiyc8ZQU3ghvkqmqMRZjDTu3QyS99je/WZii8bxyGvWbWu3EQ8l1Bx16HSxVXjad5XwdHeMMD9zOZN+w2/XU/pnR4ZOC+8z1gFLu8NoFA12u8JJxzVs341Hgi62jbb01+P3nSISRKhggLSMIICOwIBATCB/KGB1KSB0TCBzjELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEpMCcGA1UECxMgTWljcm9zb2Z0IE9wZXJhdGlvbnMgUHVlcnRvIFJpY28xJjAkBgNVBAsTHVRoYWxlcyBUU1MgRVNOOkQ5REUtRTM5QS00M0ZFMSUwIwYDVQQDExxNaWNyb3NvZnQgVGltZS1TdGFtcCBTZXJ2aWNloiMKAQEwBwYFKw4DAhoDFQAVblKEDDl6RMRe8v/hXWzStsPPeaCBgzCBgKR+MHwxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29ycG9yYXRpb24xJjAkBgNVBAMTHU1pY3Jvc29mdCBUaW1lLVN0YW1wIFBDQSAyMDEwMA0GCSqGSIb3DQEBBQUAAgUA5CtUwDAiGA8yMDIxMDQyMjA1NDk1MloYDzIwMjEwNDIzMDU0OTUyWjB3MD0GCisGAQQBhFkKBAExLzAtMAoCBQDkK1TAAgEAMAoCAQACAhvGAgH/MAcCAQACAhFQMAoCBQDkLKZAAgEAMDYGCisGAQQBhFkKBAIxKDAmMAwGCisGAQQBhFkKAwKgCjAIAgEAAgMHoSChCjAIAgEAAgMBhqAwDQYJKoZIhvcNAQEFBQADgYEAt+sT3av5NiFriCUIbIe3uaIxngW+9UX0CKYqCDrKgUlzEFbYhcLKMHEH2/r5OmK5Bia180tKjnUO1UjtTOnc7MwrgImqsqUwYUbe/XEni1+V4ca6Rq1Kj5ESBnXJeptgR3ToVxLpnoK8fbcgfsoc010qCBj4CMX4ZPQivOfDbKExggMNMIIDCQIBATCBkzB8MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSYwJAYDVQQDEx1NaWNyb3NvZnQgVGltZS1TdGFtcCBQQ0EgMjAxMAITMwAAAWH1ojNeoCokaQAAAAABYTANBglghkgBZQMEAgEFAKCCAUowGgYJKoZIhvcNAQkDMQ0GCyqGSIb3DQEJEAEEMC8GCSqGSIb3DQEJBDEiBCCeyhKNTO0PVGrV3c26Mck4zEPzFf6L7CRy26B1wld2MzCB+gYLKoZIhvcNAQkQAi8xgeowgecwgeQwgb0EIGHPi6fqaRIt3/MD7Q3lgsMani9b9UG01b+WmaG0CThvMIGYMIGApH4wfDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEmMCQGA1UEAxMdTWljcm9zb2Z0IFRpbWUtU3RhbXAgUENBIDIwMTACEzMAAAFh9aIzXqAqJGkAAAAAAWEwIgQgWnzATmJmqGDQOddbZSK/vY+YxFdFeGew+tJuZXNdppQwDQYJKoZIhvcNAQELBQAEggEATkuCVsod8+n79rW9lhD2DoTvGbnhGEpfhP7aFfxbWbsnykUchMbPe7qWsCM1SjRFTDINjqVv7K81tE3MTh9i65ptm5wPsyWySUBRSbYj9my1x2G3i703il5W7N05QsyvtQZa58ZjYs711V5eNfnSlSHTlEKu+OtLnl4iRQT+NYuXyeBaTDCoTCiD6jmRui04CpoPz3duJkNecugezvF4jif/JIlALd/KAZmPQsVFQ4uBEso15ioeINfltDYpmztGjBXcVyfyxpbbEYXzleseUcQoMGxvsNr1PIhQRZYupEslda1LzZY6aPdVqksSGriZYxKHBphMVyG41rlDhZu1qwAAAAA=</CounterSignature></Object></Signature></doc>
