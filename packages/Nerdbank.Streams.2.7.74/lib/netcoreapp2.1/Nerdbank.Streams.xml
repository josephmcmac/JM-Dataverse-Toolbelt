<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Nerdbank.Streams</name>
    </assembly>
    <members>
        <member name="T:Nerdbank.Streams.BufferTextWriter">
            <summary>
            A <see cref="T:System.IO.TextWriter"/> that writes to a reassignable instance of <see cref="T:System.Buffers.IBufferWriter`1"/>.
            </summary>
            <remarks>
            Using this is much more memory efficient than a <see cref="T:System.IO.StreamWriter"/> when writing to many different
            <see cref="T:System.Buffers.IBufferWriter`1"/> because the same writer, with all its buffers, can be reused.
            </remarks>
        </member>
        <member name="F:Nerdbank.Streams.BufferTextWriter.charBuffer">
            <summary>
            A buffer of written characters that have not yet been encoded.
            The <see cref="F:Nerdbank.Streams.BufferTextWriter.charBufferPosition"/> field tracks how many characters are represented in this buffer.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.BufferTextWriter.bufferWriter">
            <summary>
            The internal buffer writer to use for writing encoded characters.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.BufferTextWriter.memory">
            <summary>
            The last buffer received from <see cref="F:Nerdbank.Streams.BufferTextWriter.bufferWriter"/>.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.BufferTextWriter.memoryPosition">
            <summary>
            The number of characters written to the <see cref="F:Nerdbank.Streams.BufferTextWriter.memory"/> buffer.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.BufferTextWriter.charBufferPosition">
            <summary>
            The number of characters written to the <see cref="F:Nerdbank.Streams.BufferTextWriter.charBuffer"/>.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.BufferTextWriter.preambleWritten">
            <summary>
            Whether the encoding preamble has been written since the last call to <see cref="M:Nerdbank.Streams.BufferTextWriter.Initialize(System.Buffers.IBufferWriter{System.Byte},System.Text.Encoding)"/>.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.BufferTextWriter.encoding">
            <summary>
            The encoding currently in use.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.BufferTextWriter.encodingPreamble">
            <summary>
            The preamble for the current <see cref="F:Nerdbank.Streams.BufferTextWriter.encoding"/>.
            </summary>
            <remarks>
            We store this as a field to avoid calling <see cref="M:System.Text.Encoding.GetPreamble"/> repeatedly,
            since the typical implementation allocates a new array for each call.
            </remarks>
        </member>
        <member name="F:Nerdbank.Streams.BufferTextWriter.encoder">
            <summary>
            An encoder obtained from the current <see cref="F:Nerdbank.Streams.BufferTextWriter.encoding"/> used for incrementally encoding written characters.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.BufferTextWriter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.BufferTextWriter"/> class.
            </summary>
            <remarks>
            When using this constructor, call <see cref="M:Nerdbank.Streams.BufferTextWriter.Initialize(System.Buffers.IBufferWriter{System.Byte},System.Text.Encoding)"/>
            to associate the instance with the initial writer to use before using any write or flush methods.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.BufferTextWriter.#ctor(System.Buffers.IBufferWriter{System.Byte},System.Text.Encoding)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.BufferTextWriter"/> class.
            </summary>
            <param name="bufferWriter">The buffer writer to write to.</param>
            <param name="encoding">The encoding to use.</param>
        </member>
        <member name="P:Nerdbank.Streams.BufferTextWriter.Encoding">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.BufferTextWriter.CharBufferSlack">
            <summary>
            Gets the number of uninitialized characters remaining in <see cref="F:Nerdbank.Streams.BufferTextWriter.charBuffer"/>.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.BufferTextWriter.Initialize(System.Buffers.IBufferWriter{System.Byte},System.Text.Encoding)">
            <summary>
            Prepares for writing to the specified buffer.
            </summary>
            <param name="bufferWriter">The buffer writer to write to.</param>
            <param name="encoding">The encoding to use.</param>
        </member>
        <member name="M:Nerdbank.Streams.BufferTextWriter.Reset">
            <summary>
            Clears references to the <see cref="T:System.Buffers.IBufferWriter`1"/> set by a prior call to <see cref="M:Nerdbank.Streams.BufferTextWriter.Initialize(System.Buffers.IBufferWriter{System.Byte},System.Text.Encoding)"/>.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.BufferTextWriter.Flush">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.BufferTextWriter.FlushAsync">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.BufferTextWriter.Write(System.Char)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.BufferTextWriter.Write(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.BufferTextWriter.Write(System.Char[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.BufferTextWriter.Write(System.ReadOnlySpan{System.Char})">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.BufferTextWriter.WriteLine(System.ReadOnlySpan{System.Char})">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.BufferTextWriter.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.BufferTextWriter.EncodeCharactersIfBufferFull">
            <summary>
            Encodes the written characters if the character buffer is full.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.BufferTextWriter.EncodeCharacters(System.Boolean)">
            <summary>
            Encodes characters written so far to a buffer provided by the underyling <see cref="F:Nerdbank.Streams.BufferTextWriter.bufferWriter"/>.
            </summary>
            <param name="flushEncoder"><c>true</c> to flush the characters in the encoder; useful when finalizing the output.</param>
        </member>
        <member name="M:Nerdbank.Streams.BufferTextWriter.CommitBytes">
            <summary>
            Commits any written bytes to the underlying <see cref="F:Nerdbank.Streams.BufferTextWriter.bufferWriter"/>.
            </summary>
        </member>
        <member name="T:Nerdbank.Streams.BufferWriterStream">
            <summary>
            A stream that writes to a <see cref="T:System.Buffers.IBufferWriter`1"/> of <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.BufferWriterStream.#ctor(System.Buffers.IBufferWriter{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.BufferWriterStream"/> class.
            </summary>
            <param name="writer">The writer to write to.</param>
        </member>
        <member name="P:Nerdbank.Streams.BufferWriterStream.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.BufferWriterStream.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.BufferWriterStream.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.BufferWriterStream.Length">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.BufferWriterStream.Position">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.BufferWriterStream.IsDisposed">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.BufferWriterStream.Flush">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.BufferWriterStream.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.BufferWriterStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.BufferWriterStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.BufferWriterStream.ReadByte">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.BufferWriterStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.BufferWriterStream.SetLength(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.BufferWriterStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.BufferWriterStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.BufferWriterStream.WriteByte(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.BufferWriterStream.Read(System.Span{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.BufferWriterStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.BufferWriterStream.Write(System.ReadOnlySpan{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.BufferWriterStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.BufferWriterStream.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:Nerdbank.Streams.DuplexPipe">
            <summary>
            A basic implementation of <see cref="T:System.IO.Pipelines.IDuplexPipe"/>.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.DuplexPipe.#ctor(System.IO.Pipelines.PipeReader,System.IO.Pipelines.PipeWriter)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.DuplexPipe"/> class.
            </summary>
            <param name="input">The reader. If null, a completed reader will be emulated.</param>
            <param name="output">The writer. If null, a completed writer will be emulated.</param>
        </member>
        <member name="M:Nerdbank.Streams.DuplexPipe.#ctor(System.IO.Pipelines.PipeReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.DuplexPipe"/> class
            that only allows reading. The <see cref="P:Nerdbank.Streams.DuplexPipe.Output"/> property will reject writes.
            </summary>
            <param name="input">The reader.</param>
        </member>
        <member name="M:Nerdbank.Streams.DuplexPipe.#ctor(System.IO.Pipelines.PipeWriter)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.DuplexPipe"/> class
            that only allows writing. The <see cref="P:Nerdbank.Streams.DuplexPipe.Input"/> property will report completed reading.
            </summary>
            <param name="output">The writer.</param>
        </member>
        <member name="P:Nerdbank.Streams.DuplexPipe.Input">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.DuplexPipe.Output">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.DuplexPipe.IsDefinitelyCompleted(System.IO.Pipelines.PipeReader)">
            <summary>
            Checks whether the given <see cref="T:System.IO.Pipelines.PipeReader"/> is known to be already completed.
            </summary>
            <param name="reader">The reader to check.</param>
            <returns><see langword="true" /> if the <paramref name="reader"/> is known to be completed; <see langword="false"/> if the <paramref name="reader"/> is not known to be completed.</returns>
            <remarks>
            This method <em>may</em> return <see langword="false"/> for a completed <see cref="T:System.IO.Pipelines.PipeReader"/>.
            </remarks>
        </member>
        <member name="T:Nerdbank.Streams.FullDuplexStream">
            <summary>
            Provides a full duplex stream which may be shared by two parties to
            exchange messages.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.FullDuplexStream.CreatePair(System.IO.Pipelines.PipeOptions)">
            <summary>
            Creates a pair of streams that can be passed to two parties
            to allow for interaction with each other.
            </summary>
            <param name="pipeOptions">Pipe options to initialize the internal pipes with.</param>
            <returns>A pair of streams.</returns>
        </member>
        <member name="M:Nerdbank.Streams.FullDuplexStream.CreatePipePair(System.IO.Pipelines.PipeOptions)">
            <summary>
            Creates a pair of duplex pipes that can be passed to two parties
            to allow for interaction with each other.
            </summary>
            <param name="pipeOptions">Pipe options to initialize the internal pipes with.</param>
            <returns>A pair of <see cref="T:System.IO.Pipelines.IDuplexPipe"/> objects.</returns>
        </member>
        <member name="M:Nerdbank.Streams.FullDuplexStream.Splice(System.IO.Stream,System.IO.Stream)">
            <summary>
            Combines a readable <see cref="T:System.IO.Stream"/> with a writable <see cref="T:System.IO.Stream"/> into a new full-duplex <see cref="T:System.IO.Stream"/>
            that reads and writes to the specified streams.
            </summary>
            <param name="readableStream">A readable stream.</param>
            <param name="writableStream">A writable stream.</param>
            <returns>A new full-duplex stream.</returns>
        </member>
        <member name="T:Nerdbank.Streams.HalfDuplexStream">
            <summary>
            A <see cref="T:System.IO.Stream"/> that acts as a queue for bytes, in that what gets written to it
            can then be read from it, in order.
            This is actually a "simplex" stream -- not a half duplex stream. Naming bug.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.HalfDuplexStream.pipe">
            <summary>
            The pipe that does all the hard work.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.HalfDuplexStream.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.HalfDuplexStream"/> class.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.HalfDuplexStream.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.HalfDuplexStream"/> class.
            </summary>
            <param name="resumeWriterThreshold">The size the buffer must shrink to after hitting <paramref name="pauseWriterThreshold"/> before writing is allowed to resume.</param>
            <param name="pauseWriterThreshold">The maximum size the buffer is allowed to grow before write calls are blocked (pending a read that will release buffer space.</param>
        </member>
        <member name="P:Nerdbank.Streams.HalfDuplexStream.IsDisposed">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.HalfDuplexStream.CanRead">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.HalfDuplexStream.CanSeek">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.HalfDuplexStream.CanWrite">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.HalfDuplexStream.Length">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.HalfDuplexStream.Position">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.HalfDuplexStream.CompleteWriting">
            <summary>
            Signals that no more writing will take place, causing readers to receive 0 bytes when asking for any more data.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.HalfDuplexStream.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.HalfDuplexStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.HalfDuplexStream.SetLength(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.HalfDuplexStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.HalfDuplexStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.HalfDuplexStream.System#Buffers#IBufferWriter{System#Byte}#Advance(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.HalfDuplexStream.System#Buffers#IBufferWriter{System#Byte}#GetMemory(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.HalfDuplexStream.System#Buffers#IBufferWriter{System#Byte}#GetSpan(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.HalfDuplexStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.HalfDuplexStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.HalfDuplexStream.Flush">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.HalfDuplexStream.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Nerdbank.Streams.MonitoringStream">
            <summary>
            A <see cref="T:System.IO.Stream"/> that wraps another and reports all I/O taking place by raising events.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MonitoringStream.inner">
            <summary>
            The underlying stream serving the I/O.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MonitoringStream.endOfStreamRaised">
            <summary>
            A value indicating whether the <see cref="E:Nerdbank.Streams.MonitoringStream.EndOfStream"/> event has already been raised.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MonitoringStream.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MonitoringStream"/> class.
            </summary>
            <param name="inner">The stream to wrap and monitor I/O for.</param>
        </member>
        <member name="T:Nerdbank.Streams.MonitoringStream.SpanEventHandler">
            <summary>
            A delegate used for events that pass <see cref="T:System.Span`1"/> around.
            </summary>
            <param name="sender">The sender.</param>
            <param name="span">The span.</param>
        </member>
        <member name="T:Nerdbank.Streams.MonitoringStream.ReadOnlySpanEventHandler">
            <summary>
            A delegate used for events that pass <see cref="T:System.ReadOnlySpan`1"/> around.
            </summary>
            <param name="sender">The sender.</param>
            <param name="span">The span.</param>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.EndOfStream">
            <summary>
            Occurs the first time a read method returns 0 bytes.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.DidSeek">
            <summary>
            Occurs after <see cref="M:Nerdbank.Streams.MonitoringStream.Seek(System.Int64,System.IO.SeekOrigin)"/> is invoked.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.WillRead">
            <summary>
            Occurs before <see cref="M:Nerdbank.Streams.MonitoringStream.Read(System.Byte[],System.Int32,System.Int32)"/> or <see cref="M:Nerdbank.Streams.MonitoringStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"/> is invoked.
            </summary>
            <remarks>
            The <see cref="P:System.ArraySegment`1.Count"/> value is the maximum bytes that may be read.
            </remarks>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.DidRead">
            <summary>
            Occurs after <see cref="M:Nerdbank.Streams.MonitoringStream.Read(System.Byte[],System.Int32,System.Int32)"/> or <see cref="M:Nerdbank.Streams.MonitoringStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"/> is invoked.
            </summary>
            <remarks>
            The <see cref="P:System.ArraySegment`1.Count"/> value is the actual bytes that were read.
            </remarks>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.WillReadMemory">
            <summary>
            Occurs before <see cref="M:Nerdbank.Streams.MonitoringStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)"/> is invoked.
            </summary>
            <remarks>
            The <see cref="P:System.Memory`1.Length"/> value is the maximum bytes that may be read.
            </remarks>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.DidReadMemory">
            <summary>
            Occurs after <see cref="M:Nerdbank.Streams.MonitoringStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)"/> is invoked.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.WillReadSpan">
            <summary>
            Occurs before <see cref="M:Nerdbank.Streams.MonitoringStream.Read(System.Span{System.Byte})"/> is invoked.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.DidReadSpan">
            <summary>
            Occurs after <see cref="M:Nerdbank.Streams.MonitoringStream.Read(System.Span{System.Byte})"/> is invoked.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.WillWriteSpan">
            <summary>
            Occurs before <see cref="M:Nerdbank.Streams.MonitoringStream.Write(System.ReadOnlySpan{System.Byte})"/> is invoked.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.DidWriteSpan">
            <summary>
            Occurs after <see cref="M:Nerdbank.Streams.MonitoringStream.Write(System.ReadOnlySpan{System.Byte})"/> is invoked.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.WillWriteMemory">
            <summary>
            Occurs before <see cref="M:Nerdbank.Streams.MonitoringStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)"/> is invoked.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.DidWriteMemory">
            <summary>
            Occurs after <see cref="M:Nerdbank.Streams.MonitoringStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)"/> is invoked.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.WillWrite">
            <summary>
            Occurs before <see cref="M:Nerdbank.Streams.MonitoringStream.Write(System.Byte[],System.Int32,System.Int32)"/> or <see cref="M:Nerdbank.Streams.MonitoringStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"/> is invoked.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.DidWrite">
            <summary>
            Occurs after <see cref="M:Nerdbank.Streams.MonitoringStream.Write(System.Byte[],System.Int32,System.Int32)"/> or <see cref="M:Nerdbank.Streams.MonitoringStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"/> is invoked.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.WillSetLength">
            <summary>
            Occurs before <see cref="M:Nerdbank.Streams.MonitoringStream.SetLength(System.Int64)"/> is invoked.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.DidSetLength">
            <summary>
            Occurs after <see cref="M:Nerdbank.Streams.MonitoringStream.SetLength(System.Int64)"/> is invoked.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.WillReadByte">
            <summary>
            Occurs before <see cref="M:Nerdbank.Streams.MonitoringStream.ReadByte"/> is invoked.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.DidReadByte">
            <summary>
            Occurs after <see cref="M:Nerdbank.Streams.MonitoringStream.ReadByte"/> is invoked.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.WillWriteByte">
            <summary>
            Occurs before <see cref="M:Nerdbank.Streams.MonitoringStream.WriteByte(System.Byte)"/> is invoked.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.DidWriteByte">
            <summary>
            Occurs after <see cref="M:Nerdbank.Streams.MonitoringStream.WriteByte(System.Byte)"/> is invoked.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.DidFlush">
            <summary>
            Occurs after <see cref="M:Nerdbank.Streams.MonitoringStream.Flush"/> or <see cref="M:Nerdbank.Streams.MonitoringStream.FlushAsync(System.Threading.CancellationToken)"/> is invoked.
            </summary>
        </member>
        <member name="E:Nerdbank.Streams.MonitoringStream.Disposed">
            <summary>
            Occurs when <see cref="M:System.IO.Stream.Dispose"/> is invoked.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.MonitoringStream.IsDisposed">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.MonitoringStream.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.MonitoringStream.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.MonitoringStream.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.MonitoringStream.Length">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.MonitoringStream.Position">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.MonitoringStream.ReadTimeout">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.MonitoringStream.WriteTimeout">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.MonitoringStream.CanTimeout">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MonitoringStream.Flush">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MonitoringStream.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MonitoringStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MonitoringStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MonitoringStream.Read(System.Span{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MonitoringStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MonitoringStream.Write(System.ReadOnlySpan{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MonitoringStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MonitoringStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MonitoringStream.SetLength(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MonitoringStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MonitoringStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MonitoringStream.ReadByte">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MonitoringStream.WriteByte(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MonitoringStream.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:Nerdbank.Streams.MultiplexingProtocolException">
            <summary>
            An exception that is thrown when an error occurs on the remote side of a multiplexed connection.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingProtocolException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MultiplexingProtocolException"/> class.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingProtocolException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MultiplexingProtocolException"/> class.
            </summary>
            <param name="message">The message for the exception.</param>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingProtocolException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MultiplexingProtocolException"/> class.
            </summary>
            <param name="message">The message for the exception.</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingProtocolException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MultiplexingProtocolException"/> class
            for use in deserialization.
            </summary>
            <param name="info">The serialization info.</param>
            <param name="context">The serialization context.</param>
        </member>
        <member name="T:Nerdbank.Streams.MultiplexingStream">
            <content>
            Contains the <see cref="T:Nerdbank.Streams.MultiplexingStream.Channel"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:Nerdbank.Streams.MultiplexingStream.ChannelOfferEventArgs"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:Nerdbank.Streams.MultiplexingStream.ChannelOptions"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:Nerdbank.Streams.MultiplexingStream.ControlCode"/> nested type.
            </content>
            <summary>
            Encodes multiple channels over a single transport.
            </summary>
            <content>
            Contains the <see cref="T:Nerdbank.Streams.MultiplexingStream.Formatter" /> nested type.
            </content>
            <content>
            Contains the <see cref="T:Nerdbank.Streams.MultiplexingStream.FrameHeader"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:Nerdbank.Streams.MultiplexingStream.Options"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:Nerdbank.Streams.MultiplexingStream.QualifiedChannelId"/> nested type.
            </content>
        </member>
        <member name="T:Nerdbank.Streams.MultiplexingStream.Channel">
            <summary>
            An individual channel within a <see cref="T:Nerdbank.Streams.MultiplexingStream"/>.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Channel.acceptanceSource">
            <summary>
            This task source completes when the channel has been accepted, rejected, or the offer is canceled.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Channel.completionSource">
            <summary>
            The source for the <see cref="P:Nerdbank.Streams.MultiplexingStream.Channel.Completion"/> property.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Channel.disposalTokenSource">
            <summary>
            The source for a token that will be canceled when this channel has completed.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Channel.optionsAppliedTaskSource">
            <summary>
            The source for the <see cref="P:Nerdbank.Streams.MultiplexingStream.Channel.OptionsApplied"/> property. May be null if options were provided in ctor.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Channel.mxStreamIOWriterCompleted">
            <summary>
            Tracks the end of any copying from the mxstream to this channel.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Channel.remoteWindowHasCapacity">
            <summary>
            Gets a signal which indicates when the <see cref="P:Nerdbank.Streams.MultiplexingStream.Channel.RemoteWindowRemaining"/> is non-zero.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Channel.channelId">
            <summary>
            The party-qualified id of the channel.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Channel.remoteWindowFilled">
            <summary>
            The number of bytes transmitted from here but not yet acknowledged as processed from there,
            and thus occupying some portion of the full <see cref="P:Nerdbank.Streams.MultiplexingStream.Channel.AcceptanceParameters.RemoteWindowSize"/>.
            </summary>
            <remarks>
            All access to this field should be made within a lock on the <see cref="P:Nerdbank.Streams.MultiplexingStream.Channel.SyncObject"/> object.
            </remarks>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Channel.remoteWindowSize">
            <summary>
            The number of bytes that may be transmitted before receiving acknowledgment that those bytes have been processed.
            </summary>
            <remarks>
            This field is set to the value of <see cref="P:Nerdbank.Streams.MultiplexingStream.Channel.OfferParameters.RemoteWindowSize"/> if we accepted the channel,
            or the value of <see cref="P:Nerdbank.Streams.MultiplexingStream.Channel.AcceptanceParameters.RemoteWindowSize"/> if we offered the channel.
            </remarks>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Channel.localWindowSize">
            <summary>
            The number of bytes that may be received and buffered for processing.
            </summary>
            <remarks>
            This field is set to the value of <see cref="P:Nerdbank.Streams.MultiplexingStream.Channel.OfferParameters.RemoteWindowSize"/> if we offered the channel,
            or the value of <see cref="P:Nerdbank.Streams.MultiplexingStream.Channel.AcceptanceParameters.RemoteWindowSize"/> if we accepted the channel.
            </remarks>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Channel.isDisposed">
            <summary>
            Indicates whether the <see cref="M:Nerdbank.Streams.MultiplexingStream.Channel.Dispose"/> method has been called.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Channel.mxStreamIOReader">
            <summary>
            The <see cref="T:System.IO.Pipelines.PipeReader"/> to use to get data to be transmitted over the <see cref="T:Nerdbank.Streams.MultiplexingStream"/>.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Channel.mxStreamIOReaderCompleted">
            <summary>
            A task that represents the completion of the <see cref="F:Nerdbank.Streams.MultiplexingStream.Channel.mxStreamIOReader"/>,
            signifying the point where we will stop relaying data from the channel to the <see cref="P:Nerdbank.Streams.MultiplexingStream.Channel.MultiplexingStream"/> for transmission to the remote party.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Channel.mxStreamIOWriter">
            <summary>
            The <see cref="T:System.IO.Pipelines.PipeWriter"/> the underlying <see cref="T:Nerdbank.Streams.MultiplexingStream"/> should use.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Channel.channelIO">
            <summary>
            The I/O to expose on this channel if <see cref="P:Nerdbank.Streams.MultiplexingStream.ChannelOptions.ExistingPipe"/> was not specified;
            otherwise it is the buffering pipe we use as an intermediary with the specified <see cref="P:Nerdbank.Streams.MultiplexingStream.ChannelOptions.ExistingPipe"/>.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Channel.existingPipe">
            <summary>
            The value of <see cref="P:Nerdbank.Streams.MultiplexingStream.ChannelOptions.ExistingPipe"/> as it was when we received it.
            We don't use this field, but we set it for diagnostic purposes later.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Channel.existingPipeGiven">
            <summary>
            A value indicating whether this <see cref="T:Nerdbank.Streams.MultiplexingStream.Channel"/> was created or accepted with a non-null value for <see cref="P:Nerdbank.Streams.MultiplexingStream.ChannelOptions.ExistingPipe"/>.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Channel.#ctor(Nerdbank.Streams.MultiplexingStream,Nerdbank.Streams.MultiplexingStream.QualifiedChannelId,Nerdbank.Streams.MultiplexingStream.Channel.OfferParameters,Nerdbank.Streams.MultiplexingStream.ChannelOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MultiplexingStream.Channel"/> class.
            </summary>
            <param name="multiplexingStream">The owning <see cref="T:Nerdbank.Streams.MultiplexingStream"/>.</param>
            <param name="channelId">The party-qualified ID of the channel.</param>
            <param name="offerParameters">The parameters of the channel from the offering party.</param>
            <param name="channelOptions">The channel options. Should only be null if the channel is created in response to an offer that is not immediately accepted.</param>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Channel.Id">
            <summary>
            Gets the unique ID for this channel.
            </summary>
            <remarks>
            This value is usually shared for an anonymous channel so the remote party
            can accept it with <see cref="M:Nerdbank.Streams.MultiplexingStream.AcceptChannel(System.Int32,Nerdbank.Streams.MultiplexingStream.ChannelOptions)"/> or
            reject it with <see cref="M:Nerdbank.Streams.MultiplexingStream.RejectChannel(System.Int32)"/>.
            </remarks>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Channel.QualifiedId">
            <summary>
            Gets the unique ID for this channel.
            </summary>
            <remarks>
            This value is usually shared for an anonymous channel so the remote party
            can accept it with <see cref="M:Nerdbank.Streams.MultiplexingStream.AcceptChannel(System.Int32,Nerdbank.Streams.MultiplexingStream.ChannelOptions)"/> or
            reject it with <see cref="M:Nerdbank.Streams.MultiplexingStream.RejectChannel(System.Int32)"/>.
            </remarks>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Channel.TraceSource">
            <summary>
            Gets the mechanism used for tracing activity related to this channel.
            </summary>
            <value>A non-null value, once <see cref="M:Nerdbank.Streams.MultiplexingStream.Channel.ApplyChannelOptions(Nerdbank.Streams.MultiplexingStream.ChannelOptions)"/> has been called.</value>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Channel.IsDisposed">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Channel.Input">
            <summary>
            Gets the reader used to receive data over the channel.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if the channel was created with a non-null value in <see cref="P:Nerdbank.Streams.MultiplexingStream.ChannelOptions.ExistingPipe"/>.</exception>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Channel.Output">
            <summary>
            Gets the writer used to transmit data over the channel.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if the channel was created with a non-null value in <see cref="P:Nerdbank.Streams.MultiplexingStream.ChannelOptions.ExistingPipe"/>.</exception>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Channel.Acceptance">
            <summary>
            Gets a <see cref="T:System.Threading.Tasks.Task"/> that completes when the channel is accepted, rejected, or canceled.
            </summary>
            <remarks>
            If the channel is accepted, this task transitions to <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion"/> state.
            If the channel offer is canceled, this task transitions to a <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/> state.
            If the channel offer is rejected, this task transitions to a <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/> state.
            </remarks>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Channel.Completion">
            <summary>
            Gets a <see cref="T:System.Threading.Tasks.Task"/> that completes when the channel is disposed,
            which occurs when <see cref="M:Nerdbank.Streams.MultiplexingStream.Channel.Dispose"/> is invoked or when both sides
            have indicated they are done writing to the channel.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Channel.MultiplexingStream">
            <summary>
            Gets the underlying <see cref="T:Nerdbank.Streams.MultiplexingStream"/> instance.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Channel.DisposalToken">
            <summary>
            Gets a token that is canceled just before <see cref="P:Nerdbank.Streams.MultiplexingStream.Channel.Completion" /> has transitioned to its final state.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Channel.OptionsApplied">
            <summary>
            Gets a <see cref="T:System.Threading.Tasks.Task"/> that completes when options have been applied to this <see cref="T:Nerdbank.Streams.MultiplexingStream.Channel"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Channel.SyncObject">
            <summary>
            Gets an object that can be locked to make critical changes to this instance's fields.
            </summary>
            <remarks>
            We reuse an object we already have to avoid having to create a new System.Object instance just to lock with.
            </remarks>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Channel.RemoteWindowRemaining">
            <summary>
            Gets the number of bytes that may be transmitted over this channel given the
            remaining space in the <see cref="F:Nerdbank.Streams.MultiplexingStream.Channel.remoteWindowSize"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Channel.BackpressureSupportEnabled">
            <summary>
            Gets a value indicating whether backpressure support is enabled.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Channel.Dispose">
            <summary>
            Closes this channel and releases all resources associated with it.
            </summary>
            <remarks>
            Because this method may terminate the channel immediately and thus can cause previously queued content to not actually be received by the remote party,
            consider this method a "break glass" way of terminating a channel. The preferred method is that both sides "complete writing" and let the channel dispose itself.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Channel.OnContentWritingCompleted">
            <summary>
            Called by the <see cref="P:Nerdbank.Streams.MultiplexingStream.Channel.MultiplexingStream"/> when when it will not be writing any more data to the channel.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Channel.TryAcceptOffer(Nerdbank.Streams.MultiplexingStream.ChannelOptions)">
            <summary>
            Accepts an offer made by the remote party.
            </summary>
            <param name="channelOptions">The options to apply to the channel.</param>
            <returns>A value indicating whether the offer was accepted. It may fail if the channel was already closed or the offer rescinded.</returns>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Channel.OnAccepted(Nerdbank.Streams.MultiplexingStream.Channel.AcceptanceParameters)">
            <summary>
            Occurs when the remote party has accepted our offer of this channel.
            </summary>
            <param name="acceptanceParameters">The channel parameters provided by the accepting party.</param>
            <returns>A value indicating whether the acceptance went through; <c>false</c> if the channel is already accepted, rejected or offer rescinded.</returns>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Channel.OnContentProcessed(System.Int64)">
            <summary>
            Invoked when the remote party acknowledges bytes we previously transmitted as processed,
            thereby allowing us to consider that data removed from the remote party's "window"
            and thus enables us to send more data to them.
            </summary>
            <param name="bytesProcessed">The number of bytes processed by the remote party.</param>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Channel.GetReceivedMessagePipeWriter">
            <summary>
            Gets the pipe writer to use when a message is received for this channel, so that the channel owner will notice and read it.
            </summary>
            <returns>A <see cref="T:System.IO.Pipelines.PipeWriter"/>.</returns>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Channel.ApplyChannelOptions(Nerdbank.Streams.MultiplexingStream.ChannelOptions)">
            <summary>
            Apply channel options to this channel, including setting up or linking to an user-supplied pipe writer/reader pair.
            </summary>
            <param name="channelOptions">The channel options to apply.</param>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Channel.InitializeOwnPipes">
            <summary>
            Set up our own (buffering) Pipes if they have not been set up yet.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Channel.ProcessOutboundTransmissionsAsync">
            <summary>
            Relays data that the local channel owner wants to send to the remote party.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Channel.OnTransmittingBytes(System.Int64)">
            <summary>
            Invoked when we transmit data to the remote party
            so we can track how much data we're sending them so we don't overrun their receiving buffer.
            </summary>
            <param name="transmittedBytes">The number of bytes being transmitted.</param>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Channel.OfferParameters.#ctor(System.String,System.Nullable{System.Int64})">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MultiplexingStream.Channel.OfferParameters"/> class.
            </summary>
            <param name="name">The name of the channel.</param>
            <param name="remoteWindowSize">
            The maximum number of bytes that may be transmitted and not yet acknowledged as processed by the remote party.
            When based on <see cref="P:System.IO.Pipelines.PipeOptions.PauseWriterThreshold"/>, this value should be -1 of that value in order
            to avoid the actual pause that would be fatal to the read loop of the multiplexing stream.
            </param>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Channel.OfferParameters.Name">
            <summary>
            Gets the name of the channel.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Channel.OfferParameters.RemoteWindowSize">
            <summary>
            Gets the maximum number of bytes that may be transmitted and not yet acknowledged as processed by the remote party.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Channel.AcceptanceParameters.#ctor(System.Nullable{System.Int64})">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MultiplexingStream.Channel.AcceptanceParameters"/> class.
            </summary>
            <param name="remoteWindowSize">
            The maximum number of bytes that may be transmitted and not yet acknowledged as processed by the remote party.
            When based on <see cref="P:System.IO.Pipelines.PipeOptions.PauseWriterThreshold"/>, this value should be -1 of that value in order
            to avoid the actual pause that would be fatal to the read loop of the multiplexing stream.
            </param>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Channel.AcceptanceParameters.RemoteWindowSize">
            <summary>
            Gets the maximum number of bytes that may be transmitted and not yet acknowledged as processed by the remote party.
            </summary>
        </member>
        <member name="T:Nerdbank.Streams.MultiplexingStream.ChannelOfferEventArgs">
            <summary>
            Describes an offer for a channel.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.ChannelOfferEventArgs.#ctor(Nerdbank.Streams.MultiplexingStream.QualifiedChannelId,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MultiplexingStream.ChannelOfferEventArgs"/> class.
            </summary>
            <param name="id">The unique ID of the channel.</param>
            <param name="name">The name of the channel.</param>
            <param name="isAccepted">A value indicating whether the channel has already been accepted.</param>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.ChannelOfferEventArgs.Id">
            <inheritdoc cref="P:Nerdbank.Streams.MultiplexingStream.ChannelOfferEventArgs.QualifiedId"/>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.ChannelOfferEventArgs.QualifiedId">
            <summary>
            Gets the unique ID of the channel.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.ChannelOfferEventArgs.Name">
            <summary>
            Gets the name of the channel.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.ChannelOfferEventArgs.IsAccepted">
            <summary>
            Gets a value indicating whether the channel has already been accepted.
            </summary>
        </member>
        <member name="T:Nerdbank.Streams.MultiplexingStream.ChannelOptions">
            <summary>
            Describes local treatment of a channel.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.ChannelOptions.existingPipe">
            <summary>
            Backing field for the <see cref="P:Nerdbank.Streams.MultiplexingStream.ChannelOptions.ExistingPipe"/> property.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.ChannelOptions.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MultiplexingStream.ChannelOptions" /> class.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.ChannelOptions.TraceSource">
            <summary>
            Gets or sets the mechanism used for tracing activity related to this channel.
            </summary>
            <value>The trace source. May be null.</value>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.ChannelOptions.ExistingPipe">
            <summary>
            Gets or sets an existing <see cref="T:System.IO.Pipelines.IDuplexPipe"/> instance used to exchange data with the channel.
            </summary>
            <value>The default is <c>null</c>.</value>
            <remarks>
            <para>
            This property supports high throughput scenarios where channel data ultimately goes to a <see cref="T:System.IO.Pipelines.PipeWriter"/> and <see cref="T:System.IO.Pipelines.PipeReader"/> that already exist.
            This may remove the need for a memory copy of all bytes transferred over the channel by directing the <see cref="T:Nerdbank.Streams.MultiplexingStream"/> to read and write directly an existing reader/writer pair.
            When set, the <see cref="P:Nerdbank.Streams.MultiplexingStream.Channel.Input"/> and <see cref="P:Nerdbank.Streams.MultiplexingStream.Channel.Output"/> properties will throw <see cref="T:System.NotSupportedException"/>
            since their values are implementation details of the existing pipe set here.
            </para>
            <para>
            The <see cref="T:System.IO.Pipelines.PipeWriter"/> specified in <see cref="P:System.IO.Pipelines.IDuplexPipe.Output"/> *must* be created with <see cref="P:System.IO.Pipelines.PipeOptions.PauseWriterThreshold"/> that *exceeds*
            the value of <see cref="P:Nerdbank.Streams.MultiplexingStream.ChannelOptions.ChannelReceivingWindowSize"/> and <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.DefaultChannelReceivingWindowSize"/>.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown if set to an <see cref="T:System.IO.Pipelines.IDuplexPipe"/> that returns <c>null</c> for either of its properties.</exception>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.ChannelOptions.InputPipeOptions">
            <summary>
            Gets or sets the options for the <see cref="T:System.IO.Pipelines.Pipe"/> created to relay local reading from this channel.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.ChannelOptions.ChannelReceivingWindowSize">
            <summary>
            Gets or sets the number of received bytes that may be buffered locally per channel (transmitted from the remote party but not yet processed).
            </summary>
            <remarks>
            This value should be at least the value of <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.DefaultChannelReceivingWindowSize"/> when the <see cref="T:Nerdbank.Streams.MultiplexingStream"/> was created.
            When the value is null or less than <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.DefaultChannelReceivingWindowSize"/>, the value from <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.DefaultChannelReceivingWindowSize"/> is used.
            </remarks>
        </member>
        <member name="T:Nerdbank.Streams.MultiplexingStream.ControlCode">
            <summary>
            Signals what kind of frame is being transmitted.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.ControlCode.Offer">
            <summary>
            A channel is proposed to the remote party.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.ControlCode.OfferAccepted">
            <summary>
            A channel proposal has been accepted.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.ControlCode.Content">
            <summary>
            The payload of the frame is a payload intended for channel consumption.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.ControlCode.ContentWritingCompleted">
            <summary>
            Sent after all bytes have been transmitted on a given channel. Either or both sides may send this.
            A channel may be automatically closed when each side has both transmitted and received this message.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.ControlCode.ChannelTerminated">
            <summary>
            Sent when a channel is closed, an incoming offer is rejected, or an outgoing offer is canceled.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.ControlCode.ContentProcessed">
            <summary>
            Sent when a channel has finished processing data received from the remote party,
            allowing them to send more data.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.ControlChannelId">
            <summary>
            The channel id reserved for control frames.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.FramePayloadMaxLength">
            <summary>
            The maximum length of a frame's payload.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.ControlFrameEncoding">
            <summary>
            The encoding used for characters in control frames.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.DefaultChannelOptions">
            <summary>
            The options to use for channels we create in response to incoming offers.
            </summary>
            <remarks>
            Whatever these settings are, they can be replaced when the channel is accepted.
            </remarks>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.isOdd">
            <summary>
            A value indicating whether this is the "odd" party in the conversation (where the other one would be "even").
            </summary>
            <remarks>
            This value is only significant for parts of the protocol where it's useful to have the two parties behave slightly differently to avoid conflicts.
            </remarks>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.formatter">
            <summary>
            The formatter to use for serializing/deserializing multiplexing streams.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.syncObject">
            <summary>
            The object to lock when accessing internal fields.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.channelsOfferedByThemByName">
            <summary>
            A dictionary of channels being offered by the remote end but not yet accepted by us, keyed by name.
            This does not include ephemeral channels (those without a name).
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.acceptingChannels">
            <summary>
            A dictionary of channels being accepted (but not yet offered).
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.openChannels">
            <summary>
            A dictionary of all open channels (including those not yet accepted), keyed by their ID.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.channelsPendingTermination">
            <summary>
            Contains the set of channels for which we have transmitted a <see cref="F:Nerdbank.Streams.MultiplexingStream.ControlCode.ChannelTerminated"/> frame
            but for which we have not received the same frame.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.sendingSemaphore">
            <summary>
            A semaphore that must be entered to write to the underlying <see cref="F:Nerdbank.Streams.MultiplexingStream.formatter"/>.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.completionSource">
            <summary>
            The source for the <see cref="P:Nerdbank.Streams.MultiplexingStream.Completion"/> property.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.disposalTokenSource">
            <summary>
            A token that is canceled when this instance is disposed.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.protocolMajorVersion">
            <summary>
            The major version of the protocol being used for this connection.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.lastOfferedChannelId">
            <summary>
            The last number assigned to a channel.
            Each use of this should increment by two, if <see cref="F:Nerdbank.Streams.MultiplexingStream.isOdd"/> has a value.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.#ctor(Nerdbank.Streams.MultiplexingStream.Formatter,System.Nullable{System.Boolean},Nerdbank.Streams.MultiplexingStream.Options)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MultiplexingStream"/> class.
            </summary>
            <param name="formatter">The formatter to use for the multiplexing frames.</param>
            <param name="isOdd">A value indicating whether this party is the "odd" one. No value indicates this is the newer protocol version that no longer requires it.</param>
            <param name="options">The options for this instance.</param>
        </member>
        <member name="E:Nerdbank.Streams.MultiplexingStream.ChannelOffered">
            <summary>
            Occurs when the remote party offers to establish a channel.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.TraceEventId.ContentDiscardedOnDisposedChannel">
            <summary>
            Raised when content arrives for a channel that has been disposed locally, resulting in discarding the content.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.TraceEventId.WaitingForNextFrame">
            <summary>
            Raised when we are about to read (or wait for) the next frame.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.TraceEventId.UnexpectedContentProcessed">
            <summary>
            Raised when we receive a <see cref="F:Nerdbank.Streams.MultiplexingStream.ControlCode.ContentProcessed"/> message for an unknown or closed channel.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.TraceEventId.HandshakeStarted">
            <summary>
            Raised when the protocol handshake is starting, to annouce the major version being used.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Completion">
            <summary>
            Gets a task that completes when this instance is disposed, and may have captured a fault that led to its self-disposal.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.TraceSource">
            <summary>
            Gets the logger used by this instance.
            </summary>
            <value>Never null.</value>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.DefaultChannelReceivingWindowSize">
            <summary>
            Gets the default window size used for new channels that do not specify a value for <see cref="P:Nerdbank.Streams.MultiplexingStream.ChannelOptions.ChannelReceivingWindowSize"/>.
            </summary>
            <remarks>
            This value can be set at the time of creation of the <see cref="T:Nerdbank.Streams.MultiplexingStream"/> via <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.DefaultChannelReceivingWindowSize"/>.
            </remarks>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Microsoft#IDisposableObservable#IsDisposed">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.DisposalToken">
            <summary>
            Gets a token that is canceled when this instance is disposed.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.DefaultChannelTraceSourceFactory">
            <summary>
            Gets a factory for <see cref="P:Nerdbank.Streams.MultiplexingStream.TraceSource"/> instances to attach to a newly opened <see cref="T:Nerdbank.Streams.MultiplexingStream.Channel"/>
            when its <see cref="P:Nerdbank.Streams.MultiplexingStream.ChannelOptions.TraceSource"/> is <c>null</c>.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Create(System.IO.Stream,Nerdbank.Streams.MultiplexingStream.Options)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MultiplexingStream"/> class
            with <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.ProtocolMajorVersion"/> set to 3.
            </summary>
            <param name="stream">The stream to multiplex multiple channels over. Use <see cref="M:Nerdbank.Streams.FullDuplexStream.Splice(System.IO.Stream,System.IO.Stream)"/> if you have distinct input/output streams.</param>
            <param name="options">Options to define behavior for the multiplexing stream.</param>
            <returns>The multiplexing stream.</returns>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.CreateAsync(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MultiplexingStream"/> class.
            </summary>
            <param name="stream">The stream to multiplex multiple channels over. Use <see cref="M:Nerdbank.Streams.FullDuplexStream.Splice(System.IO.Stream,System.IO.Stream)"/> if you have distinct input/output streams.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>The multiplexing stream, once the handshake is complete.</returns>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if the remote end disconnects before the handshake is complete.</exception>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.CreateAsync(System.IO.Stream,Nerdbank.Streams.MultiplexingStream.Options,System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MultiplexingStream"/> class.
            </summary>
            <param name="stream">The stream to multiplex multiple channels over. Use <see cref="M:Nerdbank.Streams.FullDuplexStream.Splice(System.IO.Stream,System.IO.Stream)"/> if you have distinct input/output streams.</param>
            <param name="options">Options to define behavior for the multiplexing stream. If unspecified, the default options will include <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.ProtocolMajorVersion"/> set to 1.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>The multiplexing stream, once the handshake is complete.</returns>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if the remote end disconnects before the handshake is complete.</exception>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.CreateChannel(Nerdbank.Streams.MultiplexingStream.ChannelOptions)">
            <summary>
            Creates an anonymous channel that may be accepted by <see cref="M:Nerdbank.Streams.MultiplexingStream.AcceptChannel(System.Int32,Nerdbank.Streams.MultiplexingStream.ChannelOptions)"/>.
            Its existance must be communicated by other means (typically another, existing channel) to encourage acceptance.
            </summary>
            <param name="options">A set of options that describe local treatment of this channel.</param>
            <returns>The anonymous channel.</returns>
            <remarks>
            Note that while the channel is created immediately, any local write to that channel will be buffered locally
            until the remote party accepts the channel.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.AcceptChannel(System.Int32,Nerdbank.Streams.MultiplexingStream.ChannelOptions)">
            <inheritdoc cref="M:Nerdbank.Streams.MultiplexingStream.AcceptChannel(System.UInt64,Nerdbank.Streams.MultiplexingStream.ChannelOptions)"/>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.AcceptChannel(System.UInt64,Nerdbank.Streams.MultiplexingStream.ChannelOptions)">
            <summary>
            Accepts a channel with a specific ID.
            </summary>
            <param name="id">The <see cref="P:Nerdbank.Streams.MultiplexingStream.Channel.Id"/> of the channel to accept.</param>
            <param name="options">A set of options that describe local treatment of this channel.</param>
            <returns>The accepted <see cref="T:Nerdbank.Streams.MultiplexingStream.Channel"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the channel is already accepted or is no longer offered by the remote party.</exception>
            <remarks>
            This method can be used to accept anonymous channels created with <see cref="M:Nerdbank.Streams.MultiplexingStream.CreateChannel(Nerdbank.Streams.MultiplexingStream.ChannelOptions)"/>.
            Unlike <see cref="M:Nerdbank.Streams.MultiplexingStream.AcceptChannelAsync(System.String,Nerdbank.Streams.MultiplexingStream.ChannelOptions,System.Threading.CancellationToken)"/> which will await
            for a channel offer if a matching one has not been made yet, this method only accepts an offer
            for a channel that has already been made.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown when no channel with the specified <paramref name="id"/> exists.</exception>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.RejectChannel(System.Int32)">
            <inheritdoc cref="M:Nerdbank.Streams.MultiplexingStream.RejectChannel(System.UInt64)"/>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.RejectChannel(System.UInt64)">
            <summary>
            Rejects an offer for the channel with a specified ID.
            </summary>
            <param name="id">The ID of the channel whose offer should be rejected.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if the channel was already accepted.</exception>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.OfferChannelAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Offers a new, named channel to the remote party so they may accept it with <see cref="M:Nerdbank.Streams.MultiplexingStream.AcceptChannelAsync(System.String,Nerdbank.Streams.MultiplexingStream.ChannelOptions,System.Threading.CancellationToken)"/>.
            </summary>
            <param name="name">
            A name for the channel, which must be accepted on the remote end to complete creation.
            It need not be unique, and may be empty but must not be null.
            Any characters are allowed, and max length is determined by the maximum frame payload (based on UTF-8 encoding).
            </param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>
            A task that completes with the <see cref="T:Nerdbank.Streams.MultiplexingStream.Channel"/> if the offer is accepted on the remote end
            or faults with <see cref="T:Nerdbank.Streams.MultiplexingProtocolException"/> if the remote end rejects the channel.
            </returns>
            <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken"/> is canceled before the channel is accepted by the remote end.</exception>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.OfferChannelAsync(System.String,Nerdbank.Streams.MultiplexingStream.ChannelOptions,System.Threading.CancellationToken)">
            <summary>
            Offers a new, named channel to the remote party so they may accept it with <see cref="M:Nerdbank.Streams.MultiplexingStream.AcceptChannelAsync(System.String,Nerdbank.Streams.MultiplexingStream.ChannelOptions,System.Threading.CancellationToken)"/>.
            </summary>
            <param name="name">
            A name for the channel, which must be accepted on the remote end to complete creation.
            It need not be unique, and may be empty but must not be null.
            Any characters are allowed, and max length is determined by the maximum frame payload (based on UTF-8 encoding).
            </param>
            <param name="options">A set of options that describe local treatment of this channel.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>
            A task that completes with the <see cref="T:Nerdbank.Streams.MultiplexingStream.Channel"/> if the offer is accepted on the remote end
            or faults with <see cref="T:Nerdbank.Streams.MultiplexingProtocolException"/> if the remote end rejects the channel.
            </returns>
            <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken"/> is canceled before the channel is accepted by the remote end.</exception>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.AcceptChannelAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Accepts a channel that the remote end has attempted or may attempt to create.
            </summary>
            <param name="name">The name of the channel to accept.</param>
            <param name="cancellationToken">A token to indicate lost interest in accepting the channel.</param>
            <returns>The <see cref="T:Nerdbank.Streams.MultiplexingStream.Channel"/>, after its offer has been received from the remote party and accepted.</returns>
            <remarks>
            If multiple offers exist with the specified <paramref name="name"/>, the first one received will be accepted.
            </remarks>
            <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken"/> is canceled before a request to create the channel has been received.</exception>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.AcceptChannelAsync(System.String,Nerdbank.Streams.MultiplexingStream.ChannelOptions,System.Threading.CancellationToken)">
            <summary>
            Accepts a channel that the remote end has attempted or may attempt to create.
            </summary>
            <param name="name">The name of the channel to accept.</param>
            <param name="options">A set of options that describe local treatment of this channel.</param>
            <param name="cancellationToken">A token to indicate lost interest in accepting the channel.</param>
            <returns>The <see cref="T:Nerdbank.Streams.MultiplexingStream.Channel"/>, after its offer has been received from the remote party and accepted.</returns>
            <remarks>
            If multiple offers exist with the specified <paramref name="name"/>, the first one received will be accepted.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if the channel is already accepted or is no longer offered by the remote party.</exception>
            <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken"/> is canceled before a request to create the channel has been received.</exception>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Dispose">
            <summary>
            Immediately closes the underlying transport stream and releases all resources associated with this object and any open channels.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.DisposeAsync">
            <summary>
            Disposes this multiplexing stream.
            </summary>
            <returns>A task that indicates when disposal is complete.</returns>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.OnChannelOffered(Nerdbank.Streams.MultiplexingStream.ChannelOfferEventArgs)">
            <summary>
            Raises the <see cref="E:Nerdbank.Streams.MultiplexingStream.ChannelOffered"/> event.
            </summary>
            <param name="args">The arguments to pass to the event handlers.</param>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.ReadToFillAsync(System.IO.Stream,System.Memory{System.Byte},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Reads to fill a buffer.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="buffer">The buffer to fill.</param>
            <param name="throwOnEmpty"><c>true</c> to throw if 0 bytes are read before the stream before the end of stream is encountered; <c>false</c> to simply return <c>false</c> when that happens.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns><c>true</c> if the buffer was filled as required; <c>false</c> if the stream was empty and no bytes were read, if <paramref name="throwOnEmpty"/> is <c>false</c>.</returns>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if the end of the stream was reached before the buffer was filled (unless <paramref name="throwOnEmpty"/> is false and 0 bytes were read).</exception>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.ReadAndDiscardAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Reads the specified number of bytes from a stream and discards everything read.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="length">The number of bytes to read.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>The result of the operation.</returns>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if the end of the stream was reached before <paramref name="length"/> bytes were read.</exception>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.OnChannelTerminatedAsync(Nerdbank.Streams.MultiplexingStream.QualifiedChannelId)">
            <summary>
            Occurs when the remote party has terminated a channel (including canceling an offer).
            </summary>
            <param name="channelId">The ID of the terminated channel.</param>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.OnChannelDisposed(Nerdbank.Streams.MultiplexingStream.Channel)">
            <summary>
            Raised when <see cref="M:Nerdbank.Streams.MultiplexingStream.Channel.Dispose"/> is called and any local transmission is completed.
            </summary>
            <param name="channel">The channel that is closing down.</param>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.OnChannelWritingCompleted(Nerdbank.Streams.MultiplexingStream.Channel)">
            <summary>
            Indicates that the local end will not be writing any more data to this channel,
            leading to the transmission of a <see cref="F:Nerdbank.Streams.MultiplexingStream.ControlCode.ContentWritingCompleted"/> frame being sent for this channel.
            </summary>
            <param name="channel">The channel whose writing has finished.</param>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.GetUnusedChannelId">
            <summary>
            Gets a unique number that can be used to represent a channel.
            </summary>
            <returns>An unused channel number.</returns>
            <remarks>
            In protocol major versions 1-2, the channel numbers increase by two in order to maintain odd or even numbers, since each party is allowed to create only one or the other.
            </remarks>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Formatter.IsOddEndpoint">
            <summary>
            Gets or sets the result of the handshake regarding whether this endpoint is the "odd" one.
            </summary>
            <remarks>
            Only applicable and set in v1 and v2 of the protocol.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Formatter.WriteHandshake">
            <summary>
            Writes the initial handshake.
            </summary>
            <returns>An object that is passed to <see cref="M:Nerdbank.Streams.MultiplexingStream.Formatter.ReadHandshakeAsync(System.Object,Nerdbank.Streams.MultiplexingStream.Options,System.Threading.CancellationToken)"/> as the first parameter.</returns>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Formatter.ReadHandshakeAsync(System.Object,Nerdbank.Streams.MultiplexingStream.Options,System.Threading.CancellationToken)">
            <summary>
            Reads the initial handshake.
            </summary>
            <param name="writeHandshakeResult">The result of the <see cref="M:Nerdbank.Streams.MultiplexingStream.Formatter.WriteHandshake"/> call.</param>
            <param name="options">Configuration settings that should be shared with the remote party.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>The result of the handshake.</returns>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.V1Formatter.ProtocolMagicNumber">
            <summary>
            The magic number to send at the start of communication when using v1 of the protocol.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.FrameHeader.Code">
            <summary>
            Gets or sets the kind of frame this is.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.FrameHeader.RequiredChannelId">
            <summary>
            Gets the ID of the channel that this frame refers to or carries a payload for.
            </summary>
            <exception cref="T:Nerdbank.Streams.MultiplexingProtocolException">Thrown if <see cref="P:Nerdbank.Streams.MultiplexingStream.FrameHeader.ChannelId"/> is null.</exception>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.FrameHeader.DebuggerDisplay">
            <summary>
            Gets the text to display in the debugger when an instance of this struct is displayed.
            </summary>
        </member>
        <member name="T:Nerdbank.Streams.MultiplexingStream.Options">
            <summary>
            Describes the options that a <see cref="T:Nerdbank.Streams.MultiplexingStream"/> may be created with.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Options.RecommendedDefaultChannelReceivingWindowSize">
            <summary>
            The default window size for a new channel,
            which also serves as the minimum window size for any channel.
            </summary>
            <remarks>
            Using an integer multiple of <see cref="F:Nerdbank.Streams.MultiplexingStream.FramePayloadMaxLength"/> ensures that the client can send full frames
            instead of ending with a partial frame when the remote window limit is reached.
            </remarks>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Options.traceSource">
            <summary>
            Backing field for the <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.TraceSource"/> property.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Options.protocolMajorVersion">
            <summary>
            Backing field for the <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.ProtocolMajorVersion"/> property.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Options.defaultChannelReceivingWindowSize">
            <summary>
            Backing field for the <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.DefaultChannelReceivingWindowSize"/> property.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Options.defaultChannelTraceSourceFactory">
            <summary>
            Backing field for the <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.DefaultChannelTraceSourceFactory"/> property.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.Options.defaultChannelTraceSourceFactoryWithQualifier">
            <summary>
            Backing field for the <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.DefaultChannelTraceSourceFactoryWithQualifier"/> property.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Options.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MultiplexingStream.Options"/> class.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Options.#ctor(Nerdbank.Streams.MultiplexingStream.Options)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MultiplexingStream.Options"/> class
            and copies the values from another instance into this one.
            </summary>
            <param name="copyFrom">The instance to copy values from.</param>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Options.#ctor(Nerdbank.Streams.MultiplexingStream.Options,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MultiplexingStream.Options"/> class
            and copies the values from another instance into this one.
            </summary>
            <param name="copyFrom">The instance to copy values from.</param>
            <param name="frozen"><c>true</c> to freeze this copy.</param>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Options.TraceSource">
            <summary>
            Gets or sets the logger used by this instance.
            </summary>
            <value>Never null.</value>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Options.DefaultChannelReceivingWindowSize">
            <summary>
            Gets or sets the number of received bytes that may be buffered locally per channel (transmitted from the remote party but not yet processed).
            </summary>
            <value>
            Must be a positive value.
            </value>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if set to a non-positive value.</exception>
            <remarks>
            This value is ignored when <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.ProtocolMajorVersion"/> is set to 1.
            </remarks>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Options.ProtocolMajorVersion">
            <summary>
            Gets or sets the protocol version to be used.
            </summary>
            <value>The default is 1.</value>
            <remarks>
            1 is the original and default version.
            2 is a protocol breaking change and adds backpressure support.
            3 is a protocol breaking change that removes the initial handshake so no round-trip to establish the connection is necessary.
            </remarks>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Options.DefaultChannelTraceSourceFactory">
            <summary>
            Gets or sets a factory for <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.TraceSource"/> instances to attach to a newly opened <see cref="T:Nerdbank.Streams.MultiplexingStream.Channel"/>
            when its <see cref="P:Nerdbank.Streams.MultiplexingStream.ChannelOptions.TraceSource"/> is <c>null</c>.
            </summary>
            <remarks>
            <para>The delegate receives a channel ID and name, and may return a <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.TraceSource"/> or <c>null</c>.</para>
            <para>This delegate will not be invoked if <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.DefaultChannelTraceSourceFactoryWithQualifier"/> has been set to a non-null value.</para>
            </remarks>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Options.DefaultChannelTraceSourceFactoryWithQualifier">
            <summary>
            Gets or sets a factory for <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.TraceSource"/> instances to attach to a newly opened <see cref="T:Nerdbank.Streams.MultiplexingStream.Channel"/>
            when its <see cref="P:Nerdbank.Streams.MultiplexingStream.ChannelOptions.TraceSource"/> is <c>null</c>.
            </summary>
            <remarks>
            <para>The delegate receives a channel ID and name, and may return a <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.TraceSource"/> or <c>null</c>.</para>
            <para>This delegate supersedes the obsolete <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.DefaultChannelTraceSourceFactory"/> as this one provides detail about whether the channel was offered locally or remotely.</para>
            </remarks>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Options.SeededChannels">
            <summary>
            Gets a list of options for channels that are to be "seeded" into a new <see cref="T:Nerdbank.Streams.MultiplexingStream"/>.
            </summary>
            <remarks>
            Seeded channels avoid the need for a round-trip for an offer/accept packet exchange.
            Seeded channels are accessed within the <see cref="T:Nerdbank.Streams.MultiplexingStream"/> instance by calling <see cref="M:Nerdbank.Streams.MultiplexingStream.AcceptChannel(System.UInt64,Nerdbank.Streams.MultiplexingStream.ChannelOptions)"/>
            with the 0-based index into this list used as the channel ID.
            They are only supported when <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.ProtocolMajorVersion"/> is at least 3.
            </remarks>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.Options.IsFrozen">
            <summary>
            Gets a value indicating whether this instance is frozen.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.Options.GetFrozenCopy">
            <summary>
            Returns a frozen instance of this object.
            </summary>
            <returns>This instance if already frozen, otherwise a frozen copy.</returns>
        </member>
        <member name="T:Nerdbank.Streams.MultiplexingStream.ChannelSource">
            <summary>
            An enumeration of the possible sources of a channel.
            </summary>
            <remarks>
            The ordinal values are chosen so as to make flipping the perspective as easy as negating the value,
            while leaving the <see cref="F:Nerdbank.Streams.MultiplexingStream.ChannelSource.Seeded"/> value unchanged.
            </remarks>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.ChannelSource.Local">
            <summary>
            The channel was offered by this <see cref="T:Nerdbank.Streams.MultiplexingStream"/> instance to the other party.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.ChannelSource.Remote">
            <summary>
            The channel was offered to this <see cref="T:Nerdbank.Streams.MultiplexingStream"/> instance by the other party.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.MultiplexingStream.ChannelSource.Seeded">
            <summary>
            The channel was seeded during construction via the <see cref="P:Nerdbank.Streams.MultiplexingStream.Options.SeededChannels"/> collection.
            This channel is to be <see cref="M:Nerdbank.Streams.MultiplexingStream.AcceptChannel(System.UInt64,Nerdbank.Streams.MultiplexingStream.ChannelOptions)">accepted</see> by both parties.
            </summary>
        </member>
        <member name="T:Nerdbank.Streams.MultiplexingStream.QualifiedChannelId">
            <summary>
            The channel ID along with which party offered it.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.QualifiedChannelId.#ctor(System.UInt64,Nerdbank.Streams.MultiplexingStream.ChannelSource)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.MultiplexingStream.QualifiedChannelId"/> struct.
            </summary>
            <param name="id">The channel id.</param>
            <param name="source">A value indicating where the channel originated.</param>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.QualifiedChannelId.Id">
            <summary>
            Gets the channel ID.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.MultiplexingStream.QualifiedChannelId.Source">
            <summary>
            Gets a value indicating where the channel originated.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.QualifiedChannelId.Equals(Nerdbank.Streams.MultiplexingStream.QualifiedChannelId)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.QualifiedChannelId.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.QualifiedChannelId.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.MultiplexingStream.QualifiedChannelId.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.NestedPipeReader.AdvanceTo(System.SequencePosition)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.NestedPipeReader.AdvanceTo(System.SequencePosition,System.SequencePosition)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.NestedPipeReader.CancelPendingRead">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.NestedPipeReader.Complete(System.Exception)">
            <inheritdoc/>
            <remarks>
            If the slice has not been fully read or if <paramref name="exception"/> is non-null, this call propagates to the underlying <see cref="T:System.IO.Pipelines.PipeReader"/>.
            But if the slice is fully read without errors, the call is suppressed so the underlying <see cref="T:System.IO.Pipelines.PipeReader"/> can continue to function.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.NestedPipeReader.OnWriterCompleted(System.Action{System.Exception,System.Object},System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.NestedPipeReader.ReadAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.NestedPipeReader.TryRead(System.IO.Pipelines.ReadResult@)">
            <inheritdoc/>
        </member>
        <member name="T:Nerdbank.Streams.NestedStream">
            <summary>
            A stream that allows for reading from another stream up to a given number of bytes.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.NestedStream.underlyingStream">
            <summary>
            The stream to read from.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.NestedStream.length">
            <summary>
            The remaining bytes allowed to be read.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.NestedStream.#ctor(System.IO.Stream,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.NestedStream"/> class.
            </summary>
            <param name="underlyingStream">The stream to read from.</param>
            <param name="length">The number of bytes to read from the parent stream.</param>
        </member>
        <member name="P:Nerdbank.Streams.NestedStream.IsDisposed">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.NestedStream.CanRead">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.NestedStream.CanSeek">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.NestedStream.CanWrite">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.NestedStream.Length">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.NestedStream.Position">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.NestedStream.Flush">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.NestedStream.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.NestedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.NestedStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.NestedStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.NestedStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.NestedStream.SetLength(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.NestedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.NestedStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.NestedStream.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Nerdbank.Streams.PipeExtensions">
            <summary>
            Stream extension methods.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.PipeExtensions.DefaultReadBufferSize">
            <summary>
            The default buffer size to use for pipe readers.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.AsStream(System.IO.Pipelines.IDuplexPipe)">
            <summary>
            Exposes a full-duplex pipe as a <see cref="T:System.IO.Stream"/>.
            The pipe will be completed when the <see cref="T:System.IO.Stream"/> is disposed.
            </summary>
            <param name="pipe">The pipe to wrap as a stream.</param>
            <returns>The wrapping stream.</returns>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.AsStream(System.IO.Pipelines.IDuplexPipe,System.Boolean)">
            <summary>
            Exposes a full-duplex pipe as a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="pipe">The pipe to wrap as a stream.</param>
            <param name="ownsPipe"><c>true</c> to complete the underlying reader and writer when the <see cref="T:System.IO.Stream"/> is disposed; <c>false</c> to keep them open.</param>
            <returns>The wrapping stream.</returns>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.AsStream(System.IO.Pipelines.PipeReader)">
            <summary>
            Exposes a pipe reader as a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="pipeReader">The pipe to read from when <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"/> is invoked.</param>
            <returns>The wrapping stream.</returns>
            <remarks>
            The reader will be completed when the <see cref="T:System.IO.Stream"/> is disposed.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.AsPrebufferedStreamAsync(System.IO.Pipelines.PipeReader,System.Threading.CancellationToken)">
            <summary>
            Exposes a pipe reader as a <see cref="T:System.IO.Stream"/> after asynchronously reading all content
            so the returned stream can be read synchronously without needlessly blocking a thread while waiting for more data.
            </summary>
            <param name="pipeReader">The pipe to read from when <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"/> is invoked.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>The wrapping stream.</returns>
            <remarks>
            The reader will be completed when the <see cref="T:System.IO.Stream"/> is disposed.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.AsStream(System.IO.Pipelines.PipeWriter)">
            <summary>
            Exposes a pipe writer as a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="pipeWriter">The pipe to write to when <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"/> is invoked.</param>
            <returns>The wrapping stream.</returns>
            <remarks>
            The writer will be completed when the <see cref="T:System.IO.Stream"/> is disposed.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.UsePipeReader(System.IO.Stream,System.Int32,System.IO.Pipelines.PipeOptions,System.Threading.CancellationToken)">
            <summary>
            Enables efficiently reading a stream using <see cref="T:System.IO.Pipelines.PipeReader"/>.
            </summary>
            <param name="stream">The stream to read from using a pipe.</param>
            <param name="sizeHint">A hint at the size of messages that are commonly transferred. Use 0 for a commonly reasonable default.</param>
            <param name="pipeOptions">Optional pipe options to use.</param>
            <param name="cancellationToken">A cancellation token that aborts reading from the <paramref name="stream"/>.</param>
            <returns>A <see cref="T:System.IO.Pipelines.PipeReader"/>.</returns>
            <remarks>
            When the caller invokes <see cref="M:System.IO.Pipelines.PipeReader.Complete(System.Exception)"/> on the result value,
            this leads to the associated <see cref="M:System.IO.Pipelines.PipeWriter.Complete(System.Exception)"/> to be automatically called as well.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.UseStrictPipeReader(System.IO.Stream,System.Int32)">
            <summary>
            Creates a <see cref="T:System.IO.Pipelines.PipeReader"/> that reads from the specified <see cref="T:System.IO.Stream"/> exactly as told to do so.
            It does *not* close the <paramref name="stream"/> when completed.
            </summary>
            <param name="stream">The stream to read from using a pipe.</param>
            <param name="sizeHint">A hint at the size of messages that are commonly transferred. Use 0 for a commonly reasonable default.</param>
            <returns>A <see cref="T:System.IO.Pipelines.PipeReader"/>.</returns>
            <remarks>
            This reader may not be as efficient as the <see cref="T:System.IO.Pipelines.Pipe"/>-based <see cref="T:System.IO.Pipelines.PipeReader"/> returned from <see cref="M:Nerdbank.Streams.PipeExtensions.UsePipeReader(System.IO.Stream,System.Int32,System.IO.Pipelines.PipeOptions,System.Threading.CancellationToken)"/>,
            but its interaction with the underlying <see cref="T:System.IO.Stream"/> is closer to how a <see cref="T:System.IO.Stream"/> would typically be used which can ease migration from streams to pipes.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.UsePipeWriter(System.IO.Stream,System.IO.Pipelines.PipeOptions,System.Threading.CancellationToken)">
            <summary>
            Enables writing to a stream using <see cref="T:System.IO.Pipelines.PipeWriter"/>.
            </summary>
            <param name="stream">The stream to write to using a pipe. This stream is *not* closed automatically.</param>
            <param name="pipeOptions">Optional pipe options to use.</param>
            <param name="cancellationToken">A cancellation token that aborts writing to the <paramref name="stream"/>.</param>
            <returns>A <see cref="T:System.IO.Pipelines.PipeWriter"/>.</returns>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.UseStrictPipeWriter(System.IO.Stream)">
            <summary>
            Creates a <see cref="T:System.IO.Pipelines.PipeWriter"/> that writes to an underlying <see cref="T:System.IO.Stream"/>
            when <see cref="M:System.IO.Pipelines.PipeWriter.FlushAsync(System.Threading.CancellationToken)"/> is called rather than asynchronously sometime later.
            </summary>
            <param name="stream">The stream to write to using a pipe.</param>
            <returns>A <see cref="T:System.IO.Pipelines.PipeWriter"/>.</returns>
            <remarks>
            This writer may not be as efficient as the <see cref="T:System.IO.Pipelines.Pipe"/>-based <see cref="T:System.IO.Pipelines.PipeWriter"/> returned from <see cref="M:Nerdbank.Streams.PipeExtensions.UsePipeWriter(System.IO.Stream,System.IO.Pipelines.PipeOptions,System.Threading.CancellationToken)"/>,
            but its interaction with the underlying <see cref="T:System.IO.Stream"/> is closer to how a <see cref="T:System.IO.Stream"/> would typically be used which can ease migration from streams to pipes.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.UsePipe(System.IO.Stream,System.Int32,System.IO.Pipelines.PipeOptions,System.Threading.CancellationToken)">
            <summary>
            Enables reading and writing to a <see cref="T:System.IO.Stream"/> using <see cref="T:System.IO.Pipelines.PipeWriter"/> and <see cref="T:System.IO.Pipelines.PipeReader"/>.
            </summary>
            <param name="stream">The stream to access using a pipe.</param>
            <param name="sizeHint">A hint at the size of messages that are commonly transferred. Use 0 for a commonly reasonable default.</param>
            <param name="pipeOptions">Optional pipe options to use.</param>
            <param name="cancellationToken">A token that may cancel async processes to read from and write to the <paramref name="stream"/>.</param>
            <returns>An <see cref="T:System.IO.Pipelines.IDuplexPipe"/> instance.</returns>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.UsePipe(System.IO.Stream,System.Boolean,System.Int32,System.IO.Pipelines.PipeOptions,System.Threading.CancellationToken)">
            <summary>
            Enables reading and writing to a <see cref="T:System.IO.Stream"/> using <see cref="T:System.IO.Pipelines.PipeWriter"/> and <see cref="T:System.IO.Pipelines.PipeReader"/>.
            </summary>
            <param name="stream">The stream to access using a pipe.</param>
            <param name="allowUnwrap">Obsolete. This value is ignored.</param>
            <param name="sizeHint">A hint at the size of messages that are commonly transferred. Use 0 for a commonly reasonable default.</param>
            <param name="pipeOptions">Optional pipe options to use.</param>
            <param name="cancellationToken">A token that may cancel async processes to read from and write to the <paramref name="stream"/>.</param>
            <returns>An <see cref="T:System.IO.Pipelines.IDuplexPipe"/> instance.</returns>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.UsePipeReader(System.Net.WebSockets.WebSocket,System.Int32,System.IO.Pipelines.PipeOptions,System.Threading.CancellationToken)">
            <summary>
            Enables efficiently reading a <see cref="T:System.Net.WebSockets.WebSocket"/> using <see cref="T:System.IO.Pipelines.PipeReader"/>.
            </summary>
            <param name="webSocket">The web socket to read from using a pipe.</param>
            <param name="sizeHint">A hint at the size of messages that are commonly transferred. Use 0 for a commonly reasonable default.</param>
            <param name="pipeOptions">Optional pipe options to use.</param>
            <param name="cancellationToken">A cancellation token that aborts reading from the <paramref name="webSocket"/>.</param>
            <returns>A <see cref="T:System.IO.Pipelines.PipeReader"/>.</returns>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.UsePipeWriter(System.Net.WebSockets.WebSocket,System.IO.Pipelines.PipeOptions,System.Threading.CancellationToken)">
            <summary>
            Enables efficiently writing to a <see cref="T:System.Net.WebSockets.WebSocket"/> using a <see cref="T:System.IO.Pipelines.PipeWriter"/>.
            </summary>
            <param name="webSocket">The web socket to write to using a pipe.</param>
            <param name="pipeOptions">Optional pipe options to use.</param>
            <param name="cancellationToken">A cancellation token that aborts writing to the <paramref name="webSocket"/>.</param>
            <returns>A <see cref="T:System.IO.Pipelines.PipeWriter"/>.</returns>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.UsePipe(System.Net.WebSockets.WebSocket,System.Int32,System.IO.Pipelines.PipeOptions,System.Threading.CancellationToken)">
            <summary>
            Enables reading and writing to a <see cref="T:System.Net.WebSockets.WebSocket"/> using <see cref="T:System.IO.Pipelines.PipeWriter"/> and <see cref="T:System.IO.Pipelines.PipeReader"/>.
            </summary>
            <param name="webSocket">The <see cref="T:System.Net.WebSockets.WebSocket"/> to access using a pipe.</param>
            <param name="sizeHint">A hint at the size of messages that may be transferred. Use 0 for a commonly reasonable default.</param>
            <param name="pipeOptions">Optional pipe options to use.</param>
            <param name="cancellationToken">A token that may cancel async processes to read from and write to the <paramref name="webSocket"/>.</param>
            <returns>An <see cref="T:System.IO.Pipelines.IDuplexPipe"/> instance.</returns>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.ReadSlice(System.IO.Pipelines.PipeReader,System.Int64)">
            <summary>
            Creates a <see cref="T:System.IO.Pipelines.PipeReader"/> that can read no more than a given number of bytes from an underlying reader.
            </summary>
            <param name="reader">The <see cref="T:System.IO.Pipelines.PipeReader"/> to read from.</param>
            <param name="length">The number of bytes to read from the parent <paramref name="reader"/>.</param>
            <returns>A reader that ends after <paramref name="length"/> bytes are read.</returns>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.OnCompleted(System.IO.Pipelines.PipeReader,System.Action{System.Exception,System.Object},System.Object)">
            <summary>
            Wraps a <see cref="T:System.IO.Pipelines.PipeReader"/> in another object that will report when <see cref="M:System.IO.Pipelines.PipeReader.Complete(System.Exception)"/> is called.
            </summary>
            <param name="reader">The reader to be wrapped.</param>
            <param name="callback">
            The callback to invoke when the <see cref="M:System.IO.Pipelines.PipeReader.Complete(System.Exception)"/> method is called.
            If this delegate throws an exception it will propagate to the caller of the <see cref="M:System.IO.Pipelines.PipeReader.Complete(System.Exception)"/> method.
            </param>
            <param name="state">An optional state object to supply to the <paramref name="callback"/>.</param>
            <returns>The wrapped <see cref="T:System.IO.Pipelines.PipeReader"/> which should be exposed to have its <see cref="M:System.IO.Pipelines.PipeReader.Complete(System.Exception)"/> method called.</returns>
            <remarks>
            If the <see cref="T:System.IO.Pipelines.PipeReader"/> has already been completed, the provided <paramref name="callback"/> may never be invoked.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.OnCompleted(System.IO.Pipelines.PipeWriter,System.Action{System.Exception,System.Object},System.Object)">
            <summary>
            Wraps a <see cref="T:System.IO.Pipelines.PipeWriter"/> in another object that will report when <see cref="M:System.IO.Pipelines.PipeWriter.Complete(System.Exception)"/> is called.
            </summary>
            <param name="reader">The writer to be wrapped.</param>
            <param name="callback">
            The callback to invoke when the <see cref="M:System.IO.Pipelines.PipeWriter.Complete(System.Exception)"/> method is called.
            If this delegate throws an exception it will propagate to the caller of the <see cref="M:System.IO.Pipelines.PipeWriter.Complete(System.Exception)"/> method.
            </param>
            <param name="state">An optional state object to supply to the <paramref name="callback"/>.</param>
            <returns>The wrapped <see cref="T:System.IO.Pipelines.PipeWriter"/> which should be exposed to have its <see cref="M:System.IO.Pipelines.PipeWriter.Complete(System.Exception)"/> method called.</returns>
            <remarks>
            If the <see cref="T:System.IO.Pipelines.PipeWriter"/> has already been completed, the provided <paramref name="callback"/> may never be invoked.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.LinkToAsync(System.IO.Pipelines.PipeReader,System.IO.Pipelines.PipeWriter,System.Threading.CancellationToken)">
            <summary>
            Forwards all bytes coming from a <see cref="T:System.IO.Pipelines.PipeReader"/> to the specified <see cref="T:System.IO.Pipelines.PipeWriter"/>.
            </summary>
            <param name="reader">The reader to get bytes from.</param>
            <param name="writer">The writer to copy bytes to. <see cref="M:System.IO.Pipelines.PipeWriter.CompleteAsync(System.Exception)"/> will be called on this object when the reader completes or an error occurs.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> that completes when the <paramref name="reader"/> has finished producing bytes, or an error occurs.
            This <see cref="T:System.Threading.Tasks.Task"/> never faults, since any exceptions are used to complete the <paramref name="writer"/>.
            </returns>
            <remarks>
            If an error occurs during reading or writing, the <paramref name="writer"/> and <paramref name="reader"/> are completed with the exception.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.LinkToAsync(System.IO.Pipelines.IDuplexPipe,System.IO.Pipelines.IDuplexPipe,System.Threading.CancellationToken)">
            <summary>
            Forwards all bytes coming from either <see cref="T:System.IO.Pipelines.IDuplexPipe"/> to the other <see cref="T:System.IO.Pipelines.IDuplexPipe"/>.
            </summary>
            <param name="pipe1">The first duplex pipe.</param>
            <param name="pipe2">The second duplex pipe.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> that completes when both <see cref="T:System.IO.Pipelines.PipeReader"/> instances are finished producing bytes, or an error occurs.
            This <see cref="T:System.Threading.Tasks.Task"/> never faults, since any exceptions are used to complete the <see cref="T:System.IO.Pipelines.PipeWriter" /> objects.
            </returns>
            <remarks>
            If an error occurs during reading or writing, both reader and writer are completed with the exception.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.UsePipeReader(System.IO.Stream,System.Int32,System.IO.Pipelines.PipeOptions,System.Threading.Tasks.Task,System.Threading.CancellationToken)">
            <summary>
            Enables efficiently reading a stream using <see cref="T:System.IO.Pipelines.PipeReader"/>.
            </summary>
            <param name="stream">The stream to read from using a pipe.</param>
            <param name="sizeHint">A hint at the size of messages that are commonly transferred. Use 0 for a commonly reasonable default.</param>
            <param name="pipeOptions">Optional pipe options to use.</param>
            <param name="disposeWhenReaderCompleted">A task which, when complete, signals that this method should dispose of the <paramref name="stream"/>.</param>
            <param name="cancellationToken">A cancellation token that aborts reading from the <paramref name="stream"/>.</param>
            <returns>A <see cref="T:System.IO.Pipelines.PipeReader"/>.</returns>
            <remarks>
            When the caller invokes <see cref="M:System.IO.Pipelines.PipeReader.Complete(System.Exception)"/> on the result value,
            this leads to the associated <see cref="M:System.IO.Pipelines.PipeWriter.Complete(System.Exception)"/> to be automatically called as well.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.PipeExtensions.Write(System.IO.Pipelines.PipeWriter,System.Buffers.ReadOnlySequence{System.Byte})">
            <summary>
            Copies a sequence of bytes to a <see cref="T:System.IO.Pipelines.PipeWriter"/>.
            </summary>
            <param name="writer">The writer to use.</param>
            <param name="sequence">The sequence to read.</param>
        </member>
        <member name="M:Nerdbank.Streams.PipeWriterCompletionWatcher.Advance(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.PipeWriterCompletionWatcher.CancelPendingFlush">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.PipeWriterCompletionWatcher.Complete(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.PipeWriterCompletionWatcher.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.PipeWriterCompletionWatcher.GetMemory(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.PipeWriterCompletionWatcher.GetSpan(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.PipeWriterCompletionWatcher.OnReaderCompleted(System.Action{System.Exception,System.Object},System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Nerdbank.Streams.PrefixingBufferWriter`1">
            <summary>
            An <see cref="T:System.Buffers.IBufferWriter`1"/> that reserves some fixed size for a header.
            </summary>
            <typeparam name="T">The type of element written by this writer.</typeparam>
            <remarks>
            This type is used for inserting the length of list in the header when the length is not known beforehand.
            It is optimized to minimize or avoid copying.
            </remarks>
        </member>
        <member name="F:Nerdbank.Streams.PrefixingBufferWriter`1.PayloadSizeGuess">
            <summary>
            The value to use in place of <see cref="F:Nerdbank.Streams.PrefixingBufferWriter`1.payloadSizeHint"/> when it is 0.
            </summary>
            <remarks>
            We choose ~4K, since 4K is the default size for buffers in a lot of corefx libraries.
            We choose 4K - 4 specifically because length prefixing is so often for an <see cref="T:System.Int32"/> value,
            and if we ask for 1 byte more than 4K, memory pools tend to give us 8K.
            </remarks>
        </member>
        <member name="F:Nerdbank.Streams.PrefixingBufferWriter`1.innerWriter">
            <summary>
            The underlying buffer writer.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.PrefixingBufferWriter`1.expectedPrefixSize">
            <summary>
            The length of the prefix to reserve space for.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.PrefixingBufferWriter`1.payloadSizeHint">
            <summary>
            The minimum space to reserve for the payload when first asked for a buffer.
            </summary>
            <remarks>
            This, added to <see cref="F:Nerdbank.Streams.PrefixingBufferWriter`1.expectedPrefixSize"/>, makes up the minimum size to request from <see cref="F:Nerdbank.Streams.PrefixingBufferWriter`1.innerWriter"/>
            to minimize the chance that we'll need to copy buffers from <see cref="F:Nerdbank.Streams.PrefixingBufferWriter`1.excessSequence"/> to <see cref="F:Nerdbank.Streams.PrefixingBufferWriter`1.innerWriter"/>.
            </remarks>
        </member>
        <member name="F:Nerdbank.Streams.PrefixingBufferWriter`1.memoryPool">
            <summary>
            The pool to use when initializing <see cref="F:Nerdbank.Streams.PrefixingBufferWriter`1.excessSequence"/>.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.PrefixingBufferWriter`1.excessSequence">
            <summary>
            The buffer writer to use for all buffers after the original one obtained from <see cref="F:Nerdbank.Streams.PrefixingBufferWriter`1.innerWriter"/>.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.PrefixingBufferWriter`1.prefixMemory">
            <summary>
            The buffer from <see cref="F:Nerdbank.Streams.PrefixingBufferWriter`1.innerWriter"/> reserved for the fixed-length prefix.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.PrefixingBufferWriter`1.realMemory">
            <summary>
            The memory being actively written to, which may have come from <see cref="F:Nerdbank.Streams.PrefixingBufferWriter`1.innerWriter"/> or <see cref="F:Nerdbank.Streams.PrefixingBufferWriter`1.excessSequence"/>.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.PrefixingBufferWriter`1.advanced">
            <summary>
            The number of elements written to the original buffer obtained from <see cref="F:Nerdbank.Streams.PrefixingBufferWriter`1.innerWriter"/>.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.PrefixingBufferWriter`1.usingExcessMemory">
            <summary>
            A value indicating whether we're using <see cref="F:Nerdbank.Streams.PrefixingBufferWriter`1.excessSequence"/> in the current state.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.PrefixingBufferWriter`1.#ctor(System.Buffers.IBufferWriter{`0},System.Int32,System.Int32,System.Buffers.MemoryPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.PrefixingBufferWriter`1"/> class.
            </summary>
            <param name="innerWriter">The underlying writer that should ultimately receive the prefix and payload.</param>
            <param name="prefixSize">The length of the header to reserve space for. Must be a positive number.</param>
            <param name="payloadSizeHint">A hint at the expected max size of the payload. The real size may be more or less than this, but additional copying is avoided if it does not exceed this amount. If 0, a reasonable guess is made.</param>
            <param name="memoryPool">The memory pool to use for allocating additional memory when the payload exceeds <paramref name="payloadSizeHint"/>.</param>
        </member>
        <member name="P:Nerdbank.Streams.PrefixingBufferWriter`1.Length">
            <summary>
            Gets the sum of all values passed to <see cref="M:Nerdbank.Streams.PrefixingBufferWriter`1.Advance(System.Int32)"/> since
            the last call to <see cref="M:Nerdbank.Streams.PrefixingBufferWriter`1.Commit"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.PrefixingBufferWriter`1.Prefix">
            <summary>
            Gets the memory reserved for the prefix.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.PrefixingBufferWriter`1.Advance(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.PrefixingBufferWriter`1.GetMemory(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.PrefixingBufferWriter`1.GetSpan(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.PrefixingBufferWriter`1.Commit">
            <summary>
            Commits all the elements written and the prefix to the underlying writer
            and advances the underlying writer past the prefix and payload.
            </summary>
            <remarks>
            This instance is safe to reuse after this call.
            </remarks>
        </member>
        <member name="F:Nerdbank.Streams.ReadOnlySequenceStream.lastReadTask">
            <summary>
            A reusable task if two consecutive reads return the same number of bytes.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.ReadOnlySequenceStream.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.ReadOnlySequenceStream.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.ReadOnlySequenceStream.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.ReadOnlySequenceStream.Length">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.ReadOnlySequenceStream.Position">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.ReadOnlySequenceStream.IsDisposed">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.ReadOnlySequenceStream.Flush">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.ReadOnlySequenceStream.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.ReadOnlySequenceStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.ReadOnlySequenceStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.ReadOnlySequenceStream.ReadByte">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.ReadOnlySequenceStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.ReadOnlySequenceStream.SetLength(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.ReadOnlySequenceStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.ReadOnlySequenceStream.WriteByte(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.ReadOnlySequenceStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.ReadOnlySequenceStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.ReadOnlySequenceStream.Read(System.Span{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.ReadOnlySequenceStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.ReadOnlySequenceStream.Write(System.ReadOnlySpan{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.ReadOnlySequenceStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.ReadOnlySequenceStream.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:Nerdbank.Streams.SequenceTextReader">
            <summary>
            A <see cref="T:System.IO.TextReader"/> that reads from a reassignable instance of <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <remarks>
            Using this is much more memory efficient than a <see cref="T:System.IO.StreamReader"/> when reading from many different
            <see cref="T:System.Buffers.ReadOnlySequence`1"/> instances because the same reader, with all its buffers, can be reused.
            </remarks>
        </member>
        <member name="F:Nerdbank.Streams.SequenceTextReader.charBuffer">
            <summary>
            A buffer of written characters that have not yet been encoded.
            The <see cref="F:Nerdbank.Streams.SequenceTextReader.charBufferPosition"/> field tracks how many characters are represented in this buffer.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.SequenceTextReader.charBufferPosition">
            <summary>
            The number of characters already read from <see cref="F:Nerdbank.Streams.SequenceTextReader.charBuffer"/>.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.SequenceTextReader.charBufferLength">
            <summary>
            The number of characters decoded into <see cref="F:Nerdbank.Streams.SequenceTextReader.charBuffer"/>.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.SequenceTextReader.sequence">
            <summary>
            The sequence to be decoded and read.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.SequenceTextReader.sequencePosition">
            <summary>
            The position of the next byte to decode in <see cref="F:Nerdbank.Streams.SequenceTextReader.sequence"/>.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.SequenceTextReader.encoding">
            <summary>
            The encoding to use while decoding bytes into characters.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.SequenceTextReader.decoder">
            <summary>
            The decoder.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.SequenceTextReader.encodingPreamble">
            <summary>
            The preamble for the <see cref="F:Nerdbank.Streams.SequenceTextReader.encoding"/> in use.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.SequenceTextReader.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.SequenceTextReader"/> class
            without associating it with an initial <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <remarks>
            When using this constructor, call <see cref="M:Nerdbank.Streams.SequenceTextReader.Initialize(System.Buffers.ReadOnlySequence{System.Byte},System.Text.Encoding)"/>
            to associate the instance with the initial byte sequence to be read.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.SequenceTextReader.#ctor(System.Buffers.ReadOnlySequence{System.Byte},System.Text.Encoding)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.SequenceTextReader"/> class.
            </summary>
            <param name="sequence">The sequence to read from.</param>
            <param name="encoding">The encoding to use.</param>
        </member>
        <member name="M:Nerdbank.Streams.SequenceTextReader.Initialize(System.Buffers.ReadOnlySequence{System.Byte},System.Text.Encoding)">
            <summary>
            Initializes or reinitializes this instance to read from a given <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <param name="sequence">The sequence to read from.</param>
            <param name="encoding">The encoding to use.</param>
        </member>
        <member name="M:Nerdbank.Streams.SequenceTextReader.Reset">
            <summary>
            Clears references to the <see cref="T:System.Buffers.ReadOnlySequence`1"/> set by a prior call to <see cref="M:Nerdbank.Streams.SequenceTextReader.Initialize(System.Buffers.ReadOnlySequence{System.Byte},System.Text.Encoding)"/>.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.SequenceTextReader.Peek">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SequenceTextReader.Read">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SequenceTextReader.Read(System.Char[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SequenceTextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SequenceTextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SequenceTextReader.ReadToEndAsync">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SequenceTextReader.ReadLineAsync">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SequenceTextReader.Read(System.Span{System.Char})">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SequenceTextReader.ReadBlockAsync(System.Memory{System.Char},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SequenceTextReader.ReadAsync(System.Memory{System.Char},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:Nerdbank.Streams.Sequence`1">
            <summary>
            Manages a sequence of elements, readily castable as a <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <typeparam name="T">The type of element stored by the sequence.</typeparam>
            <remarks>
            Instance members are not thread-safe.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.Sequence`1"/> class
            that uses a private <see cref="T:System.Buffers.ArrayPool`1"/> for recycling arrays.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.#ctor(System.Buffers.MemoryPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.Sequence`1"/> class.
            </summary>
            <param name="memoryPool">The pool to use for recycling backing arrays.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.#ctor(System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.Sequence`1"/> class.
            </summary>
            <param name="arrayPool">The pool to use for recycling backing arrays.</param>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.MinimumSpanLength">
            <summary>
            Gets or sets the minimum length for any array allocated as a segment in the sequence.
            Any non-positive value allows the pool to determine the length of the array.
            </summary>
            <value>The default value is 0.</value>
            <remarks>
            <para>
            Each time <see cref="M:Nerdbank.Streams.Sequence`1.GetSpan(System.Int32)"/> or <see cref="M:Nerdbank.Streams.Sequence`1.GetMemory(System.Int32)"/> is called,
            previously allocated memory is used if it is large enough to satisfy the length demand.
            If new memory must be allocated, the argument to one of these methods typically dictate
            the length of array to allocate. When the caller uses very small values (just enough for its immediate need)
            but the high level scenario can predict that a large amount of memory will be ultimately required,
            it can be advisable to set this property to a value such that just a few larger arrays are allocated
            instead of many small ones.
            </para>
            <para>
            The <see cref="T:System.Buffers.MemoryPool`1"/> in use may itself have a minimum array length as well,
            in which case the higher of the two minimums dictate the minimum array size that will be allocated.
            </para>
            <para>
            If <see cref="P:Nerdbank.Streams.Sequence`1.AutoIncreaseMinimumSpanLength"/> is <c>true</c>, this value may be automatically increased as the length of a sequence grows.
            </para>
            </remarks>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.AutoIncreaseMinimumSpanLength">
            <summary>
            Gets or sets a value indicating whether the <see cref="P:Nerdbank.Streams.Sequence`1.MinimumSpanLength"/> should be
            intelligently increased as the length of the sequence grows.
            </summary>
            <remarks>
            This can help prevent long sequences made up of many very small arrays.
            </remarks>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.AsReadOnlySequence">
            <summary>
            Gets this sequence expressed as a <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <returns>A read only sequence representing the data in this object.</returns>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.Length">
            <summary>
            Gets the length of the sequence.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.DebuggerDisplay">
            <summary>
            Gets the value to display in a debugger datatip.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.op_Implicit(Nerdbank.Streams.Sequence{`0})~System.Buffers.ReadOnlySequence{`0}">
            <summary>
            Expresses this sequence as a <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <param name="sequence">The sequence to convert.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.AdvanceTo(System.SequencePosition)">
            <summary>
            Removes all elements from the sequence from its beginning to the specified position,
            considering that data to have been fully processed.
            </summary>
            <param name="position">
            The position of the first element that has not yet been processed.
            This is typically <see cref="P:System.Buffers.ReadOnlySequence`1.End"/> after reading all elements from that instance.
            </param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.Advance(System.Int32)">
            <summary>
            Advances the sequence to include the specified number of elements initialized into memory
            returned by a prior call to <see cref="M:Nerdbank.Streams.Sequence`1.GetMemory(System.Int32)"/>.
            </summary>
            <param name="count">The number of elements written into memory.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.GetMemory(System.Int32)">
            <summary>
            Gets writable memory that can be initialized and added to the sequence via a subsequent call to <see cref="M:Nerdbank.Streams.Sequence`1.Advance(System.Int32)"/>.
            </summary>
            <param name="sizeHint">The size of the memory required, or 0 to just get a convenient (non-empty) buffer.</param>
            <returns>The requested memory.</returns>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.GetSpan(System.Int32)">
            <summary>
            Gets writable memory that can be initialized and added to the sequence via a subsequent call to <see cref="M:Nerdbank.Streams.Sequence`1.Advance(System.Int32)"/>.
            </summary>
            <param name="sizeHint">The size of the memory required, or 0 to just get a convenient (non-empty) buffer.</param>
            <returns>The requested memory.</returns>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.Append(System.ReadOnlyMemory{`0})">
            <summary>
            Adds an existing memory location to this sequence without copying.
            </summary>
            <param name="memory">The memory to add.</param>
            <remarks>
            This *may* leave significant slack space in a previously allocated block if calls to <see cref="M:Nerdbank.Streams.Sequence`1.Append(System.ReadOnlyMemory{`0})"/>
            follow calls to <see cref="M:Nerdbank.Streams.Sequence`1.GetMemory(System.Int32)"/> or <see cref="M:Nerdbank.Streams.Sequence`1.GetSpan(System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.Dispose">
            <summary>
            Clears the entire sequence, recycles associated memory into pools,
            and resets this instance for reuse.
            This invalidates any <see cref="T:System.Buffers.ReadOnlySequence`1"/> previously produced by this instance.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.Reset">
            <summary>
            Clears the entire sequence and recycles associated memory into pools.
            This invalidates any <see cref="T:System.Buffers.ReadOnlySequence`1"/> previously produced by this instance.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.Sequence`1.SequenceSegment.MayContainReferences">
            <summary>
            A value indicating whether the element may contain references (and thus must be cleared).
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.Sequence`1.SequenceSegment.array">
            <summary>
            Gets the backing array, when using an <see cref="T:System.Buffers.ArrayPool`1"/> instead of a <see cref="T:System.Buffers.MemoryPool`1"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.Start">
            <summary>
            Gets the position within <see cref="P:System.Buffers.ReadOnlySequenceSegment`1.Memory"/> where the data starts.
            </summary>
            <remarks>This may be nonzero as a result of calling <see cref="M:Nerdbank.Streams.Sequence`1.AdvanceTo(System.SequencePosition)"/>.</remarks>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.End">
            <summary>
            Gets the position within <see cref="P:System.Buffers.ReadOnlySequenceSegment`1.Memory"/> where the data ends.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.RemainingMemory">
            <summary>
            Gets the tail of memory that has not yet been committed.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.RemainingSpan">
            <summary>
            Gets the tail of memory that has not yet been committed.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.MemoryOwner">
            <summary>
            Gets the tracker for the underlying array for this segment, which can be used to recycle the array when we're disposed of.
            Will be <c>null</c> if using an array pool, in which case the memory is held by <see cref="F:Nerdbank.Streams.Sequence`1.SequenceSegment.array"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.AvailableMemory">
            <summary>
            Gets the full memory owned by the <see cref="P:Nerdbank.Streams.Sequence`1.SequenceSegment.MemoryOwner"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.Length">
            <summary>
            Gets the number of elements that are committed in this segment.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.WritableBytes">
            <summary>
            Gets the amount of writable bytes in this segment.
            It is the amount of bytes between <see cref="P:Nerdbank.Streams.Sequence`1.SequenceSegment.Length"/> and <see cref="P:Nerdbank.Streams.Sequence`1.SequenceSegment.End"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.Next">
            <summary>
            Gets or sets the next segment in the singly linked list of segments.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.IsForeignMemory">
            <summary>
            Gets a value indicating whether this segment refers to memory that came from outside and that we cannot write to nor recycle.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.Assign(System.Buffers.IMemoryOwner{`0})">
            <summary>
            Assigns this (recyclable) segment a new area in memory.
            </summary>
            <param name="memoryOwner">The memory and a means to recycle it.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.Assign(`0[])">
            <summary>
            Assigns this (recyclable) segment a new area in memory.
            </summary>
            <param name="array">An array drawn from an <see cref="T:System.Buffers.ArrayPool`1"/>.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.AssignForeign(System.ReadOnlyMemory{`0})">
            <summary>
            Assigns this (recyclable) segment a new area in memory.
            </summary>
            <param name="memory">A memory block obtained from outside, that we do not own and should not recycle.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.ResetMemory(System.Buffers.ArrayPool{`0})">
            <summary>
            Clears all fields in preparation to recycle this instance.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.SetNext(Nerdbank.Streams.Sequence{`0}.SequenceSegment)">
            <summary>
            Adds a new segment after this one.
            </summary>
            <param name="segment">The next segment in the linked list.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.Advance(System.Int32)">
            <summary>
            Commits more elements as written in this segment.
            </summary>
            <param name="count">The number of elements written.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.AdvanceTo(System.Int32)">
            <summary>
            Removes some elements from the start of this segment.
            </summary>
            <param name="offset">The number of elements to ignore from the start of the underlying array.</param>
        </member>
        <member name="T:Nerdbank.Streams.SimplexStream">
            <summary>
            A <see cref="T:System.IO.Stream"/> that acts as a queue for bytes, in that what gets written to it
            can then be read from it, in order.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.SimplexStream.pipe">
            <summary>
            The pipe that does all the hard work.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.SimplexStream.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.SimplexStream"/> class.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.SimplexStream.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.SimplexStream"/> class.
            </summary>
            <param name="resumeWriterThreshold">The size the buffer must shrink to after hitting <paramref name="pauseWriterThreshold"/> before writing is allowed to resume.</param>
            <param name="pauseWriterThreshold">The maximum size the buffer is allowed to grow before write calls are blocked (pending a read that will release buffer space.</param>
        </member>
        <member name="P:Nerdbank.Streams.SimplexStream.IsDisposed">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.SimplexStream.CanRead">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.SimplexStream.CanSeek">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.SimplexStream.CanWrite">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.SimplexStream.Length">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.SimplexStream.Position">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SimplexStream.CompleteWriting">
            <summary>
            Signals that no more writing will take place, causing readers to receive 0 bytes when asking for any more data.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.SimplexStream.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SimplexStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SimplexStream.SetLength(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SimplexStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SimplexStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SimplexStream.System#Buffers#IBufferWriter{System#Byte}#Advance(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SimplexStream.System#Buffers#IBufferWriter{System#Byte}#GetMemory(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SimplexStream.System#Buffers#IBufferWriter{System#Byte}#GetSpan(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SimplexStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SimplexStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SimplexStream.Flush">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.SimplexStream.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Nerdbank.Streams.StreamExtensions">
            <summary>
            Stream extension methods.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.StreamExtensions.ReadSlice(System.IO.Stream,System.Int64)">
            <summary>
            Creates a <see cref="T:System.IO.Stream"/> that can read no more than a given number of bytes from an underlying stream.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="length">The number of bytes to read from the parent stream.</param>
            <returns>A stream that ends after <paramref name="length"/> bytes are read.</returns>
        </member>
        <member name="M:Nerdbank.Streams.StreamExtensions.AsStream(System.Net.WebSockets.WebSocket)">
            <summary>
            Exposes a <see cref="T:System.Net.WebSockets.WebSocket"/> as a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="webSocket">The <see cref="T:System.Net.WebSockets.WebSocket"/> to use as a transport for the returned <see cref="T:System.IO.Stream"/>.</param>
            <returns>A bidirectional <see cref="T:System.IO.Stream"/>.</returns>
        </member>
        <member name="M:Nerdbank.Streams.StreamExtensions.AsStream(System.Buffers.ReadOnlySequence{System.Byte})">
            <summary>
            Exposes a <see cref="T:System.Buffers.ReadOnlySequence`1"/> of <see cref="T:System.Byte"/> as a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="readOnlySequence">The sequence of bytes to expose as a stream.</param>
            <returns>The readable stream.</returns>
        </member>
        <member name="M:Nerdbank.Streams.StreamExtensions.AsStream(System.Buffers.ReadOnlySequence{System.Byte},System.Action{System.Object},System.Object)">
            <summary>
            Exposes a <see cref="T:System.Buffers.ReadOnlySequence`1"/> of <see cref="T:System.Byte"/> as a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="readOnlySequence">The sequence of bytes to expose as a stream.</param>
            <param name="disposeAction">A delegate to invoke when the returned stream is disposed. This might be useful to recycle the buffers backing the <paramref name="readOnlySequence"/>.</param>
            <param name="disposeActionArg">The argument to pass to <paramref name="disposeAction"/>.</param>
            <returns>The readable stream.</returns>
        </member>
        <member name="M:Nerdbank.Streams.StreamExtensions.AsStream(System.Buffers.IBufferWriter{System.Byte})">
            <summary>
            Creates a writable <see cref="T:System.IO.Stream"/> that can be used to add to a <see cref="T:System.Buffers.IBufferWriter`1"/> of <see cref="T:System.Byte"/>.
            </summary>
            <param name="writer">The buffer writer the stream should write to.</param>
            <returns>A <see cref="T:System.IO.Stream"/>.</returns>
        </member>
        <member name="M:Nerdbank.Streams.StreamExtensions.WriteSubstream(System.IO.Stream,System.Int32)">
            <summary>
            Create a new <see cref="T:System.IO.StreamWriter"/> that can be used to write a byte sequence of undetermined length to some underlying <see cref="T:System.IO.Stream"/>,
            such that it can later be read back as if it were a <see cref="T:System.IO.Stream"/> of its own that ends at the end of this particular sequence.
            </summary>
            <param name="stream">The underlying stream to write to.</param>
            <param name="minimumBufferSize">The buffer size to use.</param>
            <returns>The new <see cref="T:System.IO.Stream"/>.</returns>
            <remarks>
            Write to the returned <see cref="T:System.IO.Stream"/> until the sub-stream is complete. Call <see cref="M:Nerdbank.Streams.Substream.DisposeAsync(System.Threading.CancellationToken)"/>
            when done and resume writing to the parent stream as needed.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.StreamExtensions.ReadSubstream(System.IO.Stream)">
            <summary>
            Create a new <see cref="T:System.IO.StreamReader"/> that will read a sequence previously written to this stream using <see cref="M:Nerdbank.Streams.StreamExtensions.WriteSubstream(System.IO.Stream,System.Int32)"/>.
            </summary>
            <param name="stream">The underlying stream to read from.</param>
            <returns>A stream that will read just to the end of the substream and then end.</returns>
        </member>
        <member name="M:Nerdbank.Streams.StreamExtensions.ReadBlockAsync(System.IO.Stream,System.Memory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Fills a given buffer with bytes from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="buffer">The buffer to fill from the <paramref name="stream"/>.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>
            A task that represents the asynchronous read operation. Its resulting value contains the total number of bytes read into the buffer.
            The result value can be less than the length of the given buffer if the end of the stream has been reached.
            </returns>
            <exception cref="T:System.OperationCanceledException">May be thrown if <paramref name="cancellationToken"/> is canceled before reading has completed.</exception>
            <remarks>
            The returned task does not complete until either the <paramref name="buffer"/> is filled or the end of the <paramref name="stream"/> has been reached.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.StreamExtensions.ReadBlockOrThrowAsync(System.IO.Stream,System.Memory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Fills a given buffer with bytes from the specified <see cref="T:System.IO.Stream"/>
            or throws if the end of the stream is reached first.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="buffer">The buffer to fill from the <paramref name="stream"/>.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>
            A task that represents the asynchronous read operation.
            </returns>
            <exception cref="T:System.OperationCanceledException">May be thrown if <paramref name="cancellationToken"/> is canceled before reading has completed.</exception>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if the end of the stream is encountered before filling the buffer.</exception>
            <remarks>
            The returned task does not complete until either the <paramref name="buffer"/> is filled or the end of the <paramref name="stream"/> has been reached.
            </remarks>
        </member>
        <member name="T:Nerdbank.Streams.StreamPipeReader">
            <summary>
            A <see cref="T:System.IO.Pipelines.PipeReader"/> that reads from an underlying <see cref="T:System.IO.Stream"/> exactly when told to do so
            rather than constantly reading from the stream and buffering up the results.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.StreamPipeReader.stream">
            <summary><inheritdoc cref="M:Nerdbank.Streams.StreamPipeReader.#ctor(System.IO.Stream,System.Int32,System.Boolean)" path="/param[@name='stream']"/></summary>
        </member>
        <member name="F:Nerdbank.Streams.StreamPipeReader.bufferSize">
            <summary>
            May be 0 for a reasonable default as determined by the <see cref="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)"/> method.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.StreamPipeReader.leaveOpen">
            <summary><inheritdoc cref="M:Nerdbank.Streams.StreamPipeReader.#ctor(System.IO.Stream,System.Int32,System.Boolean)" path="/param[@name='leaveOpen']"/></summary>
        </member>
        <member name="F:Nerdbank.Streams.StreamPipeReader.isWriterCompleted">
            <summary>
            Indicates when we have drained the underlying stream of all bytes.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.StreamPipeReader.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.StreamPipeReader"/> class.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="bufferSize">A hint at the size of messages that are commonly transferred. Use 0 for a commonly reasonable default.</param>
            <param name="leaveOpen"><c>true</c> to leave the underlying <paramref name="stream"/> open after calling <see cref="M:System.IO.Pipelines.PipeReader.Complete(System.Exception)"/>; <c>false</c> to close the stream.</param>
        </member>
        <member name="M:Nerdbank.Streams.StreamPipeReader.AdvanceTo(System.SequencePosition)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.StreamPipeReader.AdvanceTo(System.SequencePosition,System.SequencePosition)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.StreamPipeReader.CancelPendingRead">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.StreamPipeReader.Complete(System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.StreamPipeReader.OnWriterCompleted(System.Action{System.Exception,System.Object},System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.StreamPipeReader.ReadAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.StreamPipeReader.TryRead(System.IO.Pipelines.ReadResult@)">
            <inheritdoc />
        </member>
        <member name="T:Nerdbank.Streams.StreamPipeWriter">
            <summary>
            A <see cref="T:System.IO.Pipelines.PipeWriter"/> that writes to an underlying <see cref="T:System.IO.Stream"/>
            when <see cref="M:Nerdbank.Streams.StreamPipeWriter.FlushAsync(System.Threading.CancellationToken)"/> is called rather than asynchronously sometime later.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.StreamPipeWriter.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.StreamPipeWriter"/> class.
            </summary>
            <param name="stream">The stream to write to.</param>
        </member>
        <member name="M:Nerdbank.Streams.StreamPipeWriter.Advance(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.StreamPipeWriter.CancelPendingFlush">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.StreamPipeWriter.Complete(System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.StreamPipeWriter.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.StreamPipeWriter.GetMemory(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.StreamPipeWriter.GetSpan(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.StreamPipeWriter.OnReaderCompleted(System.Action{System.Exception,System.Object},System.Object)">
            <inheritdoc />
        </member>
        <member name="T:Nerdbank.Streams.Strings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Strings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Strings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Strings.ExistingPipeOutputHasPauseThresholdSetTooLow">
            <summary>
              Looks up a localized string similar to ExistingPipe&apos;s PipeWriter created with PipeOptions.PauseWriterThreshold that does not exceed the channel&apos;s receiving window size..
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Strings.Frozen">
            <summary>
              Looks up a localized string similar to This instance has been frozen. No mutations are allowed..
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Strings.NoChannelFoundById">
            <summary>
              Looks up a localized string similar to No channel with that ID found..
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Strings.NotAllowedOnSeededChannel">
            <summary>
              Looks up a localized string similar to This operation is not allowed on a seeded channel..
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Strings.NotSupportedWhenExistingPipeSpecified">
            <summary>
              Looks up a localized string similar to This operation is not supported when the Channel is created with ChannelOptions.ExistingPipe set..
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Strings.PipeReaderCanceled">
            <summary>
              Looks up a localized string similar to The PipeReader was canceled..
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Strings.PipeWriterFlushCanceled">
            <summary>
              Looks up a localized string similar to The PipeWriter flush was canceled..
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Strings.ReadingAfterCompletionNotAllowed">
            <summary>
              Looks up a localized string similar to Reading not allowed after reader is completed..
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Strings.SeededChannelsRequireV3Protocol">
            <summary>
              Looks up a localized string similar to Seeded channels must be empty unless the protocol version is 3 or later..
            </summary>
        </member>
        <member name="T:Nerdbank.Streams.Substream">
            <summary>
            A stream that writes substreams of arbitrary length.
            Created with <see cref="M:Nerdbank.Streams.StreamExtensions.WriteSubstream(System.IO.Stream,System.Int32)"/>
            and later read with <see cref="M:Nerdbank.Streams.StreamExtensions.ReadSubstream(System.IO.Stream)"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Substream.IsDisposed">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.Substream.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.Substream.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.Substream.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.Substream.CanTimeout">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.Substream.Length">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.Substream.Position">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.Substream.DisposeAsync">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.Substream.DisposeAsync(System.Threading.CancellationToken)">
            <summary>
            Flushes any buffers, and writes the bytes required to indicate that this substream is at its end.
            </summary>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>A task to represent the async operation.</returns>
        </member>
        <member name="M:Nerdbank.Streams.Substream.Flush">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.Substream.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.Substream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.Substream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.Substream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.Substream.SetLength(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.Substream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.Substream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.Substream.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:Nerdbank.Streams.SubstreamReader">
            <summary>
            A stream that reads substreams of arbitrary length.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.SubstreamReader.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.SubstreamReader"/> class.
            </summary>
            <param name="underlyingStream">The stream to read from.</param>
        </member>
        <member name="P:Nerdbank.Streams.SubstreamReader.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.SubstreamReader.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.SubstreamReader.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.SubstreamReader.CanTimeout">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.SubstreamReader.Length">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.SubstreamReader.Position">
            <inheritdoc/>
        </member>
        <member name="P:Nerdbank.Streams.SubstreamReader.IsDisposed">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.SubstreamReader.Flush">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.SubstreamReader.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.SubstreamReader.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.SubstreamReader.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.SubstreamReader.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.SubstreamReader.SetLength(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.SubstreamReader.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.SubstreamReader.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Nerdbank.Streams.SubstreamReader.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:Nerdbank.Streams.Utilities">
            <summary>
            Internal utilities.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.Utilities.CompletedTask">
            <summary>
            A completed task.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Utilities.ValidateBufferIndexAndCount``1(``0[],System.Int32,System.Int32)">
            <summary>
            Validates that a buffer is not null and that its index and count refer to valid positions within the buffer.
            </summary>
            <typeparam name="T">The type of element stored in the array.</typeparam>
            <param name="buffer">The array to check.</param>
            <param name="index">The starting position within the buffer.</param>
            <param name="count">The number of elements to process in the buffer.</param>
        </member>
        <member name="M:Nerdbank.Streams.Utilities.RemoveMidQueue``1(System.Collections.Generic.Queue{``0},``0)">
            <summary>
            Removes an element from the middle of a queue without disrupting the other elements.
            </summary>
            <typeparam name="T">The element to remove.</typeparam>
            <param name="queue">The queue to modify.</param>
            <param name="valueToRemove">The value to remove.</param>
            <returns><c>true</c> if the value was found and removed; <c>false</c> if no match was found.</returns>
            <remarks>
            If a value appears multiple times in the queue, only its first entry is removed.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.Utilities.ReadInt(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads an <see cref="T:System.Int32"/> value from a buffer using big endian.
            </summary>
            <param name="buffer">The buffer to read from. Must be at most 4 bytes long.</param>
            <returns>The read value.</returns>
        </member>
        <member name="M:Nerdbank.Streams.Utilities.Write(System.Span{System.Byte},System.Int32)">
            <summary>
            Writes an <see cref="T:System.Int32"/> value to a buffer using big endian.
            </summary>
            <param name="buffer">The buffer to write to. Must be at least 4 bytes long.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:Nerdbank.Streams.Utilities.Write(System.Span{System.Byte},System.UInt16)">
            <summary>
            Writes an <see cref="T:System.UInt16"/> value to a buffer using big endian.
            </summary>
            <param name="buffer">The buffer to write to. Must be at least 2 bytes long.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:Nerdbank.Streams.Utilities.ScrubAfterAdvanceTo(System.IO.Pipelines.ReadResult@)">
            <summary>
            Removes the memory from <see cref="T:System.IO.Pipelines.ReadResult"/> that may have been recycled by a call to <see cref="M:System.IO.Pipelines.PipeReader.AdvanceTo(System.SequencePosition)"/>.
            </summary>
            <param name="readResult">The <see cref="T:System.IO.Pipelines.ReadResult"/> to scrub.</param>
            <remarks>
            The <see cref="P:System.IO.Pipelines.ReadResult.IsCanceled"/> and <see cref="P:System.IO.Pipelines.ReadResult.IsCompleted"/> values are preserved, but the <see cref="P:System.IO.Pipelines.ReadResult.Buffer"/> is made empty by this call.
            </remarks>
        </member>
        <member name="T:Nerdbank.Streams.WebSocketStream">
            <summary>
            Exposes a <see cref="T:System.Net.WebSockets.WebSocket"/> as a <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.WebSocketStream.CompletedTask">
            <summary>
            A completed task.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.WebSocketStream.webSocket">
            <summary>
            The socket wrapped by this stream.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.WebSocketStream.#ctor(System.Net.WebSockets.WebSocket)">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.WebSocketStream"/> class.
            </summary>
            <param name="webSocket">The web socket to wrap in a stream.</param>
        </member>
        <member name="P:Nerdbank.Streams.WebSocketStream.IsDisposed">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.WebSocketStream.CanRead">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.WebSocketStream.CanSeek">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.WebSocketStream.CanWrite">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.WebSocketStream.Length">
            <inheritdoc />
        </member>
        <member name="P:Nerdbank.Streams.WebSocketStream.Position">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.WebSocketStream.Flush">
            <summary>
            Does nothing, since web sockets do not need to be flushed.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.WebSocketStream.FlushAsync(System.Threading.CancellationToken)">
            <summary>
            Does nothing, since web sockets do not need to be flushed.
            </summary>
            <param name="cancellationToken">An ignored cancellation token.</param>
            <returns>A completed task.</returns>
        </member>
        <member name="M:Nerdbank.Streams.WebSocketStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.WebSocketStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.WebSocketStream.SetLength(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.WebSocketStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.WebSocketStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.WebSocketStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Nerdbank.Streams.WebSocketStream.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:MessagePack.BufferWriter">
            <summary>
            A fast access struct that wraps <see cref="T:System.Buffers.IBufferWriter`1"/>.
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._output">
            <summary>
            The underlying <see cref="T:System.Buffers.IBufferWriter`1"/>.
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._span">
            <summary>
            The result of the last call to <see cref="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)"/>, less any bytes already "consumed" with <see cref="M:MessagePack.BufferWriter.Advance(System.Int32)"/>.
            Backing field for the <see cref="P:MessagePack.BufferWriter.Span"/> property.
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._segment">
            <summary>
            The result of the last call to <see cref="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)"/>, less any bytes already "consumed" with <see cref="M:MessagePack.BufferWriter.Advance(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._buffered">
            <summary>
            The number of uncommitted bytes (all the calls to <see cref="M:MessagePack.BufferWriter.Advance(System.Int32)"/> since the last call to <see cref="M:MessagePack.BufferWriter.Commit"/>).
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._bytesCommitted">
            <summary>
            The total number of bytes written with this writer.
            Backing field for the <see cref="P:MessagePack.BufferWriter.BytesCommitted"/> property.
            </summary>
        </member>
        <member name="M:MessagePack.BufferWriter.#ctor(System.Buffers.IBufferWriter{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.BufferWriter"/> struct.
            </summary>
            <param name="output">The <see cref="T:System.Buffers.IBufferWriter`1"/> to be wrapped.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.#ctor(MessagePack.SequencePool,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.BufferWriter"/> struct.
            </summary>
            <param name="sequencePool">The pool from which to draw an <see cref="T:System.Buffers.IBufferWriter`1"/> if required..</param>
            <param name="array">An array to start with so we can avoid accessing the <paramref name="sequencePool"/> if possible.</param>
        </member>
        <member name="P:MessagePack.BufferWriter.Span">
            <summary>
            Gets the result of the last call to <see cref="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)"/>.
            </summary>
        </member>
        <member name="P:MessagePack.BufferWriter.BytesCommitted">
            <summary>
            Gets the total number of bytes written with this writer.
            </summary>
        </member>
        <member name="P:MessagePack.BufferWriter.UnderlyingWriter">
            <summary>
            Gets the <see cref="T:System.Buffers.IBufferWriter`1"/> underlying this instance.
            </summary>
        </member>
        <member name="M:MessagePack.BufferWriter.Commit">
            <summary>
            Calls <see cref="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)"/> on the underlying writer
            with the number of uncommitted bytes.
            </summary>
        </member>
        <member name="M:MessagePack.BufferWriter.Advance(System.Int32)">
            <summary>
            Used to indicate that part of the buffer has been written to.
            </summary>
            <param name="count">The number of bytes written to.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.Write(System.ReadOnlySpan{System.Byte})">
            <summary>
            Copies the caller's buffer into this writer and calls <see cref="M:MessagePack.BufferWriter.Advance(System.Int32)"/> with the length of the source buffer.
            </summary>
            <param name="source">The buffer to copy in.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.Ensure(System.Int32)">
            <summary>
            Acquires a new buffer if necessary to ensure that some given number of bytes can be written to a single buffer.
            </summary>
            <param name="count">The number of bytes that must be allocated in a single buffer.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.TryGetUncommittedSpan(System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Gets the span to the bytes written if they were never committed to the underlying buffer writer.
            </summary>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:MessagePack.BufferWriter.EnsureMore(System.Int32)">
            <summary>
            Gets a fresh span to write to, with an optional minimum size.
            </summary>
            <param name="count">The minimum size for the next requested buffer.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.WriteMultiBuffer(System.ReadOnlySpan{System.Byte})">
            <summary>
            Copies the caller's buffer into this writer, potentially across multiple buffers from the underlying writer.
            </summary>
            <param name="source">The buffer to copy into this writer.</param>
        </member>
        <member name="T:MessagePack.MessagePackType">
            <summary>
            https://github.com/msgpack/msgpack/blob/master/spec.md#serialization-type-to-format-conversion.
            </summary>
        </member>
        <member name="T:MessagePack.MessagePackCode">
            <summary>
            The core type codes as defined by msgpack.
            </summary>
            <seealso href="https://github.com/msgpack/msgpack/blob/master/spec.md#overview" />
        </member>
        <member name="M:MessagePack.MessagePackCode.IsSignedInteger(System.Byte)">
            <summary>
            Checks whether a given messagepack code represents an integer that might include a sign (i.e. might be a negative number).
            </summary>
            <param name="code">The messagepack code.</param>
            <returns>A boolean value.</returns>
        </member>
        <member name="T:MessagePack.ReservedMessagePackExtensionTypeCode">
            <summary>
            The officially defined messagepack extension type codes.
            </summary>
        </member>
        <member name="T:MessagePack.MessagePackReader">
            <summary>
            A primitive types reader for the MessagePack format.
            </summary>
            <remarks>
            <see href="https://github.com/msgpack/msgpack/blob/master/spec.md">The MessagePack spec.</see>.
            </remarks>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown when reading methods fail due to invalid data.</exception>
            <exception cref="T:System.IO.EndOfStreamException">Thrown by reading methods when there are not enough bytes to read the required value.</exception>
        </member>
        <member name="F:MessagePack.MessagePackReader.reader">
            <summary>
            The reader over the sequence.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackReader.#ctor(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackReader"/> struct.
            </summary>
            <param name="memory">The buffer to read from.</param>
        </member>
        <member name="M:MessagePack.MessagePackReader.#ctor(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackReader"/> struct.
            </summary>
            <param name="readOnlySequence">The sequence to read from.</param>
        </member>
        <member name="P:MessagePack.MessagePackReader.CancellationToken">
            <summary>
            Gets or sets the cancellation token for this deserialization operation.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.Depth">
            <summary>
            Gets or sets the present depth of the object graph being deserialized.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.Sequence">
            <summary>
            Gets the <see cref="T:System.Buffers.ReadOnlySequence`1"/> originally supplied to the constructor.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.Position">
            <summary>
            Gets the current position of the reader within <see cref="P:MessagePack.MessagePackReader.Sequence"/>.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.Consumed">
            <summary>
            Gets the number of bytes consumed by the reader.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.End">
            <summary>
            Gets a value indicating whether the reader is at the end of the sequence.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.IsNil">
            <summary>
            Gets a value indicating whether the reader position is pointing at a nil value.
            </summary>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if the end of the sequence provided to the constructor is reached before the expected end of the data.</exception>
        </member>
        <member name="P:MessagePack.MessagePackReader.NextMessagePackType">
            <summary>
            Gets the next message pack type to be read.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.NextCode">
            <summary>
            Gets the type of the next MessagePack block.
            </summary>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if the end of the sequence provided to the constructor is reached before the expected end of the data.</exception>
            <remarks>
            See <see cref="T:MessagePack.MessagePackCode"/> for valid message pack codes and ranges.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.Clone(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackReader"/> struct,
            with the same settings as this one, but with its own buffer to read from.
            </summary>
            <param name="readOnlySequence">The sequence to read from.</param>
            <returns>The new reader.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.CreatePeekReader">
            <summary>
            Creates a new <see cref="T:MessagePack.MessagePackReader"/> at this reader's current position.
            The two readers may then be used independently without impacting each other.
            </summary>
            <returns>A new <see cref="T:MessagePack.MessagePackReader"/>.</returns>
            <devremarks>
            Since this is a struct, copying it completely is as simple as returning itself
            from a property that isn't a "ref return" property.
            </devremarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.Skip">
            <summary>
            Advances the reader to the next MessagePack primitive to be read.
            </summary>
            <remarks>
            The entire primitive is skipped, including content of maps or arrays, or any other type with payloads.
            To get the raw MessagePack sequence that was skipped, use <see cref="M:MessagePack.MessagePackReader.ReadRaw"/> instead.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.TrySkip">
            <summary>
            Advances the reader to the next MessagePack primitive to be read.
            </summary>
            <returns><c>true</c> if the entire structure beginning at the current <see cref="P:MessagePack.MessagePackReader.Position"/> is found in the <see cref="P:MessagePack.MessagePackReader.Sequence"/>; <c>false</c> otherwise.</returns>
            <remarks>
            The entire primitive is skipped, including content of maps or arrays, or any other type with payloads.
            To get the raw MessagePack sequence that was skipped, use <see cref="M:MessagePack.MessagePackReader.ReadRaw"/> instead.
            WARNING: when false is returned, the position of the reader is undefined.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadNil">
            <summary>
            Reads a <see cref="F:MessagePack.MessagePackCode.Nil"/> value.
            </summary>
            <returns>A nil value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadNil">
            <summary>
            Reads nil if it is the next token.
            </summary>
            <returns><c>true</c> if the next token was nil; <c>false</c> otherwise.</returns>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if the end of the sequence provided to the constructor is reached before the expected end of the data.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadRaw(System.Int64)">
            <summary>
            Reads a sequence of bytes without any decoding.
            </summary>
            <param name="length">The number of bytes to read.</param>
            <returns>The sequence of bytes read.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadRaw">
            <summary>
            Reads the next MessagePack primitive.
            </summary>
            <returns>The raw MessagePack sequence.</returns>
            <remarks>
            The entire primitive is read, including content of maps or arrays, or any other type with payloads.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadArrayHeader">
            <summary>
            Read an array header from
            <see cref="F:MessagePack.MessagePackCode.Array16"/>,
            <see cref="F:MessagePack.MessagePackCode.Array32"/>, or
            some built-in code between <see cref="F:MessagePack.MessagePackCode.MinFixArray"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixArray"/>.
            </summary>
            <exception cref="T:System.IO.EndOfStreamException">
            Thrown if the header cannot be read in the bytes left in the <see cref="P:MessagePack.MessagePackReader.Sequence"/>
            or if it is clear that there are insufficient bytes remaining after the header to include all the elements the header claims to be there.
            </exception>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an array header is encountered.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadArrayHeader(System.Int32@)">
            <summary>
            Reads an array header from
            <see cref="F:MessagePack.MessagePackCode.Array16"/>,
            <see cref="F:MessagePack.MessagePackCode.Array32"/>, or
            some built-in code between <see cref="F:MessagePack.MessagePackCode.MinFixArray"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixArray"/>
            if there is sufficient buffer to read it.
            </summary>
            <param name="count">Receives the number of elements in the array if the entire array header could be read.</param>
            <returns><c>true</c> if there was sufficient buffer and an array header was found; <c>false</c> if the buffer incompletely describes an array header.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an array header is encountered.</exception>
            <remarks>
            When this method returns <c>false</c> the position of the reader is left in an undefined position.
            The caller is expected to recreate the reader (presumably with a longer sequence to read from) before continuing.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadMapHeader">
            <summary>
            Read a map header from
            <see cref="F:MessagePack.MessagePackCode.Map16"/>,
            <see cref="F:MessagePack.MessagePackCode.Map32"/>, or
            some built-in code between <see cref="F:MessagePack.MessagePackCode.MinFixMap"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixMap"/>.
            </summary>
            <returns>The number of key=value pairs in the map.</returns>
            <exception cref="T:System.IO.EndOfStreamException">
            Thrown if the header cannot be read in the bytes left in the <see cref="P:MessagePack.MessagePackReader.Sequence"/>
            or if it is clear that there are insufficient bytes remaining after the header to include all the elements the header claims to be there.
            </exception>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an map header is encountered.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadMapHeader(System.Int32@)">
            <summary>
            Reads a map header from
            <see cref="F:MessagePack.MessagePackCode.Map16"/>,
            <see cref="F:MessagePack.MessagePackCode.Map32"/>, or
            some built-in code between <see cref="F:MessagePack.MessagePackCode.MinFixMap"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixMap"/>
            if there is sufficient buffer to read it.
            </summary>
            <param name="count">Receives the number of key=value pairs in the map if the entire map header can be read.</param>
            <returns><c>true</c> if there was sufficient buffer and a map header was found; <c>false</c> if the buffer incompletely describes an map header.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an map header is encountered.</exception>
            <remarks>
            When this method returns <c>false</c> the position of the reader is left in an undefined position.
            The caller is expected to recreate the reader (presumably with a longer sequence to read from) before continuing.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadBoolean">
            <summary>
            Reads a boolean value from either a <see cref="F:MessagePack.MessagePackCode.False"/> or <see cref="F:MessagePack.MessagePackCode.True"/>.
            </summary>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadChar">
            <summary>
            Reads a <see cref="T:System.Char"/> from any of:
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            or anything between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>.
            </summary>
            <returns>A character.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadSingle">
            <summary>
            Reads an <see cref="T:System.Single"/> value from any value encoded with:
            <see cref="F:MessagePack.MessagePackCode.Float32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int64"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt64"/>,
            or some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            or some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>.
            </summary>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadDouble">
            <summary>
            Reads an <see cref="T:System.Double"/> value from any value encoded with:
            <see cref="F:MessagePack.MessagePackCode.Float64"/>,
            <see cref="F:MessagePack.MessagePackCode.Float32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int64"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt64"/>,
            or some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            or some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>.
            </summary>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadDateTime">
            <summary>
            Reads a <see cref="T:System.DateTime"/> from a value encoded with
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>.
            Expects extension type code <see cref="F:MessagePack.ReservedMessagePackExtensionTypeCode.DateTime"/>.
            </summary>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadDateTime(MessagePack.ExtensionHeader)">
            <summary>
            Reads a <see cref="T:System.DateTime"/> from a value encoded with
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>.
            Expects extension type code <see cref="F:MessagePack.ReservedMessagePackExtensionTypeCode.DateTime"/>.
            </summary>
            <param name="header">The extension header that was already read.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadBytes">
            <summary>
            Reads a span of bytes, whose length is determined by a header of one of these types:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>,
            or to support OldSpec compatibility:
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or something between <see cref="F:MessagePack.MessagePackCode.MinFixStr"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixStr"/>.
            </summary>
            <returns>
            A sequence of bytes, or <c>null</c> if the read token is <see cref="F:MessagePack.MessagePackCode.Nil"/>.
            The data is a slice from the original sequence passed to this reader's constructor.
            </returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadStringSequence">
            <summary>
            Reads a string of bytes, whose length is determined by a header of one of these types:
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or a code between <see cref="F:MessagePack.MessagePackCode.MinFixStr"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixStr"/>.
            </summary>
            <returns>
            The sequence of bytes, or <c>null</c> if the read token is <see cref="F:MessagePack.MessagePackCode.Nil"/>.
            The data is a slice from the original sequence passed to this reader's constructor.
            </returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadStringSpan(System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Reads a string of bytes, whose length is determined by a header of one of these types:
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or a code between <see cref="F:MessagePack.MessagePackCode.MinFixStr"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixStr"/>.
            </summary>
            <param name="span">Receives the span to the string.</param>
            <returns>
            <c>true</c> if the string is contiguous in memory such that it could be set as a single span.
            <c>false</c> if the read token is <see cref="F:MessagePack.MessagePackCode.Nil"/> or the string is not in a contiguous span.
            </returns>
            <remarks>
            Callers should generally be prepared for a <c>false</c> result and failover to calling <see cref="M:MessagePack.MessagePackReader.ReadStringSequence"/>
            which can represent a <c>null</c> result and handle strings that are not contiguous in memory.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadString">
            <summary>
            Reads a string, whose length is determined by a header of one of these types:
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or a code between <see cref="F:MessagePack.MessagePackCode.MinFixStr"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixStr"/>.
            </summary>
            <returns>A string, or <c>null</c> if the current msgpack token is <see cref="F:MessagePack.MessagePackCode.Nil"/>.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadExtensionFormatHeader">
            <summary>
            Reads an extension format header, based on one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>.
            </summary>
            <returns>The extension header.</returns>
            <exception cref="T:System.IO.EndOfStreamException">
            Thrown if the header cannot be read in the bytes left in the <see cref="P:MessagePack.MessagePackReader.Sequence"/>
            or if it is clear that there are insufficient bytes remaining after the header to include all the bytes the header claims to be there.
            </exception>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an extension format header is encountered.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadExtensionFormatHeader(MessagePack.ExtensionHeader@)">
            <summary>
            Reads an extension format header, based on one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>
            if there is sufficient buffer to read it.
            </summary>
            <param name="extensionHeader">Receives the extension header if the remaining bytes in the <see cref="P:MessagePack.MessagePackReader.Sequence"/> fully describe the header.</param>
            <returns>The number of key=value pairs in the map.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an extension format header is encountered.</exception>
            <remarks>
            When this method returns <c>false</c> the position of the reader is left in an undefined position.
            The caller is expected to recreate the reader (presumably with a longer sequence to read from) before continuing.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadExtensionFormat">
            <summary>
            Reads an extension format header and data, based on one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>.
            </summary>
            <returns>
            The extension format.
            The data is a slice from the original sequence passed to this reader's constructor.
            </returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ThrowNotEnoughBytesException">
            <summary>
            Throws an exception indicating that there aren't enough bytes remaining in the buffer to store
            the promised data.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackReader.ThrowNotEnoughBytesException(System.Exception)">
            <summary>
            Throws an exception indicating that there aren't enough bytes remaining in the buffer to store
            the promised data.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackReader.ThrowInvalidCode(System.Byte)">
            <summary>
            Throws an <see cref="T:MessagePack.MessagePackSerializationException"/> explaining an unexpected code was encountered.
            </summary>
            <param name="code">The code that was encountered.</param>
            <returns>Nothing. This method always throws.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ThrowInsufficientBufferUnless(System.Boolean)">
            <summary>
            Throws <see cref="T:System.IO.EndOfStreamException"/> if a condition is false.
            </summary>
            <param name="condition">A boolean value.</param>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if <paramref name="condition"/> is <c>false</c>.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryGetStringLengthInBytes(System.Int32@)">
            <summary>
            Gets the length of the next string.
            </summary>
            <param name="length">Receives the length of the next string, if there were enough bytes to read it.</param>
            <returns><c>true</c> if there were enough bytes to read the length of the next string; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.GetStringLengthInBytes">
            <summary>
            Gets the length of the next string.
            </summary>
            <returns>The length of the next string.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadStringSlow(System.Int32)">
            <summary>
            Reads a string assuming that it is spread across multiple spans in the <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <param name="byteLength">The length of the string to be decoded, in bytes.</param>
            <returns>The decoded string.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadByte">
            <summary>
            Reads an <see cref="T:System.Byte"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadUInt16">
            <summary>
            Reads an <see cref="T:System.UInt16"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadUInt32">
            <summary>
            Reads an <see cref="T:System.UInt32"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadUInt64">
            <summary>
            Reads an <see cref="T:System.UInt64"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadSByte">
            <summary>
            Reads an <see cref="T:System.SByte"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadInt16">
            <summary>
            Reads an <see cref="T:System.Int16"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadInt32">
            <summary>
            Reads an <see cref="T:System.Int32"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadInt64">
            <summary>
            Reads an <see cref="T:System.Int64"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="T:MessagePack.MessagePackSerializationException">
            <summary>
            An exception thrown during serializing an object graph or deserializing a messagepack sequence.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackSerializationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializationException"/> class.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackSerializationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializationException"/> class.
            </summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:MessagePack.MessagePackSerializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializationException"/> class.
            </summary>
            <param name="message">The exception message.</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:MessagePack.MessagePackSerializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializationException"/> class.
            </summary>
            <param name="info">Serialization info.</param>
            <param name="context">Serialization context.</param>
        </member>
        <member name="T:MessagePack.MessagePackWriter">
            <summary>
            A primitive types writer for the MessagePack format.
            </summary>
            <remarks>
            <see href="https://github.com/msgpack/msgpack/blob/master/spec.md">The MessagePack spec.</see>.
            </remarks>
        </member>
        <member name="F:MessagePack.MessagePackWriter.writer">
            <summary>
            The writer to use.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackWriter.#ctor(System.Buffers.IBufferWriter{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackWriter"/> struct.
            </summary>
            <param name="writer">The writer to use.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.#ctor(MessagePack.SequencePool,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackWriter"/> struct.
            </summary>
            <param name="sequencePool">The pool from which to draw an <see cref="T:System.Buffers.IBufferWriter`1"/> if required..</param>
            <param name="array">An array to start with so we can avoid accessing the <paramref name="sequencePool"/> if possible.</param>
        </member>
        <member name="P:MessagePack.MessagePackWriter.CancellationToken">
            <summary>
            Gets or sets the cancellation token for this serialization operation.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackWriter.OldSpec">
            <summary>
            Gets or sets a value indicating whether to write in <see href="https://github.com/msgpack/msgpack/blob/master/spec-old.md">old spec</see> compatibility mode.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Clone(System.Buffers.IBufferWriter{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackWriter"/> struct,
            with the same settings as this one, but with its own buffer writer.
            </summary>
            <param name="writer">The writer to use for the new instance.</param>
            <returns>The new writer.</returns>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Flush">
            <summary>
            Ensures everything previously written has been flushed to the underlying <see cref="T:System.Buffers.IBufferWriter`1"/>.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteNil">
            <summary>
            Writes a <see cref="F:MessagePack.MessagePackCode.Nil"/> value.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteRaw(System.ReadOnlySpan{System.Byte})">
            <summary>
            Copies bytes directly into the message pack writer.
            </summary>
            <param name="rawMessagePackBlock">The span of bytes to copy from.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteRaw(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Copies bytes directly into the message pack writer.
            </summary>
            <param name="rawMessagePackBlock">The span of bytes to copy from.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteArrayHeader(System.Int32)">
            <summary>
            Write the length of the next array to be written in the most compact form of
            <see cref="F:MessagePack.MessagePackCode.MinFixArray"/>,
            <see cref="F:MessagePack.MessagePackCode.Array16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Array32"/>.
            </summary>
            <param name="count">The number of elements that will be written in the array.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteArrayHeader(System.UInt32)">
            <summary>
            Write the length of the next array to be written in the most compact form of
            <see cref="F:MessagePack.MessagePackCode.MinFixArray"/>,
            <see cref="F:MessagePack.MessagePackCode.Array16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Array32"/>.
            </summary>
            <param name="count">The number of elements that will be written in the array.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteMapHeader(System.Int32)">
            <summary>
            Write the length of the next map to be written in the most compact form of
            <see cref="F:MessagePack.MessagePackCode.MinFixMap"/>,
            <see cref="F:MessagePack.MessagePackCode.Map16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Map32"/>.
            </summary>
            <param name="count">The number of key=value pairs that will be written in the map.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteMapHeader(System.UInt32)">
            <summary>
            Write the length of the next map to be written in the most compact form of
            <see cref="F:MessagePack.MessagePackCode.MinFixMap"/>,
            <see cref="F:MessagePack.MessagePackCode.Map16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Map32"/>.
            </summary>
            <param name="count">The number of key=value pairs that will be written in the map.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte"/> value using a 1-byte code when possible, otherwise as <see cref="F:MessagePack.MessagePackCode.UInt8"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteUInt8(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte"/> value using <see cref="F:MessagePack.MessagePackCode.UInt8"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.SByte)">
            <summary>
            Writes an 8-bit value using a 1-byte code when possible, otherwise as <see cref="F:MessagePack.MessagePackCode.Int8"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteInt8(System.SByte)">
            <summary>
            Writes an 8-bit value using <see cref="F:MessagePack.MessagePackCode.Int8"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16"/> value using a 1-byte code when possible, otherwise as <see cref="F:MessagePack.MessagePackCode.UInt8"/> or <see cref="F:MessagePack.MessagePackCode.UInt16"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteUInt16(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16"/> value using <see cref="F:MessagePack.MessagePackCode.UInt16"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>, or
            <see cref="F:MessagePack.MessagePackCode.Int16"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteInt16(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16"/> using <see cref="F:MessagePack.MessagePackCode.Int16"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.UInt32)">
            <summary>
            Writes an <see cref="T:System.UInt32"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>, or
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteUInt32(System.UInt32)">
            <summary>
            Writes an <see cref="T:System.UInt32"/> using <see cref="F:MessagePack.MessagePackCode.UInt32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Int32)">
            <summary>
            Writes an <see cref="T:System.Int32"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteInt32(System.Int32)">
            <summary>
            Writes an <see cref="T:System.Int32"/> using <see cref="F:MessagePack.MessagePackCode.Int32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.UInt64)">
            <summary>
            Writes an <see cref="T:System.UInt64"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteUInt64(System.UInt64)">
            <summary>
            Writes an <see cref="T:System.UInt64"/> using <see cref="F:MessagePack.MessagePackCode.Int32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Int64)">
            <summary>
            Writes an <see cref="T:System.Int64"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt64"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int64"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteInt64(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64"/> using <see cref="F:MessagePack.MessagePackCode.Int64"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Boolean)">
            <summary>
            Writes a <see cref="T:System.Boolean"/> value using either <see cref="F:MessagePack.MessagePackCode.True"/> or <see cref="F:MessagePack.MessagePackCode.False"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Char)">
            <summary>
            Writes a <see cref="T:System.Char"/> value using a 1-byte code when possible, otherwise as <see cref="F:MessagePack.MessagePackCode.UInt8"/> or <see cref="F:MessagePack.MessagePackCode.UInt16"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Single)">
            <summary>
            Writes a <see cref="F:MessagePack.MessagePackCode.Float32"/> value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Double)">
            <summary>
            Writes a <see cref="F:MessagePack.MessagePackCode.Float64"/> value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.DateTime)">
            <summary>
            Writes a <see cref="T:System.DateTime"/> using the message code <see cref="F:MessagePack.ReservedMessagePackExtensionTypeCode.DateTime"/>.
            </summary>
            <param name="dateTime">The value to write.</param>
            <exception cref="T:System.NotSupportedException">Thrown when <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> is true because the old spec does not define a <see cref="T:System.DateTime"/> format.</exception>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Byte[])">
            <summary>
            Writes a <see cref="T:System.Byte"/>[], prefixed with a length encoded as the smallest fitting from:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>,
            or <see cref="F:MessagePack.MessagePackCode.Nil"/> if <paramref name="src"/> is <c>null</c>.
            </summary>
            <param name="src">The array of bytes to write. May be <c>null</c>.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.ReadOnlySpan{System.Byte})">
            <summary>
            Writes a span of bytes, prefixed with a length encoded as the smallest fitting from:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>.
            </summary>
            <param name="src">The span of bytes to write.</param>
            <remarks>
            When <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> is <c>true</c>, the msgpack code used is <see cref="F:MessagePack.MessagePackCode.Str8"/>, <see cref="F:MessagePack.MessagePackCode.Str16"/> or <see cref="F:MessagePack.MessagePackCode.Str32"/> instead.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Writes a sequence of bytes, prefixed with a length encoded as the smallest fitting from:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>.
            </summary>
            <param name="src">The span of bytes to write.</param>
            <remarks>
            When <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> is <c>true</c>, the msgpack code used is <see cref="F:MessagePack.MessagePackCode.Str8"/>, <see cref="F:MessagePack.MessagePackCode.Str16"/> or <see cref="F:MessagePack.MessagePackCode.Str32"/> instead.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteBinHeader(System.Int32)">
            <summary>
            Writes the header that precedes a raw binary sequence with a length encoded as the smallest fitting from:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>.
            </summary>
            <param name="length">The length of bytes that will be written next.</param>
            <remarks>
            <para>
            The caller should use <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.Buffers.ReadOnlySequence{System.Byte}@)"/> or <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.ReadOnlySpan{System.Byte})"/>
            after calling this method to actually write the content.
            Alternatively a single call to <see cref="M:MessagePack.MessagePackWriter.Write(System.ReadOnlySpan{System.Byte})"/> or <see cref="M:MessagePack.MessagePackWriter.Write(System.Buffers.ReadOnlySequence{System.Byte}@)"/> will take care of the header and content in one call.
            </para>
            <para>
            When <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> is <c>true</c>, the msgpack code used is <see cref="F:MessagePack.MessagePackCode.Str8"/>, <see cref="F:MessagePack.MessagePackCode.Str16"/> or <see cref="F:MessagePack.MessagePackCode.Str32"/> instead.
            </para>
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteString(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Writes out an array of bytes that (may) represent a UTF-8 encoded string, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Str32"/>.
            </summary>
            <param name="utf8stringBytes">The bytes to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteString(System.ReadOnlySpan{System.Byte})">
            <summary>
            Writes out an array of bytes that (may) represent a UTF-8 encoded string, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Str32"/>.
            </summary>
            <param name="utf8stringBytes">The bytes to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteStringHeader(System.Int32)">
            <summary>
            Writes out the header that may precede a UTF-8 encoded string, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Str32"/>.
            </summary>
            <param name="byteCount">The number of bytes in the string that will follow this header.</param>
            <remarks>
            The caller should use <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.Buffers.ReadOnlySequence{System.Byte}@)"/> or <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.ReadOnlySpan{System.Byte})"/>
            after calling this method to actually write the content.
            Alternatively a single call to <see cref="M:MessagePack.MessagePackWriter.WriteString(System.ReadOnlySpan{System.Byte})"/> or <see cref="M:MessagePack.MessagePackWriter.WriteString(System.Buffers.ReadOnlySequence{System.Byte}@)"/> will take care of the header and content in one call.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.String)">
            <summary>
            Writes out a <see cref="T:System.String"/>, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or <see cref="F:MessagePack.MessagePackCode.Nil"/> if the <paramref name="value"/> is <c>null</c>.
            </summary>
            <param name="value">The value to write. May be null.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.ReadOnlySpan{System.Char})">
            <summary>
            Writes out a <see cref="T:System.String"/>, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteExtensionFormatHeader(MessagePack.ExtensionHeader)">
            <summary>
            Writes the extension format header, using the smallest one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>.
            </summary>
            <param name="extensionHeader">The extension header.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteExtensionFormat(MessagePack.ExtensionResult)">
            <summary>
            Writes an extension format, using the smallest one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>.
            </summary>
            <param name="extensionData">The extension data.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.GetSpan(System.Int32)">
            <summary>
            Gets memory where raw messagepack data can be written.
            </summary>
            <param name="length">The size of the memory block required.</param>
            <returns>The span of memory to write to. This *may* exceed <paramref name="length"/>.</returns>
            <remarks>
            <para>After initializing the resulting memory, always follow up with a call to <see cref="M:MessagePack.MessagePackWriter.Advance(System.Int32)"/>.</para>
            <para>
            This is similar in purpose to <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.ReadOnlySpan{System.Byte})"/>
            but provides uninitialized memory for the caller to write to instead of copying initialized memory from elsewhere.
            </para>
            </remarks>
            <seealso cref="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)"/>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Advance(System.Int32)">
            <summary>
            Commits memory previously returned from <see cref="M:MessagePack.MessagePackWriter.GetSpan(System.Int32)"/> as initialized.
            </summary>
            <param name="length">The number of bytes initialized with messagepack data from the previously returned span.</param>
            <seealso cref="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)"/>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteBigEndian(System.UInt16)">
            <summary>
            Writes a 16-bit integer in big endian format.
            </summary>
            <param name="value">The integer.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteBigEndian(System.UInt32)">
            <summary>
            Writes a 32-bit integer in big endian format.
            </summary>
            <param name="value">The integer.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteBigEndian(System.UInt64)">
            <summary>
            Writes a 64-bit integer in big endian format.
            </summary>
            <param name="value">The integer.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteString_PrepareSpan(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Estimates the length of the header required for a given string.
            </summary>
            <param name="characterLength">The length of the string to be written, in characters.</param>
            <param name="bufferSize">Receives the guaranteed length of the returned buffer.</param>
            <param name="encodedBytesOffset">Receives the offset within the returned buffer to write the encoded string to.</param>
            <returns>
            A reference to the first byte in the buffer.
            </returns>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteString_PostEncoding(System.Byte*,System.Int32,System.Int32)">
            <summary>
            Finalizes an encoding of a string.
            </summary>
            <param name="pBuffer">A pointer obtained from a prior call to <see cref="M:MessagePack.MessagePackWriter.WriteString_PrepareSpan(System.Int32,System.Int32@,System.Int32@)"/>.</param>
            <param name="estimatedOffset">The offset obtained from a prior call to <see cref="M:MessagePack.MessagePackWriter.WriteString_PrepareSpan(System.Int32,System.Int32@,System.Int32@)"/>.</param>
            <param name="byteCount">The number of bytes used to actually encode the string.</param>
        </member>
        <member name="T:MessagePack.SequencePool">
            <summary>
            A thread-safe, alloc-free reusable object pool.
            </summary>
        </member>
        <member name="F:MessagePack.SequencePool.Shared">
            <summary>
            A thread-safe pool of reusable <see cref="T:Nerdbank.Streams.Sequence`1"/> objects.
            </summary>
            <remarks>
            We use a <see cref="F:MessagePack.SequencePool.maxSize"/> that allows every processor to be involved in messagepack serialization concurrently,
            plus one nested serialization per processor (since LZ4 and sometimes other nested serializations may exist).
            </remarks>
        </member>
        <member name="F:MessagePack.SequencePool.MinimumSpanLength">
            <summary>
            The value to use for <see cref="P:Nerdbank.Streams.Sequence`1.MinimumSpanLength"/>.
            </summary>
            <remarks>
            Individual users that want a different value for this can modify the setting on the rented <see cref="T:Nerdbank.Streams.Sequence`1"/>
            or by supplying their own <see cref="T:System.Buffers.IBufferWriter`1" />.
            </remarks>
            <devremarks>
            We use 32KB so that when LZ4Codec.MaximumOutputLength is used on this length it does not require a
            buffer that would require the Large Object Heap.
            </devremarks>
        </member>
        <member name="F:MessagePack.SequencePool.arrayPool">
            <summary>
            The array pool which we share with all <see cref="T:Nerdbank.Streams.Sequence`1"/> objects created by this <see cref="T:MessagePack.SequencePool"/> instance.
            </summary>
            <devremarks>
            We allow 100 arrays to be shared (instead of the default 50) and reduce the max array length from the default 1MB to something more reasonable for our expected use.
            </devremarks>
        </member>
        <member name="M:MessagePack.SequencePool.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.SequencePool"/> class.
            </summary>
            <param name="maxSize">The maximum size to allow the pool to grow.</param>
        </member>
        <member name="M:MessagePack.SequencePool.Rent">
            <summary>
            Gets an instance of <see cref="T:Nerdbank.Streams.Sequence`1"/>
            This is taken from the recycled pool if one is available; otherwise a new one is created.
            </summary>
            <returns>The rental tracker that provides access to the object as well as a means to return it.</returns>
        </member>
        <member name="P:MessagePack.SequencePool.Rental.Value">
            <summary>
            Gets the recyclable object.
            </summary>
        </member>
        <member name="M:MessagePack.SequencePool.Rental.Dispose">
            <summary>
            Returns the recyclable object to the pool.
            </summary>
            <remarks>
            The instance is cleaned first, if a clean delegate was provided.
            It is dropped instead of being returned to the pool if the pool is already at its maximum size.
            </remarks>
        </member>
        <member name="F:MessagePack.SequenceReader`1.usingSequence">
            <summary>
            A value indicating whether we're using <see cref="F:MessagePack.SequenceReader`1.sequence"/> (as opposed to <see cref="F:MessagePack.SequenceReader`1.memory"/>.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.sequence">
            <summary>
            Backing for the entire sequence when we're not using <see cref="F:MessagePack.SequenceReader`1.memory"/>.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.currentPosition">
            <summary>
            The position at the start of the <see cref="P:MessagePack.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.nextPosition">
            <summary>
            The position at the end of the <see cref="P:MessagePack.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.memory">
            <summary>
            Backing for the entire sequence when we're not using <see cref="F:MessagePack.SequenceReader`1.sequence"/>.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.moreData">
            <summary>
            A value indicating whether there is unread data remaining.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.length">
            <summary>
            The total number of elements in the sequence.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.SequenceReader`1"/> struct
            over the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.#ctor(System.ReadOnlyMemory{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.SequenceReader`1"/> struct
            over the given <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.End">
            <summary>
            Gets a value indicating whether there is no more data in the <see cref="P:MessagePack.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.Sequence">
            <summary>
            Gets the underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/> for the reader.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.Position">
            <summary>
            Gets the current position in the <see cref="P:MessagePack.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.CurrentSpan">
            <summary>
            Gets the current segment in the <see cref="P:MessagePack.SequenceReader`1.Sequence"/> as a span.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.CurrentSpanIndex">
            <summary>
            Gets the index in the <see cref="P:MessagePack.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.UnreadSpan">
            <summary>
            Gets the unread portion of the <see cref="P:MessagePack.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.Consumed">
            <summary>
            Gets the total number of <typeparamref name="T"/>'s processed by the reader.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.Remaining">
            <summary>
            Gets remaining <typeparamref name="T"/>'s in the reader's <see cref="P:MessagePack.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.Length">
            <summary>
            Gets count of <typeparamref name="T"/> in the reader's <see cref="P:MessagePack.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.TryPeek(`0@)">
            <summary>
            Peeks at the next value without advancing the reader.
            </summary>
            <param name="value">The next value or default if at the end.</param>
            <returns>False if at the end of the reader.</returns>
        </member>
        <member name="M:MessagePack.SequenceReader`1.TryRead(`0@)">
            <summary>
            Read the next value and advance the reader.
            </summary>
            <param name="value">The next value or default if at the end.</param>
            <returns>False if at the end of the reader.</returns>
        </member>
        <member name="M:MessagePack.SequenceReader`1.Rewind(System.Int64)">
            <summary>
            Move the reader back the specified number of items.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.GetNextSpan">
            <summary>
            Get the next segment with available data, if any.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.Advance(System.Int64)">
            <summary>
            Move the reader ahead the specified number of items.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.AdvanceCurrentSpan(System.Int64)">
            <summary>
            Unchecked helper to avoid unnecessary checks where you know count is valid.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.AdvanceWithinSpan(System.Int64)">
            <summary>
            Only call this helper if you know that you are advancing in the current span
            with valid count and there is no need to fetch the next one.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.TryAdvance(System.Int64)">
            <summary>
            Move the reader ahead the specified number of items
            if there are enough elements remaining in the sequence.
            </summary>
            <returns><c>true</c> if there were enough elements to advance; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReader`1.TryCopyTo(System.Span{`0})">
            <summary>
            Copies data from the current <see cref="P:MessagePack.SequenceReader`1.Position"/> to the given <paramref name="destination"/> span.
            </summary>
            <param name="destination">Destination to copy to.</param>
            <returns>True if there is enough data to copy to the <paramref name="destination"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryRead``1(MessagePack.SequenceReader{System.Byte}@,``0@)">
            <summary>
            Try to read the given type out of the buffer if possible. Warning: this is dangerous to use with arbitrary
            structs- see remarks for full details.
            </summary>
            <remarks>
            IMPORTANT: The read is a straight copy of bits. If a struct depends on specific state of its members to
            behave correctly this can lead to exceptions, etc. If reading endian specific integers, use the explicit
            overloads such as <see cref="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Int16@)"/>.
            </remarks>
            <returns>
            True if successful. <paramref name="value"/> will be default if failed (due to lack of space).
            </returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryRead(MessagePack.SequenceReader{System.Byte}@,System.SByte@)">
            <summary>
            Reads an <see cref="T:System.SByte"/> from the next position in the sequence.
            </summary>
            <param name="reader">The reader to read from.</param>
            <param name="value">Receives the value read.</param>
            <returns><c>true</c> if there was another byte in the sequence; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Int16@)">
            <summary>
            Reads an <see cref="T:System.Int16"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int16"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.UInt16@)">
            <summary>
            Reads an <see cref="T:System.UInt16"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt16"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Int32@)">
            <summary>
            Reads an <see cref="T:System.Int32"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int32"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.UInt32@)">
            <summary>
            Reads an <see cref="T:System.UInt32"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt32"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Int64@)">
            <summary>
            Reads an <see cref="T:System.Int64"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.UInt64@)">
            <summary>
            Reads an <see cref="T:System.UInt64"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt64"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Single@)">
            <summary>
            Reads a <see cref="T:System.Single"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for a <see cref="T:System.Single"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Double@)">
            <summary>
            Reads a <see cref="T:System.Double"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for a <see cref="T:System.Double"/>.</returns>
        </member>
        <member name="T:MessagePack.Utilities">
            <summary>
            Internal utilities and extension methods for various external types.
            </summary>
        </member>
        <member name="F:MessagePack.Utilities.IsMono">
            <summary>
            A value indicating whether we're running on mono.
            </summary>
        </member>
        <member name="T:MessagePack.MessagePackStreamReader">
            <summary>
            Reads one or more messagepack data structures from a <see cref="T:System.IO.Stream"/>.
            </summary>
            <remarks>
            This class is *not* thread-safe. Do not call more than one member at once and be sure any call completes (including asynchronous tasks)
            before calling the next one.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackStreamReader"/> class.
            </summary>
            <param name="stream">The stream to read from. This stream will be disposed of when this <see cref="T:MessagePack.MessagePackStreamReader"/> is disposed.</param>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackStreamReader"/> class.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="leaveOpen">If true, leaves the stream open after this <see cref="T:MessagePack.MessagePackStreamReader"/> is disposed; otherwise, false.</param>
        </member>
        <member name="P:MessagePack.MessagePackStreamReader.RemainingBytes">
            <summary>
            Gets any bytes that have been read since the last complete message returned from <see cref="M:MessagePack.MessagePackStreamReader.ReadAsync(System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackStreamReader.ReadData">
            <summary>
            Gets the sequence that we read data from the <see cref="F:MessagePack.MessagePackStreamReader.stream"/> into.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.ReadAsync(System.Threading.CancellationToken)">
            <summary>
            Reads the next whole (top-level) messagepack data structure.
            </summary>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>
            A task whose result is the next whole data structure from the stream, or <c>null</c> if the stream ends.
            The returned sequence is valid until this <see cref="T:MessagePack.MessagePackStreamReader"/> is disposed or
            until this method is called again, whichever comes first.
            </returns>
            <remarks>
            When <c>null</c> is the result of the returned task,
            any extra bytes read (between the last complete message and the end of the stream) will be available via the <see cref="P:MessagePack.MessagePackStreamReader.RemainingBytes"/> property.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.DiscardBufferedData">
            <summary>
            Arranges for the next read operation to start by reading from the underlying <see cref="T:System.IO.Stream"/>
            instead of any data buffered from a previous read.
            </summary>
            <remarks>
            This is appropriate if the underlying <see cref="T:System.IO.Stream"/> has been repositioned such that
            any previously buffered data is no longer applicable to what the caller wants to read.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.RecycleLastMessage">
            <summary>
            Recycle memory from a previously returned message.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.TryReadMoreDataAsync(System.Threading.CancellationToken)">
            <summary>
            Read more data from the stream into the <see cref="P:MessagePack.MessagePackStreamReader.ReadData"/> buffer.
            </summary>
            <param name="cancellationToken">A cancellation token.</param>
            <returns><c>true</c> if more data was read; <c>false</c> if the end of the stream had already been reached.</returns>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.TryReadNextMessage(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Checks whether the content in <see cref="P:MessagePack.MessagePackStreamReader.ReadData"/> include a complete messagepack structure.
            </summary>
            <param name="completeMessage">Receives the sequence of the first complete data structure found, if any.</param>
            <returns><c>true</c> if a complete data structure was found; <c>false</c> otherwise.</returns>
        </member>
    </members>
</doc>
